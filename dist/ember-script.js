// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v1.6.2',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/src/browser.coffee', function (module, exports, __dirname, __filename) {
    var EmberScript, runScripts;
    module.exports = EmberScript = require('/src/module.coffee', module);
    global.EmberScript = EmberScript;
    EmberScript['eval'] = function (code, options) {
      if (null == options)
        options = {};
      if (null != options.bare)
        options.bare;
      else
        options.bare = true;
      if (null != options.optimise)
        options.optimise;
      else
        options.optimise = true;
      return eval(EmberScript.em2js(code, options));
    };
    EmberScript.run = function (code, options) {
      if (null == options)
        options = {};
      options.bare = true;
      if (null != options.optimise)
        options.optimise;
      else
        options.optimise = true;
      return Function(EmberScript.em2js(code, options))();
    };
    EmberScript.load = function (url, callback) {
      var xhr;
      xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP') : new XMLHttpRequest;
      xhr.open('GET', url, true);
      if ('overrideMimeType' in xhr)
        xhr.overrideMimeType('text/plain');
      xhr.onreadystatechange = function () {
        if (!(xhr.readyState === xhr.DONE))
          return;
        if (xhr.status === 0 || xhr.status === 200) {
          EmberScript.run(xhr.responseText);
        } else {
          throw new Error('Could not load ' + url);
        }
        if (callback)
          return callback();
      };
      return xhr.send(null);
    };
    runScripts = function () {
      var coffees, execute, index, s, scripts;
      scripts = document.getElementsByTagName('script');
      coffees = function (accum$) {
        for (var i$ = 0, length$ = scripts.length; i$ < length$; ++i$) {
          s = scripts[i$];
          if (!(s.type === 'text/emberscript'))
            continue;
          accum$.push(s);
        }
        return accum$;
      }.call(this, []);
      index = 0;
      (execute = function () {
        var script;
        if (!(script = coffees[index++]))
          return;
        if (script.src) {
          return EmberScript.load(script.src, execute);
        } else {
          EmberScript.run(script.innerHTML);
          return execute();
        }
      })();
      return null;
    };
    if ('undefined' !== typeof addEventListener && null != addEventListener) {
      addEventListener('DOMContentLoaded', runScripts, false);
    } else if ('undefined' !== typeof attachEvent && null != attachEvent) {
      attachEvent('onload', runScripts);
    }
  });
  require.define('/src/module.coffee', function (module, exports, __dirname, __filename) {
    var CoffeeScript, Compiler, cscodegen, escodegen, escodegenFormat, ext, formatParserError, Nodes, Optimiser, Parser, pkg, Preprocessor;
    formatParserError = require('/src/helpers.coffee', module).formatParserError;
    Nodes = require('/src/nodes.coffee', module);
    Preprocessor = require('/src/preprocessor.coffee', module).Preprocessor;
    Parser = require('/src/parser.coffee', module);
    Optimiser = require('/src/optimiser.coffee', module).Optimiser;
    Compiler = require('/src/compiler.coffee', module).Compiler;
    cscodegen = function () {
      try {
        return require('/node_modules/cscodegen/lib/cscodegen.js', module);
      } catch (e$) {
        return;
      }
    }.call(this);
    escodegen = function () {
      try {
        return require('/node_modules/escodegen/escodegen.js', module);
      } catch (e$1) {
        return;
      }
    }.call(this);
    pkg = require('/package.json', module);
    escodegenFormat = {
      indent: {
        style: '  ',
        base: 0
      },
      renumber: true,
      hexadecimal: true,
      quotes: 'auto',
      parentheses: false
    };
    CoffeeScript = {
      CoffeeScript: CoffeeScript,
      Compiler: Compiler,
      Optimiser: Optimiser,
      Parser: Parser,
      Preprocessor: Preprocessor,
      Nodes: Nodes,
      VERSION: pkg.version,
      parse: function (coffee, options) {
        var e, parsed, preprocessed;
        if (null == options)
          options = {};
        try {
          preprocessed = Preprocessor.process(coffee, { literate: options.literate });
          parsed = Parser.parse(preprocessed, {
            raw: options.raw,
            inputSource: options.inputSource
          });
          if (options.optimise) {
            return Optimiser.optimise(parsed);
          } else {
            return parsed;
          }
        } catch (e$2) {
          e = e$2;
          if (!(e instanceof Parser.SyntaxError))
            throw e;
          throw new Error(formatParserError(preprocessed, e));
        }
      },
      compile: function (csAst, options) {
        return Compiler.compile(csAst, options).toBasicObject();
      },
      cs: function (csAst, options) {
      },
      jsWithSourceMap: function (jsAst, name, options) {
        var targetName;
        if (null == name)
          name = 'unknown';
        if (null == options)
          options = {};
        if (!(null != escodegen))
          throw new Error('escodegen not found: run `npm install escodegen`');
        if (!{}.hasOwnProperty.call(jsAst, 'type'))
          jsAst = jsAst.toBasicObject();
        targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
        return escodegen.generate(jsAst, {
          comment: !options.compact,
          sourceMapWithCode: true,
          sourceMap: name,
          file: targetName || 'unknown',
          format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat,
          verbatim: 'verbatim'
        });
      },
      js: function (jsAst, options) {
        return this.jsWithSourceMap(jsAst, null, options).code;
      },
      sourceMap: function (jsAst, name, options) {
        return this.jsWithSourceMap(jsAst, name, options).map;
      },
      em2js: function (input, options) {
        var csAST, jsAST;
        if (null == options)
          options = {};
        if (null != options.optimise)
          options.optimise;
        else
          options.optimise = true;
        csAST = this.parse(input, options);
        jsAST = this.compile(csAST, { bare: options.bare });
        return this.js(jsAST, { compact: options.compact || options.minify });
      }
    };
    module.exports = CoffeeScript;
    if (null != (null != require.extensions ? require.extensions['.node'] : void 0)) {
      CoffeeScript.register = function () {
        return require('/src/register.coffee', module);
      };
      for (var cache$ = [
            '.em',
            '.litem'
          ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
        ext = cache$[i$];
        if (null != require.extensions[ext])
          require.extensions[ext];
        else
          require.extensions[ext] = function () {
            throw new Error('Use EmberScript.register() or require the ember-script/register module to require ' + ext + ' files.');
          };
      }
    }
  });
  require.define('/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'name': 'ember-script',
      'description': 'Ember-infused CoffeeScript',
      'keywords': [
        'javascript',
        'language',
        'coffeescript',
        'compiler',
        'ember.js'
      ],
      'author': 'Gordon L. Hempton, Michael Ficarra',
      'version': '0.0.14',
      'main': './lib/module',
      'bin': { 'ember-script': './bin/ember-script' },
      'homepage': 'https://github.com/ghempton/ember-script',
      'bugs': 'https://github.com/ghempton/ember-script/issues',
      'repository': {
        'type': 'git',
        'url': 'git://github.com/ghempton/ember-script.git'
      },
      'scripts': {
        'build': 'make -j build',
        'test': 'make -j test'
      },
      'devDependencies': {
        'cluster': '~0.7.7',
        'coffee-script-redux': 'git://github.com/michaelficarra/CoffeeScriptRedux.git',
        'commonjs-everywhere': '~0.9.0',
        'mocha': '~1.12.0',
        'pegjs': 'git://github.com/dmajda/pegjs.git#bea6b1fde74c8aebf802f9bcc3380c65b241e1b7',
        'semver': '~2.1.0'
      },
      'dependencies': {
        'StringScanner': '~0.0.3',
        'lodash': '^3.6.0',
        'nopt': '~2.1.2'
      },
      'optionalDependencies': {
        'esmangle': '~1.0.0',
        'source-map': '0.1.x',
        'escodegen': '~1.2.0',
        'cscodegen': 'git://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383'
      },
      'engines': { 'node': '0.8.x || 0.10.x' },
      'licenses': [{
          'type': '3-clause BSD',
          'url': 'https://raw.github.com/ghempton/ember-script/master/LICENSE'
        }]
    };
  });
  require.define('/node_modules/escodegen/escodegen.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse = require('/node_modules/escodegen/node_modules/estraverse/estraverse.js', module);
      esutils = require('/node_modules/escodegen/node_modules/esutils/lib/utils.js', module);
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
      };
      BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
      };
      function getDefaultOptions() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: '    ',
              base: 0,
              adjustMultilineComment: false
            },
            newline: '\n',
            space: ' ',
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: 'single',
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false,
            parenthesizedComprehensionBlock: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          verbatim: null
        };
      }
      function stringRepeat(str, num) {
        var result = '';
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function hasLineTerminator(str) {
        return /[\r\n]/g.test(str);
      }
      function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target) {
          return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
          throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
          throw new Error('Numeric literal whose value is negative');
        }
        if (value === 1 / 0) {
          return json ? 'null' : renumber ? '1e400' : '1e+400';
        }
        result = '' + value;
        if (!renumber || result.length < 3) {
          return result;
        }
        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 48 && point === 1) {
          point = 0;
          result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
          exponent = +temp.slice(pos + 1);
          temp = temp.slice(0, pos);
        }
        if (point >= 0) {
          exponent -= temp.length - point - 1;
          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 48) {
          --pos;
        }
        if (pos !== 0) {
          exponent -= pos;
          temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
          temp += 'e' + exponent;
        }
        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
          result = temp;
        }
        return result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        if ((ch & ~1) === 8232) {
          return (previousIsBackslash ? 'u' : '\\u') + (ch === 8232 ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {
          return (previousIsBackslash ? '' : '\\') + (ch === 10 ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
          match = result.match(/\/([^\/]*)$/);
          if (!match) {
            return result;
          }
          flags = match[1];
          result = '';
          characterInBrack = false;
          previousIsBackslash = false;
          for (i = 0, iz = reg.source.length; i < iz; ++i) {
            ch = reg.source.charCodeAt(i);
            if (!previousIsBackslash) {
              if (characterInBrack) {
                if (ch === 93) {
                  characterInBrack = false;
                }
              } else {
                if (ch === 47) {
                  result += '\\';
                } else if (ch === 91) {
                  characterInBrack = true;
                }
              }
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = ch === 92;
            } else {
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = false;
            }
          }
          return '/' + result + '/' + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';
        switch (code) {
        case 8:
          result += 'b';
          break;
        case 12:
          result += 'f';
          break;
        case 9:
          result += 't';
          break;
        default:
          hex = code.toString(16).toUpperCase();
          if (json || code > 255) {
            result += 'u' + '0000'.slice(hex.length) + hex;
          } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
            result += '0';
          } else if (code === 11) {
            result += 'x0B';
          } else {
            result += 'x' + '00'.slice(hex.length) + hex;
          }
          break;
        }
        return result;
      }
      function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 92:
          result += '\\';
          break;
        case 10:
          result += 'n';
          break;
        case 13:
          result += 'r';
          break;
        case 8232:
          result += 'u2028';
          break;
        case 8233:
          result += 'u2029';
          break;
        default:
          throw new Error('Incorrectly classified character');
        }
        return result;
      }
      function escapeDirective(str) {
        var i, iz, code, quote;
        quote = quotes === 'double' ? '"' : "'";
        for (i = 0, iz = str.length; i < iz; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            quote = '"';
            break;
          } else if (code === 34) {
            quote = "'";
            break;
          } else if (code === 92) {
            ++i;
          }
        }
        return quote + str + quote;
      }
      function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            ++singleQuotes;
          } else if (code === 34) {
            ++doubleQuotes;
          } else if (code === 47 && json) {
            result += '\\';
          } else if (esutils.code.isLineTerminator(code) || code === 92) {
            result += escapeDisallowedCharacter(code);
            continue;
          } else if (json && code < 32 || !(json || escapeless || code >= 32 && code <= 126)) {
            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
            continue;
          }
          result += String.fromCharCode(code);
        }
        single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
        quote = single ? "'" : '"';
        if (!(single ? singleQuotes : doubleQuotes)) {
          return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39 && single || code === 34 && !single) {
            result += '\\';
          }
          result += String.fromCharCode(code);
        }
        return result + quote;
      }
      function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
          elem = arr[i];
          result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
          if (isArray(generated)) {
            return flattenToString(generated);
          } else {
            return generated;
          }
        }
        if (node == null) {
          if (generated instanceof SourceNode) {
            return generated;
          } else {
            node = {};
          }
        }
        if (node.loc == null) {
          return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
      }
      function noEmptySpace() {
        return space ? space : ' ';
      }
      function join(left, right) {
        var leftSource = toSourceNodeWhenNeeded(left).toString(), rightSource = toSourceNodeWhenNeeded(right).toString(), leftCharCode = leftSource.charCodeAt(leftSource.length - 1), rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
          return [
            left,
            noEmptySpace(),
            right
          ];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
          return [
            left,
            right
          ];
        }
        return [
          left,
          space,
          right
        ];
      }
      function addIndent(stmt) {
        return [
          base,
          stmt
        ];
      }
      function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
      }
      function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
            break;
          }
        }
        return str.length - 1 - i;
      }
      function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;
        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array.length; i < len; ++i) {
          line = array[i];
          j = 0;
          while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
            ++j;
          }
          if (spaces > j) {
            spaces = j;
          }
        }
        if (typeof specialBase !== 'undefined') {
          previousBase = base;
          if (array[1][spaces] === '*') {
            specialBase += ' ';
          }
          base = specialBase;
        } else {
          if (spaces & 1) {
            --spaces;
          }
          previousBase = base;
        }
        for (i = 1, len = array.length; i < len; ++i) {
          sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
          array[i] = sourceMap ? sn.join('') : sn;
        }
        base = previousBase;
        return array.join('\n');
      }
      function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
          if (endsWithLineTerminator(comment.value)) {
            return '//' + comment.value;
          } else {
            return '//' + comment.value + '\n';
          }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
          return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
      }
      function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          save = result;
          comment = stmt.leadingComments[0];
          result = [];
          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
            result.push('\n');
          }
          result.push(generateComment(comment));
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push('\n');
          }
          for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
            comment = stmt.leadingComments[i];
            fragment = [generateComment(comment)];
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              fragment.push('\n');
            }
            result.push(addIndent(fragment));
          }
          result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([
            base,
            result,
            indent
          ]).toString()));
          for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
            comment = stmt.trailingComments[i];
            if (tailingToStatement) {
              if (i === 0) {
                result = [
                  result,
                  indent
                ];
              } else {
                result = [
                  result,
                  specialBase
                ];
              }
              result.push(generateComment(comment, specialBase));
            } else {
              result = [
                result,
                addIndent(generateComment(comment))
              ];
            }
            if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result = [
                result,
                '\n'
              ];
            }
          }
        }
        return result;
      }
      function parenthesize(text, current, should) {
        if (current < should) {
          return [
            '(',
            text,
            ')'
          ];
        }
        return text;
      }
      function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;
        noLeadingComment = !extra.comment || !stmt.leadingComments;
        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
          return [
            space,
            generateStatement(stmt, { functionBody: functionBody })
          ];
        }
        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
          return ';';
        }
        withIndent(function () {
          result = [
            newline,
            addIndent(generateStatement(stmt, {
              semicolonOptional: semicolonOptional,
              functionBody: functionBody
            }))
          ];
        });
        return result;
      }
      function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
          return [
            result,
            space
          ];
        }
        if (ends) {
          return [
            result,
            base
          ];
        }
        return [
          result,
          newline,
          base
        ];
      }
      function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
          result[i] = newline + base + result[i];
        }
        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNodeWhenNeeded(result, expr);
      }
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generatePattern(node, options) {
        var result;
        if (node.type === Syntax.Identifier) {
          result = generateIdentifier(node);
        } else {
          result = generateExpression(node, {
            precedence: options.precedence,
            allowIn: options.allowIn,
            allowCall: true
          });
        }
        return result;
      }
      function generateFunctionBody(node) {
        var result, i, len, expr, arrow;
        arrow = node.type === Syntax.ArrowFunctionExpression;
        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
          result = [generateIdentifier(node.params[0])];
        } else {
          result = ['('];
          for (i = 0, len = node.params.length; i < len; ++i) {
            result.push(generatePattern(node.params[i], {
              precedence: Precedence.Assignment,
              allowIn: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result.push(')');
        }
        if (arrow) {
          result.push(space);
          result.push('=>');
        }
        if (node.expression) {
          result.push(space);
          expr = generateExpression(node.body, {
            precedence: Precedence.Assignment,
            allowIn: true,
            allowCall: true
          });
          if (expr.toString().charAt(0) === '{') {
            expr = [
              '(',
              expr,
              ')'
            ];
          }
          result.push(expr);
        } else {
          result.push(maybeBlock(node.body, false, true));
        }
        return result;
      }
      function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
        var result = ['for' + space + '('];
        withIndent(function () {
          if (stmt.left.type === Syntax.VariableDeclaration) {
            withIndent(function () {
              result.push(stmt.left.kind + noEmptySpace());
              result.push(generateStatement(stmt.left.declarations[0], { allowIn: false }));
            });
          } else {
            result.push(generateExpression(stmt.left, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true
            }));
          }
          result = join(result, operator);
          result = [
            join(result, generateExpression(stmt.right, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })),
            ')'
          ];
        });
        result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
        return result;
      }
      function generateExpression(expr, option) {
        var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftCharCode, leftSource, rightCharCode, allowIn, allowCall, allowUnparenthesizedNew, property, isGenerator;
        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;
        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
          return generateVerbatim(expr, option);
        }
        switch (type) {
        case Syntax.SequenceExpression:
          result = [];
          allowIn |= Precedence.Sequence < precedence;
          for (i = 0, len = expr.expressions.length; i < len; ++i) {
            result.push(generateExpression(expr.expressions[i], {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result = parenthesize(result, Precedence.Sequence, precedence);
          break;
        case Syntax.AssignmentExpression:
          allowIn |= Precedence.Assignment < precedence;
          result = parenthesize([
            generateExpression(expr.left, {
              precedence: Precedence.Call,
              allowIn: allowIn,
              allowCall: true
            }),
            space + expr.operator + space,
            generateExpression(expr.right, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            })
          ], Precedence.Assignment, precedence);
          break;
        case Syntax.ArrowFunctionExpression:
          allowIn |= Precedence.ArrowFunction < precedence;
          result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
          break;
        case Syntax.ConditionalExpression:
          allowIn |= Precedence.Conditional < precedence;
          result = parenthesize([
            generateExpression(expr.test, {
              precedence: Precedence.LogicalOR,
              allowIn: allowIn,
              allowCall: true
            }),
            space + '?' + space,
            generateExpression(expr.consequent, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            }),
            space + ':' + space,
            generateExpression(expr.alternate, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            })
          ], Precedence.Conditional, precedence);
          break;
        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
          currentPrecedence = BinaryPrecedence[expr.operator];
          allowIn |= currentPrecedence < precedence;
          fragment = generateExpression(expr.left, {
            precedence: currentPrecedence,
            allowIn: allowIn,
            allowCall: true
          });
          leftSource = fragment.toString();
          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
            result = [
              fragment,
              noEmptySpace(),
              expr.operator
            ];
          } else {
            result = join(fragment, expr.operator);
          }
          fragment = generateExpression(expr.right, {
            precedence: currentPrecedence + 1,
            allowIn: allowIn,
            allowCall: true
          });
          if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result = join(result, fragment);
          }
          if (expr.operator === 'in' && !allowIn) {
            result = [
              '(',
              result,
              ')'
            ];
          } else {
            result = parenthesize(result, currentPrecedence, precedence);
          }
          break;
        case Syntax.CallExpression:
          result = [generateExpression(expr.callee, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true,
              allowUnparenthesizedNew: false
            })];
          result.push('(');
          for (i = 0, len = expr['arguments'].length; i < len; ++i) {
            result.push(generateExpression(expr['arguments'][i], {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result.push(')');
          if (!allowCall) {
            result = [
              '(',
              result,
              ')'
            ];
          } else {
            result = parenthesize(result, Precedence.Call, precedence);
          }
          break;
        case Syntax.NewExpression:
          len = expr['arguments'].length;
          allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;
          result = join('new', generateExpression(expr.callee, {
            precedence: Precedence.New,
            allowIn: true,
            allowCall: false,
            allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
          }));
          if (!allowUnparenthesizedNew || parentheses || len > 0) {
            result.push('(');
            for (i = 0; i < len; ++i) {
              result.push(generateExpression(expr['arguments'][i], {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
              }));
              if (i + 1 < len) {
                result.push(',' + space);
              }
            }
            result.push(')');
          }
          result = parenthesize(result, Precedence.New, precedence);
          break;
        case Syntax.MemberExpression:
          result = [generateExpression(expr.object, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: allowCall,
              allowUnparenthesizedNew: false
            })];
          if (expr.computed) {
            result.push('[');
            result.push(generateExpression(expr.property, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: allowCall
            }));
            result.push(']');
          } else {
            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                result.push('.');
              }
            }
            result.push('.');
            result.push(generateIdentifier(expr.property));
          }
          result = parenthesize(result, Precedence.Member, precedence);
          break;
        case Syntax.UnaryExpression:
          fragment = generateExpression(expr.argument, {
            precedence: Precedence.Unary,
            allowIn: true,
            allowCall: true
          });
          if (space === '') {
            result = join(expr.operator, fragment);
          } else {
            result = [expr.operator];
            if (expr.operator.length > 2) {
              result = join(result, fragment);
            } else {
              leftSource = toSourceNodeWhenNeeded(result).toString();
              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
              rightCharCode = fragment.toString().charCodeAt(0);
              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode)) {
                result.push(noEmptySpace());
                result.push(fragment);
              } else {
                result.push(fragment);
              }
            }
          }
          result = parenthesize(result, Precedence.Unary, precedence);
          break;
        case Syntax.YieldExpression:
          if (expr.delegate) {
            result = 'yield*';
          } else {
            result = 'yield';
          }
          if (expr.argument) {
            result = join(result, generateExpression(expr.argument, {
              precedence: Precedence.Yield,
              allowIn: true,
              allowCall: true
            }));
          }
          result = parenthesize(result, Precedence.Yield, precedence);
          break;
        case Syntax.UpdateExpression:
          if (expr.prefix) {
            result = parenthesize([
              expr.operator,
              generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
              })
            ], Precedence.Unary, precedence);
          } else {
            result = parenthesize([
              generateExpression(expr.argument, {
                precedence: Precedence.Postfix,
                allowIn: true,
                allowCall: true
              }),
              expr.operator
            ], Precedence.Postfix, precedence);
          }
          break;
        case Syntax.FunctionExpression:
          isGenerator = expr.generator && !extra.moz.starlessGenerator;
          result = isGenerator ? 'function*' : 'function';
          if (expr.id) {
            result = [
              result,
              isGenerator ? space : noEmptySpace(),
              generateIdentifier(expr.id),
              generateFunctionBody(expr)
            ];
          } else {
            result = [
              result + space,
              generateFunctionBody(expr)
            ];
          }
          break;
        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
          if (!expr.elements.length) {
            result = '[]';
            break;
          }
          multiline = expr.elements.length > 1;
          result = [
            '[',
            multiline ? newline : ''
          ];
          withIndent(function (indent) {
            for (i = 0, len = expr.elements.length; i < len; ++i) {
              if (!expr.elements[i]) {
                if (multiline) {
                  result.push(indent);
                }
                if (i + 1 === len) {
                  result.push(',');
                }
              } else {
                result.push(multiline ? indent : '');
                result.push(generateExpression(expr.elements[i], {
                  precedence: Precedence.Assignment,
                  allowIn: true,
                  allowCall: true
                }));
              }
              if (i + 1 < len) {
                result.push(',' + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : '');
          result.push(']');
          break;
        case Syntax.Property:
          if (expr.kind === 'get' || expr.kind === 'set') {
            result = [
              expr.kind,
              noEmptySpace(),
              generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              generateFunctionBody(expr.value)
            ];
          } else {
            if (expr.shorthand) {
              result = generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              });
            } else if (expr.method) {
              result = [];
              if (expr.value.generator) {
                result.push('*');
              }
              result.push(generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(generateFunctionBody(expr.value));
            } else {
              result = [
                generateExpression(expr.key, {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                }),
                ':' + space,
                generateExpression(expr.value, {
                  precedence: Precedence.Assignment,
                  allowIn: true,
                  allowCall: true
                })
              ];
            }
          }
          break;
        case Syntax.ObjectExpression:
          if (!expr.properties.length) {
            result = '{}';
            break;
          }
          multiline = expr.properties.length > 1;
          withIndent(function () {
            fragment = generateExpression(expr.properties[0], {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true,
              type: Syntax.Property
            });
          });
          if (!multiline) {
            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result = [
                '{',
                space,
                fragment,
                space,
                '}'
              ];
              break;
            }
          }
          withIndent(function (indent) {
            result = [
              '{',
              newline,
              indent,
              fragment
            ];
            if (multiline) {
              result.push(',' + newline);
              for (i = 1, len = expr.properties.length; i < len; ++i) {
                result.push(indent);
                result.push(generateExpression(expr.properties[i], {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true,
                  type: Syntax.Property
                }));
                if (i + 1 < len) {
                  result.push(',' + newline);
                }
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base);
          result.push('}');
          break;
        case Syntax.ObjectPattern:
          if (!expr.properties.length) {
            result = '{}';
            break;
          }
          multiline = false;
          if (expr.properties.length === 1) {
            property = expr.properties[0];
            if (property.value.type !== Syntax.Identifier) {
              multiline = true;
            }
          } else {
            for (i = 0, len = expr.properties.length; i < len; ++i) {
              property = expr.properties[i];
              if (!property.shorthand) {
                multiline = true;
                break;
              }
            }
          }
          result = [
            '{',
            multiline ? newline : ''
          ];
          withIndent(function (indent) {
            for (i = 0, len = expr.properties.length; i < len; ++i) {
              result.push(multiline ? indent : '');
              result.push(generateExpression(expr.properties[i], {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              if (i + 1 < len) {
                result.push(',' + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : '');
          result.push('}');
          break;
        case Syntax.ThisExpression:
          result = 'this';
          break;
        case Syntax.Identifier:
          result = generateIdentifier(expr);
          break;
        case Syntax.Literal:
          if (expr.hasOwnProperty('raw') && parse) {
            try {
              raw = parse(expr.raw).body[0].expression;
              if (raw.type === Syntax.Literal) {
                if (raw.value === expr.value) {
                  result = expr.raw;
                  break;
                }
              }
            } catch (e) {
            }
          }
          if (expr.value === null) {
            result = 'null';
            break;
          }
          if (typeof expr.value === 'string') {
            result = escapeString(expr.value);
            break;
          }
          if (typeof expr.value === 'number') {
            result = generateNumber(expr.value);
            break;
          }
          if (typeof expr.value === 'boolean') {
            result = expr.value ? 'true' : 'false';
            break;
          }
          result = generateRegExp(expr.value);
          break;
        case Syntax.GeneratorExpression:
        case Syntax.ComprehensionExpression:
          result = type === Syntax.GeneratorExpression ? ['('] : ['['];
          if (extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = generateExpression(expr.body, {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            });
            result.push(fragment);
          }
          if (expr.blocks) {
            withIndent(function () {
              for (i = 0, len = expr.blocks.length; i < len; ++i) {
                fragment = generateExpression(expr.blocks[i], {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                });
                if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                  result = join(result, fragment);
                } else {
                  result.push(fragment);
                }
              }
            });
          }
          if (expr.filter) {
            result = join(result, 'if' + space);
            fragment = generateExpression(expr.filter, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            });
            if (extra.moz.parenthesizedComprehensionBlock) {
              result = join(result, [
                '(',
                fragment,
                ')'
              ]);
            } else {
              result = join(result, fragment);
            }
          }
          if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = generateExpression(expr.body, {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            });
            result = join(result, fragment);
          }
          result.push(type === Syntax.GeneratorExpression ? ')' : ']');
          break;
        case Syntax.ComprehensionBlock:
          if (expr.left.type === Syntax.VariableDeclaration) {
            fragment = [
              expr.left.kind,
              noEmptySpace(),
              generateStatement(expr.left.declarations[0], { allowIn: false })
            ];
          } else {
            fragment = generateExpression(expr.left, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true
            });
          }
          fragment = join(fragment, expr.of ? 'of' : 'in');
          fragment = join(fragment, generateExpression(expr.right, {
            precedence: Precedence.Sequence,
            allowIn: true,
            allowCall: true
          }));
          if (extra.moz.parenthesizedComprehensionBlock) {
            result = [
              'for' + space + '(',
              fragment,
              ')'
            ];
          } else {
            result = join('for' + space, fragment);
          }
          break;
        default:
          throw new Error('Unknown expression type: ' + expr.type);
        }
        return toSourceNodeWhenNeeded(result, expr);
      }
      function generateStatement(stmt, option) {
        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon, isGenerator;
        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
          allowIn = option.allowIn === undefined || option.allowIn;
          if (!semicolons && option.semicolonOptional === true) {
            semicolon = '';
          }
          functionBody = option.functionBody;
          directiveContext = option.directiveContext;
        }
        switch (stmt.type) {
        case Syntax.BlockStatement:
          result = [
            '{',
            newline
          ];
          withIndent(function () {
            for (i = 0, len = stmt.body.length; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.body[i], {
                semicolonOptional: i === len - 1,
                directiveContext: functionBody
              }));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          result.push(addIndent('}'));
          break;
        case Syntax.BreakStatement:
          if (stmt.label) {
            result = 'break ' + stmt.label.name + semicolon;
          } else {
            result = 'break' + semicolon;
          }
          break;
        case Syntax.ContinueStatement:
          if (stmt.label) {
            result = 'continue ' + stmt.label.name + semicolon;
          } else {
            result = 'continue' + semicolon;
          }
          break;
        case Syntax.DirectiveStatement:
          if (stmt.raw) {
            result = stmt.raw + semicolon;
          } else {
            result = escapeDirective(stmt.directive) + semicolon;
          }
          break;
        case Syntax.DoWhileStatement:
          result = join('do', maybeBlock(stmt.body));
          result = maybeBlockSuffix(stmt.body, result);
          result = join(result, [
            'while' + space + '(',
            generateExpression(stmt.test, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            }),
            ')' + semicolon
          ]);
          break;
        case Syntax.CatchClause:
          withIndent(function () {
            var guard;
            result = [
              'catch' + space + '(',
              generateExpression(stmt.param, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
            if (stmt.guard) {
              guard = generateExpression(stmt.guard, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              });
              result.splice(2, 0, ' if ', guard);
            }
          });
          result.push(maybeBlock(stmt.body));
          break;
        case Syntax.DebuggerStatement:
          result = 'debugger' + semicolon;
          break;
        case Syntax.EmptyStatement:
          result = ';';
          break;
        case Syntax.ExportDeclaration:
          result = 'export ';
          if (stmt.declaration) {
            result = [
              result,
              generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' })
            ];
            break;
          }
          break;
        case Syntax.ExpressionStatement:
          result = [generateExpression(stmt.expression, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })];
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.charAt(0) === '{' || fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
            result = [
              '(',
              result,
              ')' + semicolon
            ];
          } else {
            result.push(semicolon);
          }
          break;
        case Syntax.VariableDeclarator:
          if (stmt.init) {
            result = [
              generateExpression(stmt.id, {
                precedence: Precedence.Assignment,
                allowIn: allowIn,
                allowCall: true
              }),
              space,
              '=',
              space,
              generateExpression(stmt.init, {
                precedence: Precedence.Assignment,
                allowIn: allowIn,
                allowCall: true
              })
            ];
          } else {
            result = generatePattern(stmt.id, {
              precedence: Precedence.Assignment,
              allowIn: allowIn
            });
          }
          break;
        case Syntax.VariableDeclaration:
          result = [stmt.kind];
          if (stmt.declarations.length === 1 && stmt.declarations[0].init && stmt.declarations[0].init.type === Syntax.FunctionExpression) {
            result.push(noEmptySpace());
            result.push(generateStatement(stmt.declarations[0], { allowIn: allowIn }));
          } else {
            withIndent(function () {
              node = stmt.declarations[0];
              if (extra.comment && node.leadingComments) {
                result.push('\n');
                result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
              } else {
                result.push(noEmptySpace());
                result.push(generateStatement(node, { allowIn: allowIn }));
              }
              for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                node = stmt.declarations[i];
                if (extra.comment && node.leadingComments) {
                  result.push(',' + newline);
                  result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
                } else {
                  result.push(',' + space);
                  result.push(generateStatement(node, { allowIn: allowIn }));
                }
              }
            });
          }
          result.push(semicolon);
          break;
        case Syntax.ThrowStatement:
          result = [
            join('throw', generateExpression(stmt.argument, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })),
            semicolon
          ];
          break;
        case Syntax.TryStatement:
          result = [
            'try',
            maybeBlock(stmt.block)
          ];
          result = maybeBlockSuffix(stmt.block, result);
          if (stmt.handlers) {
            for (i = 0, len = stmt.handlers.length; i < len; ++i) {
              result = join(result, generateStatement(stmt.handlers[i]));
              if (stmt.finalizer || i + 1 !== len) {
                result = maybeBlockSuffix(stmt.handlers[i].body, result);
              }
            }
          } else {
            stmt.guardedHandlers = stmt.guardedHandlers || [];
            for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
              result = join(result, generateStatement(stmt.guardedHandlers[i]));
              if (stmt.finalizer || i + 1 !== len) {
                result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
              }
            }
            if (stmt.handler) {
              if (isArray(stmt.handler)) {
                for (i = 0, len = stmt.handler.length; i < len; ++i) {
                  result = join(result, generateStatement(stmt.handler[i]));
                  if (stmt.finalizer || i + 1 !== len) {
                    result = maybeBlockSuffix(stmt.handler[i].body, result);
                  }
                }
              } else {
                result = join(result, generateStatement(stmt.handler));
                if (stmt.finalizer) {
                  result = maybeBlockSuffix(stmt.handler.body, result);
                }
              }
            }
          }
          if (stmt.finalizer) {
            result = join(result, [
              'finally',
              maybeBlock(stmt.finalizer)
            ]);
          }
          break;
        case Syntax.SwitchStatement:
          withIndent(function () {
            result = [
              'switch' + space + '(',
              generateExpression(stmt.discriminant, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')' + space + '{' + newline
            ];
          });
          if (stmt.cases) {
            for (i = 0, len = stmt.cases.length; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.cases[i], { semicolonOptional: i === len - 1 }));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          }
          result.push(addIndent('}'));
          break;
        case Syntax.SwitchCase:
          withIndent(function () {
            if (stmt.test) {
              result = [
                join('case', generateExpression(stmt.test, {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                })),
                ':'
              ];
            } else {
              result = ['default:'];
            }
            i = 0;
            len = stmt.consequent.length;
            if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
              fragment = maybeBlock(stmt.consequent[0]);
              result.push(fragment);
              i = 1;
            }
            if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            for (; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.consequent[i], { semicolonOptional: i === len - 1 && semicolon === '' }));
              result.push(fragment);
              if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          break;
        case Syntax.IfStatement:
          withIndent(function () {
            result = [
              'if' + space + '(',
              generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          if (stmt.alternate) {
            result.push(maybeBlock(stmt.consequent));
            result = maybeBlockSuffix(stmt.consequent, result);
            if (stmt.alternate.type === Syntax.IfStatement) {
              result = join(result, [
                'else ',
                generateStatement(stmt.alternate, { semicolonOptional: semicolon === '' })
              ]);
            } else {
              result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
            }
          } else {
            result.push(maybeBlock(stmt.consequent, semicolon === ''));
          }
          break;
        case Syntax.ForStatement:
          withIndent(function () {
            result = ['for' + space + '('];
            if (stmt.init) {
              if (stmt.init.type === Syntax.VariableDeclaration) {
                result.push(generateStatement(stmt.init, { allowIn: false }));
              } else {
                result.push(generateExpression(stmt.init, {
                  precedence: Precedence.Sequence,
                  allowIn: false,
                  allowCall: true
                }));
                result.push(';');
              }
            } else {
              result.push(';');
            }
            if (stmt.test) {
              result.push(space);
              result.push(generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(';');
            } else {
              result.push(';');
            }
            if (stmt.update) {
              result.push(space);
              result.push(generateExpression(stmt.update, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(')');
            } else {
              result.push(')');
            }
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        case Syntax.ForInStatement:
          result = generateIterationForStatement('in', stmt, semicolon === '');
          break;
        case Syntax.ForOfStatement:
          result = generateIterationForStatement('of', stmt, semicolon === '');
          break;
        case Syntax.LabeledStatement:
          result = [
            stmt.label.name + ':',
            maybeBlock(stmt.body, semicolon === '')
          ];
          break;
        case Syntax.Program:
          len = stmt.body.length;
          result = [safeConcatenation && len > 0 ? '\n' : ''];
          for (i = 0; i < len; ++i) {
            fragment = addIndent(generateStatement(stmt.body[i], {
              semicolonOptional: !safeConcatenation && i === len - 1,
              directiveContext: true
            }));
            result.push(fragment);
            if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
          break;
        case Syntax.FunctionDeclaration:
          isGenerator = stmt.generator && !extra.moz.starlessGenerator;
          result = [
            isGenerator ? 'function*' : 'function',
            isGenerator ? space : noEmptySpace(),
            generateIdentifier(stmt.id),
            generateFunctionBody(stmt)
          ];
          break;
        case Syntax.ReturnStatement:
          if (stmt.argument) {
            result = [
              join('return', generateExpression(stmt.argument, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              })),
              semicolon
            ];
          } else {
            result = ['return' + semicolon];
          }
          break;
        case Syntax.WhileStatement:
          withIndent(function () {
            result = [
              'while' + space + '(',
              generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        case Syntax.WithStatement:
          withIndent(function () {
            result = [
              'with' + space + '(',
              generateExpression(stmt.object, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        default:
          throw new Error('Unknown statement type: ' + stmt.type);
        }
        if (extra.comment) {
          result = addCommentsToStatement(stmt, result);
        }
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
          result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }
        return toSourceNodeWhenNeeded(result, stmt);
      }
      function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;
        if (options != null) {
          if (typeof options.indent === 'string') {
            defaultOptions.format.indent.style = options.indent;
          }
          if (typeof options.base === 'number') {
            defaultOptions.format.indent.base = options.base;
          }
          options = updateDeeply(defaultOptions, options);
          indent = options.format.indent.style;
          if (typeof options.base === 'string') {
            base = options.base;
          } else {
            base = stringRepeat(indent, options.format.indent.base);
          }
        } else {
          options = defaultOptions;
          indent = options.format.indent.style;
          base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
          newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;
        if (sourceMap) {
          if (!exports.browser) {
            SourceNode = require('/node_modules/source-map/lib/source-map.js', module).SourceNode;
          } else {
            SourceNode = global.sourceMap.SourceNode;
          }
        }
        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
          result = generateStatement(node);
          break;
        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:
          result = generateExpression(node, {
            precedence: Precedence.Sequence,
            allowIn: true,
            allowCall: true
          });
          break;
        default:
          throw new Error('Unknown node type: ' + node.type);
        }
        if (!sourceMap) {
          return result.toString();
        }
        pair = result.toStringWithSourceMap({
          file: options.file,
          sourceRoot: options.sourceMapRoot
        });
        if (options.sourceContent) {
          pair.map.setSourceContent(options.sourceMap, options.sourceContent);
        }
        if (options.sourceMapWithCode) {
          return pair;
        }
        return pair.map.toString();
      }
      FORMAT_MINIFY = {
        indent: {
          style: '',
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      };
      FORMAT_DEFAULTS = getDefaultOptions().format;
      exports.version = require('/node_modules/escodegen/package.json', module).version;
      exports.generate = generate;
      exports.attachComments = estraverse.attachComments;
      exports.browser = false;
      exports.FORMAT_MINIFY = FORMAT_MINIFY;
      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    }());
  });
  require.define('/node_modules/escodegen/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'name': 'escodegen',
      'description': 'ECMAScript code generator',
      'homepage': 'http://github.com/Constellation/escodegen',
      'main': 'escodegen.js',
      'bin': {
        'esgenerate': './bin/esgenerate.js',
        'escodegen': './bin/escodegen.js'
      },
      'version': '1.2.0',
      'engines': { 'node': '>=0.4.0' },
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'repository': {
        'type': 'git',
        'url': 'http://github.com/Constellation/escodegen.git'
      },
      'dependencies': {
        'esprima': '~1.0.4',
        'estraverse': '~1.5.0',
        'esutils': '~1.0.0',
        'source-map': '~0.1.30'
      },
      'optionalDependencies': { 'source-map': '~0.1.30' },
      'devDependencies': {
        'esprima-moz': '*',
        'q': '*',
        'bower': '*',
        'semver': '*',
        'chai': '~1.7.2',
        'gulp': '~3.5.0',
        'gulp-mocha': '~0.4.1',
        'gulp-eslint': '~0.1.2',
        'jshint-stylish': '~0.1.5',
        'gulp-jshint': '~1.4.0',
        'commonjs-everywhere': '~0.9.6'
      },
      'licenses': [{
          'type': 'BSD',
          'url': 'http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD'
        }],
      'scripts': {
        'test': 'gulp travis',
        'unit-test': 'gulp test',
        'lint': 'gulp lint',
        'release': 'node tools/release.js',
        'build-min': 'cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js',
        'build': 'cjsify -a path: tools/entry-point.js > escodegen.browser.js'
      },
      'readme': "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### Building browser bundle / minified browser bundle\n\nAt first, executing `npm install` to install the all dev dependencies.\nAfter that,\n\n    npm run-script build\n\nwill generate `escodegen.browser.js`, it is used on the browser environment.\n\nAnd,\n\n    npm run-script build-min\n\nwill generate minified `escodegen.browser.min.js`.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
      'readmeFilename': 'README.md',
      'bugs': { 'url': 'https://github.com/Constellation/escodegen/issues' },
      '_id': 'escodegen@1.2.0',
      '_shasum': '09de7967791cc958b7f89a2ddb6d23451af327e1',
      '_resolved': 'https://registry.npmjs.org/escodegen/-/escodegen-1.2.0.tgz',
      '_from': 'escodegen@>=1.2.0 <1.3.0'
    };
  });
  require.define('/node_modules/source-map/lib/source-map.js', function (module, exports, __dirname, __filename) {
    exports.SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;
    exports.SourceMapConsumer = require('/node_modules/source-map/lib/source-map/source-map-consumer.js', module).SourceMapConsumer;
    exports.SourceNode = require('/node_modules/source-map/lib/source-map/source-node.js', module).SourceNode;
  });
  require.define('/node_modules/source-map/lib/source-map/source-node.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = '$$$isSourceNode$$$';
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode;
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var shiftNextLine = function () {
          var lineContents = remainingLines.shift();
          var newLine = remainingLines.shift() || '';
          return lineContents + newLine;
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              var code = '';
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[0];
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLines.length > 0) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.join(''));
        }
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === undefined) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === 'string') {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== '') {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = '';
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
            code: '',
            line: 1,
            column: 0
          };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return {
          code: generated.code,
          map: map
        };
      };
      exports.SourceNode = SourceNode;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/util.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ':' + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = path.charAt(0) === '/';
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === '') {
          aRoot = '.';
        }
        if (aPath === '') {
          aPath = '.';
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      function relative(aRoot, aPath) {
        if (aRoot === '') {
          aRoot = '.';
        }
        aRoot = aRoot.replace(/\/$/, '');
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == '/' && url && url.path == '/') {
          return aPath.slice(1);
        }
        return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;
      }
      exports.relative = relative;
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || '';
        var s2 = aStr2 || '';
        return (s1 > s2) - (s1 < s2);
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
        cmp = strcmp(mappingA.name, mappingB.name);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
        return mappingA.generatedColumn - mappingB.generatedColumn;
      }
      ;
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      ;
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    });
  });
  require.define('/node_modules/source-map/node_modules/amdefine/amdefine.js', function (module, exports, __dirname, __filename) {
    'use strict';
    function amdefine(module, requireFn) {
      'use strict';
      var defineCache = {}, loaderCache = {}, alreadyCalled = false, path = require('path', module), makeRequire, stringRequire;
      function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i += 1) {
          part = ary[i];
          if (part === '.') {
            ary.splice(i, 1);
            i -= 1;
          } else if (part === '..') {
            if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
              break;
            } else if (i > 0) {
              ary.splice(i - 1, 2);
              i -= 2;
            }
          }
        }
      }
      function normalize(name, baseName) {
        var baseParts;
        if (name && name.charAt(0) === '.') {
          if (baseName) {
            baseParts = baseName.split('/');
            baseParts = baseParts.slice(0, baseParts.length - 1);
            baseParts = baseParts.concat(name.split('/'));
            trimDots(baseParts);
            name = baseParts.join('/');
          }
        }
        return name;
      }
      function makeNormalize(relName) {
        return function (name) {
          return normalize(name, relName);
        };
      }
      function makeLoad(id) {
        function load(value) {
          loaderCache[id] = value;
        }
        load.fromText = function (id, text) {
          throw new Error('amdefine does not implement load.fromText');
        };
        return load;
      }
      makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
          if (typeof deps === 'string') {
            return stringRequire(systemRequire, exports, module, deps, relId);
          } else {
            deps = deps.map(function (depName) {
              return stringRequire(systemRequire, exports, module, depName, relId);
            });
            process.nextTick(function () {
              callback.apply(null, deps);
            });
          }
        }
        amdRequire.toUrl = function (filePath) {
          if (filePath.indexOf('.') === 0) {
            return normalize(filePath, path.dirname(module.filename));
          } else {
            return filePath;
          }
        };
        return amdRequire;
      };
      requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
      };
      function runFactory(id, deps, factory) {
        var r, e, m, result;
        if (id) {
          e = loaderCache[id] = {};
          m = {
            id: id,
            uri: __filename,
            exports: e
          };
          r = makeRequire(requireFn, e, m, id);
        } else {
          if (alreadyCalled) {
            throw new Error('amdefine with no module ID cannot be called more than once per file.');
          }
          alreadyCalled = true;
          e = module.exports;
          m = module;
          r = makeRequire(requireFn, e, m, module.id);
        }
        if (deps) {
          deps = deps.map(function (depName) {
            return r(depName);
          });
        }
        if (typeof factory === 'function') {
          result = factory.apply(m.exports, deps);
        } else {
          result = factory;
        }
        if (result !== undefined) {
          m.exports = result;
          if (id) {
            loaderCache[id] = m.exports;
          }
        }
      }
      stringRequire = function (systemRequire, exports, module, id, relId) {
        var index = id.indexOf('!'), originalId = id, prefix, plugin;
        if (index === -1) {
          id = normalize(id, relId);
          if (id === 'require') {
            return makeRequire(systemRequire, exports, module, relId);
          } else if (id === 'exports') {
            return exports;
          } else if (id === 'module') {
            return module;
          } else if (loaderCache.hasOwnProperty(id)) {
            return loaderCache[id];
          } else if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
          } else {
            if (systemRequire) {
              return systemRequire(originalId);
            } else {
              throw new Error('No module with ID: ' + id);
            }
          }
        } else {
          prefix = id.substring(0, index);
          id = id.substring(index + 1, id.length);
          plugin = stringRequire(systemRequire, exports, module, prefix, relId);
          if (plugin.normalize) {
            id = plugin.normalize(id, makeNormalize(relId));
          } else {
            id = normalize(id, relId);
          }
          if (loaderCache[id]) {
            return loaderCache[id];
          } else {
            plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
            return loaderCache[id];
          }
        }
      };
      function define(id, deps, factory) {
        if (Array.isArray(id)) {
          factory = deps;
          deps = id;
          id = undefined;
        } else if (typeof id !== 'string') {
          factory = id;
          id = deps = undefined;
        }
        if (deps && !Array.isArray(deps)) {
          factory = deps;
          deps = undefined;
        }
        if (!deps) {
          deps = [
            'require',
            'exports',
            'module'
          ];
        }
        if (id) {
          defineCache[id] = [
            id,
            deps,
            factory
          ];
        } else {
          runFactory(id, deps, factory);
        }
      }
      define.require = function (id) {
        if (loaderCache[id]) {
          return loaderCache[id];
        }
        if (defineCache[id]) {
          runFactory.apply(null, defineCache[id]);
          return loaderCache[id];
        }
      };
      define.amd = {};
      return define;
    }
    module.exports = amdefine;
  });
  require.define('path', function (module, exports, __dirname, __filename) {
    var isWindows = process.platform === 'win32';
    var util = require('util', module);
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    if (isWindows) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
      var splitPath = function (filename) {
        var result = splitDeviceRe.exec(filename), device = (result[1] || '') + (result[2] || ''), tail = result[3] || '';
        var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
        return [
          device,
          dir,
          basename,
          ext
        ];
      };
      var normalizeUNCRoot = function (device) {
        return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
      };
      exports.resolve = function () {
        var resolvedDevice = '', resolvedTail = '', resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1; i--) {
          var path;
          if (i >= 0) {
            path = arguments[i];
          } else if (!resolvedDevice) {
            path = process.cwd();
          } else {
            path = process.env['=' + resolvedDevice];
            if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
              path = resolvedDevice + '\\';
            }
          }
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = !!result[2] || isUnc, tail = result[3];
          if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
          if (!resolvedDevice) {
            resolvedDevice = device;
          }
          if (!resolvedAbsolute) {
            resolvedTail = tail + '\\' + resolvedTail;
            resolvedAbsolute = isAbsolute;
          }
          if (resolvedDevice && resolvedAbsolute) {
            break;
          }
        }
        if (isUnc) {
          resolvedDevice = normalizeUNCRoot(resolvedDevice);
        }
        function f(p) {
          return !!p;
        }
        resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');
        return resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail || '.';
      };
      exports.normalize = function (path) {
        var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = !!result[2] || isUnc, tail = result[3], trailingSlash = /[\\\/]$/.test(tail);
        tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
          return !!p;
        }), !isAbsolute).join('\\');
        if (!tail && !isAbsolute) {
          tail = '.';
        }
        if (tail && trailingSlash) {
          tail += '\\';
        }
        if (isUnc) {
          device = normalizeUNCRoot(device);
        }
        return device + (isAbsolute ? '\\' : '') + tail;
      };
      exports.join = function () {
        function f(p) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }
        var paths = Array.prototype.filter.call(arguments, f);
        var joined = paths.join('\\');
        if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
          joined = joined.replace(/^[\\\/]{2,}/, '\\');
        }
        return exports.normalize(joined);
      };
      exports.relative = function (from, to) {
        from = exports.resolve(from);
        to = exports.resolve(to);
        var lowerFrom = from.toLowerCase();
        var lowerTo = to.toLowerCase();
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '')
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '')
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var toParts = trim(to.split('\\'));
        var lowerFromParts = trim(lowerFrom.split('\\'));
        var lowerToParts = trim(lowerTo.split('\\'));
        var length = Math.min(lowerFromParts.length, lowerToParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (lowerFromParts[i] !== lowerToParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        if (samePartsLength == 0) {
          return to;
        }
        var outputParts = [];
        for (var i = samePartsLength; i < lowerFromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('\\');
      };
      exports.sep = '\\';
      exports.delimiter = ';';
    } else {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      var splitPath = function (filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      exports.resolve = function () {
        var resolvedPath = '', resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : process.cwd();
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
      };
      exports.normalize = function (path) {
        var isAbsolute = path.charAt(0) === '/', trailingSlash = path.substr(-1) === '/';
        path = normalizeArray(path.split('/').filter(function (p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      };
      exports.join = function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return exports.normalize(paths.filter(function (p, index) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }).join('/'));
      };
      exports.relative = function (from, to) {
        from = exports.resolve(from).substr(1);
        to = exports.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '')
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '')
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      };
      exports.sep = '/';
      exports.delimiter = ':';
    }
    exports.dirname = function (path) {
      var result = splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return '.';
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    exports.basename = function (path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    exports.extname = function (path) {
      return splitPath(path)[3];
    };
    exports.exists = util.deprecate(function (path, callback) {
      require('fs', module).exists(path, callback);
    }, 'path.exists is now called `fs.exists`.');
    exports.existsSync = util.deprecate(function (path) {
      return require('fs', module).existsSync(path);
    }, 'path.existsSync is now called `fs.existsSync`.');
    if (isWindows) {
      exports._makeLong = function (path) {
        if (typeof path !== 'string')
          return path;
        if (!path) {
          return '';
        }
        var resolvedPath = exports.resolve(path);
        if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
          return '\\\\?\\' + resolvedPath;
        } else if (/^\\\\[^?.]/.test(resolvedPath)) {
          return '\\\\?\\UNC\\' + resolvedPath.substring(2);
        }
        return path;
      };
    } else {
      exports._makeLong = function (path) {
        return path;
      };
    }
  });
  require.define('util', function (module, exports, __dirname, __filename) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (typeof f !== 'string') {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%')
            return '%';
          if (i >= len)
            return x;
          switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            return JSON.stringify(args[i++]);
          default:
            return x;
          }
        });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (x === null || typeof x !== 'object') {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    exports.print = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(String(arguments[i]));
      }
    };
    exports.puts = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(arguments[i] + '\n');
      }
    };
    exports.debug = function (x) {
      process.stderr.write('DEBUG: ' + x + '\n');
    };
    var error = exports.error = function (x) {
        for (var i = 0, len = arguments.length; i < len; ++i) {
          process.stderr.write(arguments[i] + '\n');
        }
      };
    function inspect(obj, opts) {
      var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (typeof opts === 'boolean') {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (typeof ctx.showHidden === 'undefined')
        ctx.showHidden = false;
      if (typeof ctx.depth === 'undefined')
        ctx.depth = 2;
      if (typeof ctx.colors === 'undefined')
        ctx.colors = false;
      if (typeof ctx.customInspect === 'undefined')
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [
        1,
        22
      ],
      'italic': [
        3,
        23
      ],
      'underline': [
        4,
        24
      ],
      'inverse': [
        7,
        27
      ],
      'white': [
        37,
        39
      ],
      'grey': [
        90,
        39
      ],
      'black': [
        30,
        39
      ],
      'blue': [
        34,
        39
      ],
      'cyan': [
        36,
        39
      ],
      'green': [
        32,
        39
      ],
      'magenta': [
        35,
        39
      ],
      'red': [
        31,
        39
      ],
      'yellow': [
        33,
        39
      ]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && typeof value.inspect === 'function' && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        return String(value.inspect(recurseTimes));
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (keys.length === 0) {
        if (typeof value === 'function') {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '', array = false, braces = [
          '{',
          '}'
        ];
      if (isArray(value)) {
        array = true;
        braces = [
          '[',
          ']'
        ];
      }
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');
      case 'string':
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      case 'number':
        return ctx.stylize('' + value, 'number');
      case 'boolean':
        return ctx.stylize('' + value, 'boolean');
      }
      if (value === null) {
        return ctx.stylize('null', 'null');
      }
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0)
            numLinesEst++;
          return prev + cur.length + 1;
        }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
    }
    exports.isArray = isArray;
    function isRegExp(re) {
      return typeof re === 'object' && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isDate(d) {
      return typeof d === 'object' && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return typeof e === 'object' && objectToString(e) === '[object Error]';
    }
    exports.isError = isError;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    exports.p = exports.deprecate(function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        error(exports.inspect(arguments[i]));
      }
    }, 'util.p: Use console.error() instead.');
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ];
    function timestamp() {
      var d = new Date;
      var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(':');
      return [
        d.getDate(),
        months[d.getMonth()],
        time
      ].join(' ');
    }
    exports.log = function (msg) {
      exports.puts(timestamp() + ' - ' + msg.toString());
    };
    exports.exec = exports.deprecate(function () {
      return require('child_process', module).exec.apply(this, arguments);
    }, 'util.exec is now called `child_process.exec`.');
    function pump(readStream, writeStream, callback) {
      var callbackCalled = false;
      function call(a, b, c) {
        if (callback && !callbackCalled) {
          callback(a, b, c);
          callbackCalled = true;
        }
      }
      readStream.addListener('data', function (chunk) {
        if (writeStream.write(chunk) === false)
          readStream.pause();
      });
      writeStream.addListener('drain', function () {
        readStream.resume();
      });
      readStream.addListener('end', function () {
        writeStream.end();
      });
      readStream.addListener('close', function () {
        call();
      });
      readStream.addListener('error', function (err) {
        writeStream.end();
        call(err);
      });
      writeStream.addListener('error', function (err) {
        readStream.destroy();
        call(err);
      });
    }
    exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use readableStream.pipe() instead.');
    exports.inherits = function (ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
    exports._extend = function (origin, add) {
      if (!add || typeof add !== 'object')
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  });
  require.define('/node_modules/source-map/lib/source-map/source-map-generator.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;
      var MappingList = require('/node_modules/source-map/lib/source-map/mapping-list.js', module).MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
        this._sources = new ArraySet;
        this._names = new ArraySet;
        this._mappings = new MappingList;
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
        aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, 'generated');
        var original = util.getArg(aArgs, 'original', null);
        var source = util.getArg(aArgs, 'source', null);
        var name = util.getArg(aArgs, 'name', null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null && !this._sources.has(source)) {
          this._sources.add(source);
        }
        if (name != null && !this._names.has(name)) {
          this._names.add(name);
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = {};
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet;
        var newNames = new ArraySet;
        this._mappings.unsortedForEach(function (mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var mapping;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              result += ';';
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
                continue;
              }
              result += ',';
            }
          }
          result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
            previousSource = this._sources.indexOf(mapping.source);
            result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
              previousName = this._names.indexOf(mapping.name);
            }
          }
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
            version: this._version,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this);
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/mapping-list.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = {
          generatedLine: -1,
          generatedColumn: 0
        };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        var mapping;
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositions);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/array-set.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet;
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/base64-vlq.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var base64 = require('/node_modules/source-map/lib/source-map/base64.js', module);
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = '';
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aOutParam) {
        var i = 0;
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (i >= strLen) {
            throw new Error('Expected more digits in base 64 VLQ value.');
          }
          digit = base64.decode(aStr.charAt(i++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aStr.slice(i);
      };
    });
  });
  require.define('/node_modules/source-map/lib/source-map/base64.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var charToIntMap = {};
      var intToCharMap = {};
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function (ch, index) {
        charToIntMap[ch] = index;
        intToCharMap[index] = ch;
      });
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError('Must be between 0 and 63: ' + aNumber);
      };
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError('Not a valid base 64 digit: ' + aChar);
      };
    });
  });
  require.define('/node_modules/source-map/lib/source-map/source-map-consumer.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      var binarySearch = require('/node_modules/source-map/lib/source-map/binary-search.js', module);
      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;
      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
        sources = sources.map(util.normalize);
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
      SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
        var smc = Object.create(SourceMapConsumer.prototype);
        smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
        smc.file = aSourceMap._file;
        smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
        smc.__originalMappings = aSourceMap._mappings.toArray().slice().sort(util.compareByOriginalPositions);
        return smc;
      };
      SourceMapConsumer.prototype._version = 3;
      Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
        var c = aStr.charAt(0);
        return c === ';' || c === ',';
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var str = aStr;
        var temp = {};
        var mapping;
        while (str.length > 0) {
          if (str.charAt(0) === ';') {
            generatedLine++;
            str = str.slice(1);
            previousGeneratedColumn = 0;
          } else if (str.charAt(0) === ',') {
            str = str.slice(1);
          } else {
            mapping = {};
            mapping.generatedLine = generatedLine;
            base64VLQ.decode(str, temp);
            mapping.generatedColumn = previousGeneratedColumn + temp.value;
            previousGeneratedColumn = mapping.generatedColumn;
            str = temp.rest;
            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              base64VLQ.decode(str, temp);
              mapping.source = this._sources.at(previousSource + temp.value);
              previousSource += temp.value;
              str = temp.rest;
              if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                throw new Error('Found a source, but no line and column');
              }
              base64VLQ.decode(str, temp);
              mapping.originalLine = previousOriginalLine + temp.value;
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              str = temp.rest;
              if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
                throw new Error('Found a source and line, but no column');
              }
              base64VLQ.decode(str, temp);
              mapping.originalColumn = previousOriginalColumn + temp.value;
              previousOriginalColumn = mapping.originalColumn;
              str = temp.rest;
              if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
                base64VLQ.decode(str, temp);
                mapping.name = this._names.at(previousName + temp.value);
                previousName += temp.value;
                str = temp.rest;
              }
            }
            this.__generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
              this.__originalMappings.push(mapping);
            }
          }
        }
        this.__generatedMappings.sort(util.compareByGeneratedPositions);
        this.__originalMappings.sort(util.compareByOriginalPositions);
      };
      SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator);
      };
      SourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
        var index = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositions);
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source != null && this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: util.getArg(mapping, 'name', null)
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {
        if (!this.sourcesContent) {
          return null;
        }
        if (this.sourceRoot != null) {
          aSource = util.relative(this.sourceRoot, aSource);
        }
        if (this._sources.has(aSource)) {
          return this.sourcesContent[this._sources.indexOf(aSource)];
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = aSource.replace(/^file:\/\//, '');
          if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {
            return this.sourcesContent[this._sources.indexOf('/' + aSource)];
          }
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      };
      SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
        if (this.sourceRoot != null) {
          needle.source = util.relative(this.sourceRoot, needle.source);
        }
        var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: Infinity
          };
        if (this.sourceRoot != null) {
          needle.source = util.relative(this.sourceRoot, needle.source);
        }
        var mappings = [];
        var index = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          while (mapping && mapping.originalLine === needle.originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });
            mapping = this._originalMappings[--index];
          }
        }
        return mappings.reverse();
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error('Unknown order of iteration.');
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source;
          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name
          };
        }).forEach(aCallback, context);
      };
      exports.SourceMapConsumer = SourceMapConsumer;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/binary-search.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
          }
          return mid;
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
          }
          return aLow < 0 ? -1 : aLow;
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare) {
        if (aHaystack.length === 0) {
          return -1;
        }
        return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare);
      };
    });
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/utils.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      exports.code = require('/node_modules/escodegen/node_modules/esutils/lib/code.js', module);
      exports.keyword = require('/node_modules/escodegen/node_modules/esutils/lib/keyword.js', module);
    }());
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/keyword.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var code = require('/node_modules/escodegen/node_modules/esutils/lib/code.js', module);
      function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
          return true;
        default:
          return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
        case 2:
          return id === 'if' || id === 'in' || id === 'do';
        case 3:
          return id === 'var' || id === 'for' || id === 'new' || id === 'try';
        case 4:
          return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
        case 5:
          return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
        case 6:
          return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
        case 7:
          return id === 'default' || id === 'finally' || id === 'extends';
        case 8:
          return id === 'function' || id === 'continue' || id === 'debugger';
        case 10:
          return id === 'instanceof';
        default:
          return false;
        }
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isIdentifierName(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPart(ch) || ch === 92) {
            return false;
          }
        }
        return true;
      }
      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
      };
    }());
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/code.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Regex;
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isHexDigit(ch) {
        return isDecimalDigit(ch) || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
      }
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
          5760,
          6158,
          8192,
          8193,
          8194,
          8195,
          8196,
          8197,
          8198,
          8199,
          8200,
          8201,
          8202,
          8239,
          8287,
          12288,
          65279
        ].indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
      }
      function isIdentifierStart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
      }
      function isIdentifierPart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
      };
    }());
  });
  require.define('/node_modules/escodegen/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory(root.estraverse = {});
      }
    }(this, function (exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'defaults',
          'rest',
          'body'
        ],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'body',
          'superClass'
        ],
        ClassExpression: [
          'id',
          'body',
          'superClass'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        ForOfStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handlers',
          'handler',
          'guardedHandlers',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
      };
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (!isArray(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
                continue;
              }
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', null);
                } else {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, null);
                }
                worklist.push(element);
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP) {
              element.ref.replace(target);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = element.wrap || node.type;
          candidates = VisitorKeys[nodeType];
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (!isArray(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
              continue;
            }
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], 'Property', new Reference(candidate, current2));
              } else {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], null, new Reference(candidate, current2));
              }
              worklist.push(element);
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = '1.5.1-dev';
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
    }));
  });
  require.define('/node_modules/cscodegen/lib/cscodegen.js', function (module, exports, __dirname, __filename) {
    (function () {
      var __hasProp = {}.hasOwnProperty, __slice = [].slice, __indexOf = [].indexOf || function (item) {
          for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        };
      (function (exports) {
        var TAB, clone, eq, formatInterpolation, formatStringData, generate, indent, levels, needsParensWhenOnLeft, operators, parens, precedence;
        TAB = '  ';
        indent = function (code) {
          var line;
          return function () {
            var _i, _len, _ref, _results;
            _ref = code.split('\n');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              line = _ref[_i];
              _results.push('' + TAB + line);
            }
            return _results;
          }().join('\n');
        };
        parens = function (code) {
          return '(' + code + ')';
        };
        formatStringData = function (data) {
          return data.replace(/[^\x20-\x7e]|['\\]/, function (c) {
            var escape, pad;
            switch (c) {
            case '\0':
              return '\\0';
            case '\b':
              return '\\b';
            case '\t':
              return '\\t';
            case '\n':
              return '\\n';
            case '\f':
              return '\\f';
            case '\r':
              return '\\r';
            case "'":
              return "\\'";
            case '\\':
              return '\\\\';
            default:
              escape = c.charCodeAt(0).toString(16);
              pad = '0000'.slice(escape.length);
              return '\\u' + pad + escape;
            }
          });
        };
        formatInterpolation = function (ast, options) {
          var left, right;
          switch (ast.className) {
          case 'ConcatOp':
            left = formatInterpolation(ast.left, options);
            right = formatInterpolation(ast.right, options);
            return '' + left + right;
          case 'String':
            return formatStringData(ast.data);
          default:
            return '#{' + generate(ast, options) + '}';
          }
        };
        needsParensWhenOnLeft = function (ast) {
          switch (ast.className) {
          case 'Function':
          case 'BoundFunction':
          case 'NewOp':
            return true;
          case 'Conditional':
          case 'Switch':
          case 'While':
          case 'Block':
            return true;
          case 'PreIncrementOp':
          case 'PreDecrementOp':
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'DeleteOp':
            return needsParensWhenOnLeft(ast.expression);
          case 'FunctionApplication':
            return ast['arguments'].length > 0;
          default:
            return false;
          }
        };
        eq = function (nodeA, nodeB) {
          var i, prop, v, val, _i, _len;
          for (prop in nodeA) {
            if (!__hasProp.call(nodeA, prop))
              continue;
            val = nodeA[prop];
            if (prop === 'raw' || prop === 'line' || prop === 'column') {
              continue;
            }
            switch (Object.prototype.toString.call(val)) {
            case '[object Object]':
              if (!eq(nodeB[prop], val)) {
                return false;
              }
              break;
            case '[object Array]':
              for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
                v = val[i];
                if (!eq(nodeB[prop][i], v)) {
                  return false;
                }
              }
              break;
            default:
              if (nodeB[prop] !== val) {
                return false;
              }
            }
          }
          return true;
        };
        clone = function (obj, overrides) {
          var newObj, prop, val;
          if (overrides == null) {
            overrides = {};
          }
          newObj = {};
          for (prop in obj) {
            if (!__hasProp.call(obj, prop))
              continue;
            val = obj[prop];
            newObj[prop] = val;
          }
          for (prop in overrides) {
            if (!__hasProp.call(overrides, prop))
              continue;
            val = overrides[prop];
            newObj[prop] = val;
          }
          return newObj;
        };
        levels = [
          ['SeqOp'],
          [
            'Conditional',
            'ForIn',
            'ForOf',
            'While'
          ],
          [
            'FunctionApplication',
            'SoakedFunctionApplication'
          ],
          [
            'AssignOp',
            'CompoundAssignOp',
            'ExistsAssignOp'
          ],
          ['LogicalOrOp'],
          ['LogicalAndOp'],
          ['BitOrOp'],
          ['BitXorOp'],
          ['BitAndOp'],
          ['ExistsOp'],
          [
            'EQOp',
            'NEQOp'
          ],
          [
            'LTOp',
            'LTEOp',
            'GTOp',
            'GTEOp',
            'InOp',
            'OfOp',
            'InstanceofOp'
          ],
          [
            'LeftShiftOp',
            'SignedRightShiftOp',
            'UnsignedRightShiftOp'
          ],
          [
            'PlusOp',
            'SubtractOp'
          ],
          [
            'MultiplyOp',
            'DivideOp',
            'RemOp'
          ],
          [
            'UnaryPlusOp',
            'UnaryNegateOp',
            'LogicalNotOp',
            'BitNotOp',
            'DoOp',
            'TypeofOp',
            'PreIncrementOp',
            'PreDecrementOp',
            'DeleteOp'
          ],
          [
            'UnaryExistsOp',
            'ShallowCopyArray',
            'PostIncrementOp',
            'PostDecrementOp',
            'Spread'
          ],
          ['NewOp'],
          [
            'MemberAccessOp',
            'SoakedMemberAccessOp',
            'DynamicMemberAccessOp',
            'SoakedDynamicMemberAccessOp',
            'ProtoMemberAccessOp',
            'DynamicProtoMemberAccessOp',
            'SoakedProtoMemberAccessOp',
            'SoakedDynamicProtoMemberAccessOp'
          ]
        ];
        precedence = {};
        (function () {
          var level, op, ops, _i, _len, _results;
          _results = [];
          for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
            ops = levels[level];
            _results.push(function () {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
                op = ops[_j];
                _results1.push(precedence[op] = level);
              }
              return _results1;
            }());
          }
          return _results;
        }());
        operators = {
          SeqOp: ';',
          LogicalOrOp: 'or',
          LogicalAndOp: 'and',
          BitOrOp: '|',
          BitXorOp: '^',
          BitAndOp: '&',
          EQOp: 'is',
          NEQOp: 'isnt',
          LTOp: '<',
          LTEOp: '<=',
          GTOp: '>',
          GTEOp: '>=',
          InOp: 'in',
          OfOp: 'of',
          InstanceofOp: 'instanceof',
          LeftShiftOp: '<<',
          SignedRightShiftOp: '>>',
          UnsignedRightShiftOp: '>>>',
          PlusOp: '+',
          SubtractOp: '-',
          MultiplyOp: '*',
          DivideOp: '/',
          RemOp: '%',
          UnaryPlusOp: '+',
          UnaryNegateOp: '-',
          LogicalNotOp: 'not ',
          BitNotOp: '~',
          DoOp: 'do ',
          NewOp: 'new ',
          TypeofOp: 'typeof ',
          PreIncrementOp: '++',
          PreDecrementOp: '--',
          UnaryExistsOp: '?',
          ShallowCopyArray: '[..]',
          PostIncrementOp: '++',
          PostDecrementOp: '--',
          Spread: '...',
          FunctionApplication: '',
          SoakedFunctionApplication: '?',
          MemberAccessOp: '.',
          SoakedMemberAccessOp: '?.',
          ProtoMemberAccessOp: '::',
          SoakedProtoMemberAccessOp: '?::',
          DynamicMemberAccessOp: '',
          SoakedDynamicMemberAccessOp: '?',
          DynamicProtoMemberAccessOp: '::',
          SoakedDynamicProtoMemberAccessOp: '?::'
        };
        return exports.generate = generate = function (ast, options) {
          var a, absNum, arg, args, expression_, hasAlternate, i, isMultiline, key_, m, memberAccessOps, members_, needsParens, p, parameters, parent, parentClassName, prec, s, sep, src, usedAsExpression, _alternate, _argList, _args, _assignee, _block, _body, _consequent, _ctor, _expr, _fn, _indexingExpr, _left, _op, _paramList, _ref, _ref1, _right;
          if (options == null) {
            options = {};
          }
          needsParens = false;
          if ((_ref = options.precedence) == null) {
            options.precedence = 0;
          }
          if ((_ref1 = options.ancestors) == null) {
            options.ancestors = [];
          }
          parent = options.ancestors[0];
          parentClassName = parent != null ? parent.className : void 0;
          usedAsExpression = parent != null && parentClassName !== 'Block';
          src = function () {
            var _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6;
            switch (ast.className) {
            case 'Program':
              options.ancestors = [ast].concat(__slice.call(options.ancestors));
              if (ast.body != null) {
                return generate(ast.body, options);
              } else {
                return '';
              }
              break;
            case 'Block':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: 0
              });
              if (ast.statements.length === 0) {
                return generate(new Undefined().g(), options);
              } else {
                sep = parentClassName === 'Program' ? '\n\n' : '\n';
                return function () {
                  var _i, _len, _ref2, _results;
                  _ref2 = ast.statements;
                  _results = [];
                  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    s = _ref2[_i];
                    _results.push(generate(s, options));
                  }
                  return _results;
                }().join(sep);
              }
              break;
            case 'Conditional':
              options.ancestors.unshift(ast);
              options.precedence = 0;
              hasAlternate = ast.consequent != null && ast.alternate != null;
              _consequent = generate((_ref2 = ast.consequent) != null ? _ref2 : new Undefined().g(), options);
              _alternate = hasAlternate ? generate(ast.alternate, options) : '';
              isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
              _consequent = isMultiline ? '\n' + indent(_consequent) : ' then ' + _consequent;
              if (hasAlternate) {
                _alternate = isMultiline ? '\nelse\n' + indent(_alternate) : ' else ' + _alternate;
              }
              return 'if ' + generate(ast.condition, options) + _consequent + _alternate;
            case 'Identifier':
              return ast.data;
            case 'Null':
              return 'null';
            case 'This':
              return 'this';
            case 'Undefined':
              return 'undefined';
            case 'Int':
              absNum = ast.data < 0 ? -ast.data : ast.data;
              if (absNum >= 1e12 || absNum >= 16 && 0 === (absNum & absNum - 1)) {
                return '0x' + ast.data.toString(16);
              } else {
                return ast.data.toString(10);
              }
              break;
            case 'Float':
              return ast.data.toString(10);
            case 'String':
              return "'" + formatStringData(ast.data) + "'";
            case 'ArrayInitialiser':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              members_ = function () {
                var _i, _len, _ref3, _results;
                _ref3 = ast.members;
                _results = [];
                for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                  m = _ref3[_i];
                  _results.push(generate(m, options));
                }
                return _results;
              }();
              switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return '[' + members_.join(', ') + ']';
              default:
                return '[\n' + indent(members_.join('\n')) + '\n]';
              }
              break;
            case 'ObjectInitialiser':
              options.ancestors = [ast].concat(__slice.call(options.ancestors));
              members_ = function () {
                var _j, _len1, _ref3, _results;
                _ref3 = ast.members;
                _results = [];
                for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                  m = _ref3[_j];
                  _results.push(generate(m, options));
                }
                return _results;
              }();
              switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return '{' + members_.join(', ') + '}';
              default:
                return '{\n' + indent(members_.join('\n')) + '\n}';
              }
              break;
            case 'ObjectInitialiserMember':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              key_ = generate(ast.key, options);
              expression_ = generate(ast.expression, options);
              memberAccessOps = [
                'MemberAccessOp',
                'ProtoMemberAccessOp',
                'SoakedMemberAccessOp',
                'SoakedProtoMemberAccessOp'
              ];
              if (eq(ast.key, ast.expression)) {
                return '' + key_;
              } else if ((_ref3 = ast.expression.className, __indexOf.call(memberAccessOps, _ref3) >= 0) && ast.key.data === ast.expression.memberName) {
                return '' + expression_;
              } else {
                return '' + key_ + ': ' + expression_;
              }
              break;
            case 'Function':
            case 'BoundFunction':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              parameters = function () {
                var _j, _len1, _ref4, _results;
                _ref4 = ast.parameters;
                _results = [];
                for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                  p = _ref4[_j];
                  _results.push(generate(p, options));
                }
                return _results;
              }();
              options.precedence = 0;
              _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
              _paramList = ast.parameters.length > 0 ? '(' + parameters.join(', ') + ') ' : '';
              _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? ' ' + _body : '\n' + indent(_body);
              switch (ast.className) {
              case 'Function':
                return '' + _paramList + '->' + _block;
              case 'BoundFunction':
                return '' + _paramList + '=>' + _block;
              }
              break;
            case 'AssignOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _assignee = generate(ast.assignee, options);
              _expr = generate(ast.expression, options);
              return '' + _assignee + ' = ' + _expr;
            case 'CompoundAssignOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _op = operators[ast.op.prototype.className];
              _assignee = generate(ast.assignee, options);
              _expr = generate(ast.expression, options);
              return '' + _assignee + ' ' + _op + '= ' + _expr;
            case 'SeqOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _left = generate(ast.left, options);
              _right = generate(ast.right, options);
              return '' + _left + '; ' + _right;
            case 'LogicalOrOp':
            case 'LogicalAndOp':
            case 'BitOrOp':
            case 'BitXorOp':
            case 'BitAndOp':
            case 'LeftShiftOp':
            case 'SignedRightShiftOp':
            case 'UnsignedRightShiftOp':
            case 'EQOp':
            case 'NEQOp':
            case 'LTOp':
            case 'LTEOp':
            case 'GTOp':
            case 'GTEOp':
            case 'InOp':
            case 'OfOp':
            case 'InstanceofOp':
            case 'PlusOp':
            case 'SubtractOp':
            case 'MultiplyOp':
            case 'DivideOp':
            case 'RemOp':
            case 'ExistsOp':
              _op = operators[ast.className];
              if (((_ref4 = ast.className) === 'InOp' || _ref4 === 'OfOp' || _ref4 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
                _op = 'not ' + _op;
              }
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _left = generate(ast.left, options);
              if (needsParensWhenOnLeft(ast.left)) {
                _left = parens(_left);
              }
              _right = generate(ast.right, options);
              return '' + _left + ' ' + _op + ' ' + _right;
            case 'UnaryPlusOp':
            case 'UnaryNegateOp':
            case 'LogicalNotOp':
            case 'BitNotOp':
            case 'DoOp':
            case 'TypeofOp':
            case 'PreIncrementOp':
            case 'PreDecrementOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              if (ast.className === 'LogicalNotOp') {
                if ((_ref5 = ast.expression.className) === 'InOp' || _ref5 === 'OfOp' || _ref5 === 'InstanceofOp') {
                  _op = '';
                  prec = precedence[ast.expression.className];
                }
                if ('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) {
                  _op = '!';
                }
              }
              needsParens = prec < options.precedence;
              if (parentClassName === ast.className && ((_ref6 = ast.className) === 'UnaryPlusOp' || _ref6 === 'UnaryNegateOp')) {
                needsParens = true;
              }
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              return '' + _op + generate(ast.expression, options);
            case 'UnaryExistsOp':
            case 'PostIncrementOp':
            case 'PostDecrementOp':
            case 'Spread':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
              return '' + _expr + _op;
            case 'NewOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _ctor = generate(ast.ctor, options);
              if (ast['arguments'].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
                _ctor = parens(_ctor);
              }
              options.precedence = precedence['AssignOp'];
              args = function () {
                var _j, _len1, _ref7, _results;
                _ref7 = ast['arguments'];
                _results = [];
                for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                  a = _ref7[i];
                  arg = generate(a, options);
                  if (needsParensWhenOnLeft(a) && i + 1 !== ast['arguments'].length) {
                    arg = parens(arg);
                  }
                  _results.push(arg);
                }
                return _results;
              }();
              _args = ast['arguments'].length === 0 ? '' : ' ' + args.join(', ');
              return '' + _op + _ctor + _args;
            case 'FunctionApplication':
            case 'SoakedFunctionApplication':
              if (ast.className === 'FunctionApplication' && ast['arguments'].length === 0 && !usedAsExpression) {
                return generate(new DoOp(ast['function']), options);
              } else {
                options = clone(options, {
                  ancestors: [ast].concat(__slice.call(options.ancestors)),
                  precedence: precedence[ast.className]
                });
                _op = operators[ast.className];
                _fn = generate(ast['function'], options);
                if (needsParensWhenOnLeft(ast['function'])) {
                  _fn = parens(_fn);
                }
                args = function () {
                  var _j, _len1, _ref7, _results;
                  _ref7 = ast['arguments'];
                  _results = [];
                  for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                    a = _ref7[i];
                    arg = generate(a, options);
                    if (needsParensWhenOnLeft(a) && i + 1 !== ast['arguments'].length) {
                      arg = parens(arg);
                    }
                    _results.push(arg);
                  }
                  return _results;
                }();
                _argList = ast['arguments'].length === 0 ? '()' : ' ' + args.join(', ');
                return '' + _fn + _op + _argList;
              }
              break;
            case 'MemberAccessOp':
            case 'SoakedMemberAccessOp':
            case 'ProtoMemberAccessOp':
            case 'SoakedProtoMemberAccessOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              if (ast.expression.className === 'This') {
                _expr = '@';
                if (ast.className === 'MemberAccessOp') {
                  _op = '';
                }
              } else {
                _expr = generate(ast.expression, options);
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
              return '' + _expr + _op + ast.memberName;
            case 'DynamicMemberAccessOp':
            case 'SoakedDynamicMemberAccessOp':
            case 'DynamicProtoMemberAccessOp':
            case 'SoakedDynamicProtoMemberAccessOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              if (ast.expression.className === 'This') {
                _expr = '@';
              } else {
                _expr = generate(ast.expression, options);
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
              options.precedence = 0;
              _indexingExpr = generate(ast.indexingExpr, options);
              return '' + _expr + _op + '[' + _indexingExpr + ']';
            case 'ConcatOp':
              _left = formatInterpolation(ast.left, options);
              _right = formatInterpolation(ast.right, options);
              return '"' + _left + _right + '"';
            default:
              throw new Error('Non-exhaustive patterns in case: ' + ast.className);
            }
          }();
          if (needsParens) {
            return parens(src);
          } else {
            return src;
          }
        };
      }(typeof exports !== 'undefined' && exports !== null ? exports : this.cscodegen = {}));
    }.call(this));
  });
  require.define('/src/compiler.coffee', function (module, exports, __dirname, __filename) {
    var _, any, assignment, beingDeclared, collectIdentifiers, concat, concatMap, CS, declarationsNeeded, declarationsNeededRecursive, defaultRules, difference, divMod, dynamicMemberAccess, emberComputedProperty, enabledHelpers, envEnrichments, exports, expr, fn, fn, foldl1, forceBlock, forceComputedProperty, generateMutatingWalker, generateSoak, genSym, h, h, hasSoak, helperNames, helpers, inlineHelpers, intersect, isIdentifierName, JS, jsReserved, makeReturn, makeVarDeclaration, map, memberAccess, needsCaching, nub, owns, partition, span, stmt, union, usedAsExpression, variableDeclarations;
    cache$ = require('/src/functional-helpers.coffee', module);
    any = cache$.any;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    divMod = cache$.divMod;
    foldl1 = cache$.foldl1;
    intersect = cache$.intersect;
    map = cache$.map;
    nub = cache$.nub;
    owns = cache$.owns;
    partition = cache$.partition;
    span = cache$.span;
    union = cache$.union;
    cache$1 = require('/src/helpers.coffee', module);
    beingDeclared = cache$1.beingDeclared;
    usedAsExpression = cache$1.usedAsExpression;
    envEnrichments = cache$1.envEnrichments;
    CS = require('/src/nodes.coffee', module);
    JS = require('/src/js-nodes.coffee', module);
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    _ = require('/node_modules/lodash/index.js', module);
    jsReserved = [
      'break',
      'case',
      'catch',
      'class',
      'const',
      'continue',
      'debugger',
      'default',
      'delete',
      'do',
      'else',
      'enum',
      'export',
      'extends',
      'false',
      'finally',
      'for',
      'function',
      'if',
      'implements',
      'import',
      'in',
      'instanceof',
      'interface',
      'let',
      'native',
      'new',
      'null',
      'package',
      'private',
      'protected',
      'public',
      'return',
      'static',
      'super',
      'switch',
      'this',
      'throw',
      'true',
      'try',
      'typeof',
      'var',
      'void',
      'while',
      'with',
      'yield',
      'arguments',
      'eval'
    ];
    genSym = function () {
      var genSymCounter;
      genSymCounter = 0;
      return function (pre) {
        return new JS.GenSym(pre, ++genSymCounter);
      };
    }();
    stmt = function (e) {
      var walk;
      if (!(null != e))
        return e;
      if (e.isStatement) {
        return e;
      } else if (e['instanceof'](JS.SequenceExpression)) {
        walk = function (seq) {
          return concatMap(seq.expressions, function (e) {
            if (e['instanceof'](JS.SequenceExpression)) {
              return walk(e);
            } else {
              return [stmt(e)];
            }
          });
        };
        return new JS.BlockStatement(walk(e));
      } else if (e['instanceof'](JS.ConditionalExpression)) {
        return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
      } else {
        return new JS.ExpressionStatement(e);
      }
    };
    expr = function (s) {
      var accum, alternate, block, consequent, iife, lastExpression, push;
      if (!(null != s))
        return s;
      if (s.isExpression) {
        return s;
      } else if (s['instanceof'](JS.BlockStatement)) {
        switch (s.body.length) {
        case 0:
          return helpers.undef();
        case 1:
          return expr(s.body[0]);
        default:
          return new JS.SequenceExpression(map(s.body, expr));
        }
      } else if (s['instanceof'](JS.ExpressionStatement)) {
        return s.expression;
      } else if (s['instanceof'](JS.ThrowStatement)) {
        return new JS.CallExpression(new JS.FunctionExpression(null, [], forceBlock(s)), []);
      } else if (s['instanceof'](JS.IfStatement)) {
        consequent = expr(null != s.consequent ? s.consequent : helpers.undef());
        alternate = expr(null != s.alternate ? s.alternate : helpers.undef());
        return new JS.ConditionalExpression(s.test, consequent, alternate);
      } else if (s['instanceof'](JS.ForInStatement, JS.ForStatement, JS.WhileStatement)) {
        accum = genSym('accum');
        push = function (x) {
          return stmt(new JS.CallExpression(memberAccess(accum, 'push'), [x]));
        };
        s.body = forceBlock(s.body);
        if (s.body.body.length) {
          lastExpression = s.body.body.slice(-1)[0];
          if (!lastExpression['instanceof'](JS.ThrowStatement))
            s.body.body[s.body.body.length - 1] = push(expr(lastExpression));
        } else {
          s.body.body.push(push(helpers.undef()));
        }
        block = new JS.BlockStatement([
          s,
          new JS.ReturnStatement(accum)
        ]);
        iife = new JS.FunctionExpression(null, [accum], block);
        return new JS.CallExpression(memberAccess(iife.g(), 'call'), [
          new JS.ThisExpression,
          new JS.ArrayExpression([])
        ]);
      } else if (s['instanceof'](JS.SwitchStatement, JS.TryStatement)) {
        block = new JS.BlockStatement([makeReturn(s)]);
        iife = new JS.FunctionExpression(null, [], block);
        return new JS.CallExpression(memberAccess(iife.g(), 'call'), [new JS.ThisExpression]);
      } else {
        throw new Error('expr: Cannot use a ' + s.type + ' as a value');
      }
    };
    makeReturn = function (node) {
      var stmts;
      if (!(null != node))
        return new JS.ReturnStatement;
      if (node['instanceof'](JS.BlockStatement)) {
        return new JS.BlockStatement([].slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
      } else if (node['instanceof'](JS.SequenceExpression)) {
        return new JS.SequenceExpression([].slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
      } else if (node['instanceof'](JS.IfStatement)) {
        return new JS.IfStatement(node.test, makeReturn(node.consequent), null != node.alternate ? makeReturn(node.alternate) : null);
      } else if (node['instanceof'](JS.SwitchStatement)) {
        return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
      } else if (node['instanceof'](JS.SwitchCase)) {
        if (!node.consequent.length)
          return node;
        stmts = node.consequent.slice(-1)[0]['instanceof'](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
        return new JS.SwitchCase(node.test, [].slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
      } else if (node['instanceof'](JS.TryStatement)) {
        return new JS.TryStatement(makeReturn(node.block), map(node.handlers, makeReturn), null != node.finalizer ? makeReturn(node.finalizer) : null);
      } else if (node['instanceof'](JS.CatchClause)) {
        return new JS.CatchClause(node.param, makeReturn(node.body));
      } else if (node['instanceof'](JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement)) {
        return node;
      } else if (node['instanceof'](JS.UnaryExpression) && node.operator === 'void') {
        return new JS.ReturnStatement;
      } else {
        return new JS.ReturnStatement(expr(node));
      }
    };
    generateMutatingWalker = function (fn) {
      return function (node, args) {
        var childName, n;
        args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
        for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
          childName = node.childNodes[i$];
          if (!(null != node[childName]))
            continue;
          node[childName] = in$(childName, node.listMembers) ? function (accum$) {
            for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
              n = node[childName][i$1];
              accum$.push(fn.apply(n, args));
            }
            return accum$;
          }.call(this, []) : fn.apply(node[childName], args);
        }
        return node;
      };
    };
    declarationsNeeded = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.AssignmentExpression) && node.operator === '=' && node.left['instanceof'](JS.Identifier)) {
        return [node.left];
      } else if (node['instanceof'](JS.ForInStatement) && node.left['instanceof'](JS.Identifier)) {
        return [node.left];
      } else {
        return [];
      }
    };
    declarationsNeededRecursive = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !node.generated) {
        return [];
      } else {
        return union(declarationsNeeded(node), concatMap(node.childNodes, function (childName) {
          if (!(null != node[childName]))
            return [];
          if (in$(childName, node.listMembers)) {
            return concatMap(node[childName], declarationsNeededRecursive);
          } else {
            return declarationsNeededRecursive(node[childName]);
          }
        }));
      }
    };
    variableDeclarations = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.FunctionDeclaration)) {
        return [node.id];
      } else if (node['instanceof'](JS.FunctionExpression) && !node.generated) {
        return [];
      } else if (node['instanceof'](JS.VariableDeclarator)) {
        return [node.id];
      } else {
        return concatMap(node.childNodes, function (childName) {
          if (!(null != node[childName]))
            return [];
          if (in$(childName, node.listMembers)) {
            return concatMap(node[childName], variableDeclarations);
          } else {
            return variableDeclarations(node[childName]);
          }
        });
      }
    };
    collectIdentifiers = function (node) {
      return nub(function () {
        switch (false) {
        case !!(null != node):
          return [];
        case !node['instanceof'](JS.Identifier):
          return [node.name];
        case !(node['instanceof'](JS.MemberExpression) && !node.computed):
          return collectIdentifiers(node.object);
        default:
          return concatMap(node.childNodes, function (childName) {
            if (!(null != node[childName]))
              return [];
            if (in$(childName, node.listMembers)) {
              return concatMap(node[childName], collectIdentifiers);
            } else {
              return collectIdentifiers(node[childName]);
            }
          });
        }
      }.call(this));
    };
    needsCaching = function (node) {
      if (!(null != node))
        return false;
      return envEnrichments(node, []).length > 0 || node['instanceof'](CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp, CS.PreIncrementOp, CS.PostIncrementOp, CS.PreDecrementOp, CS.PostDecrementOp, CS.Range) || any(difference(node.childNodes, node.listMembers), function (n) {
        return needsCaching(node[n]);
      }) || any(node.listMembers, function (n) {
        return any(node[n], needsCaching);
      });
    };
    forceBlock = function (node) {
      if (!(null != node))
        return new JS.BlockStatement([]);
      node = stmt(node);
      if (node['instanceof'](JS.BlockStatement)) {
        return node;
      } else {
        return new JS.BlockStatement([node]);
      }
    };
    makeVarDeclaration = function (vars) {
      var decls, v;
      vars.sort(function (a, b) {
        a = a.name.toLowerCase();
        b = b.name.toLowerCase();
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      decls = function (accum$) {
        for (var i$ = 0, length$ = vars.length; i$ < length$; ++i$) {
          v = vars[i$];
          accum$.push(new JS.VariableDeclarator(v));
        }
        return accum$;
      }.call(this, []);
      return new JS.VariableDeclaration('var', decls);
    };
    isIdentifierName = function (name) {
      return !in$(name, jsReserved) && /^[$_a-z][$_a-z0-9]*$/i.test(name);
    };
    memberAccess = function (e, member) {
      if (isIdentifierName(member)) {
        return new JS.MemberExpression(false, expr(e), new JS.Identifier(member));
      } else {
        return new JS.MemberExpression(true, expr(e), new JS.Literal(member));
      }
    };
    dynamicMemberAccess = function (e, index) {
      if (index['instanceof'](JS.Literal) && typeof index.value === 'string') {
        return memberAccess(e, index.value);
      } else {
        return new JS.MemberExpression(true, expr(e), expr(index));
      }
    };
    forceComputedProperty = function (fn, chains) {
      return emberComputedProperty(fn, chains);
    };
    emberComputedProperty = function (fn, chains) {
      var computed;
      computed = new JS.CallExpression(memberAccess(new JS.Identifier('Ember'), 'computed'), [fn]);
      chains = chains.map(function (c) {
        return new JS.Literal(c);
      });
      return new JS.CallExpression(memberAccess(computed, 'property'), chains);
    };
    assignment = function (assignee, expression, valueUsed) {
      var alternate, assignments, consequent, e, elements, i, index, m, numElements, p, propName, restName, size, test;
      if (null == valueUsed)
        valueUsed = false;
      assignments = [];
      expression = expr(expression);
      switch (false) {
      case !assignee.rest:
      case !assignee['instanceof'](JS.ArrayExpression):
        e = expression;
        if (valueUsed || assignee.elements.length > 1) {
          e = genSym('cache');
          assignments.push(new JS.AssignmentExpression('=', e, expression));
        }
        elements = assignee.elements;
        for (var i$ = 0, length$ = elements.length; i$ < length$; ++i$) {
          m = elements[i$];
          i = i$;
          if (m.rest)
            break;
          assignments.push(assignment(m, dynamicMemberAccess(e, new JS.Literal(i)), valueUsed));
        }
        if (elements.length > 0) {
          if (elements.slice(-1)[0].rest) {
            numElements = elements.length;
            restName = elements[numElements - 1] = elements[numElements - 1].expression;
            test = new JS.BinaryExpression('<=', new JS.Literal(numElements), memberAccess(e, 'length'));
            consequent = helpers.slice(e, new JS.Literal(numElements - 1));
            alternate = new JS.ArrayExpression([]);
            assignments.push(stmt(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, alternate))));
          } else if (any(elements, function (p) {
              return p.rest;
            })) {
            restName = index = null;
            for (var i$1 = 0, length$1 = elements.length; i$1 < length$1; ++i$1) {
              p = elements[i$1];
              i = i$1;
              if (!p.rest)
                continue;
              restName = p.expression;
              index = i;
              break;
            }
            elements.splice(index, 1);
            numElements = elements.length;
            size = genSym('size');
            assignments.push(new JS.AssignmentExpression('=', size, memberAccess(e, 'length')));
            test = new JS.BinaryExpression('>', size, new JS.Literal(numElements));
            consequent = helpers.slice(e, new JS.Literal(index), new JS.BinaryExpression('-', size, new JS.Literal(numElements - index)));
            assignments.push(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, new JS.ArrayExpression([]))));
            for (var i$2 = 0, length$2 = elements.slice(index).length; i$2 < length$2; ++i$2) {
              p = elements.slice(index)[i$2];
              i = i$2;
              assignments.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, e, new JS.BinaryExpression('-', size, new JS.Literal(numElements - index - i))))));
            }
          }
          if (any(elements, function (p) {
              return p.rest;
            }))
            throw new Error('Positional destructuring assignments may not have more than one rest operator');
        }
        break;
      case !assignee['instanceof'](JS.ObjectExpression):
        e = expression;
        if (valueUsed || assignee.properties.length > 1) {
          e = genSym('cache');
          assignments.push(new JS.AssignmentExpression('=', e, expression));
        }
        for (var i$3 = 0, length$3 = assignee.properties.length; i$3 < length$3; ++i$3) {
          m = assignee.properties[i$3];
          propName = m.key['instanceof'](JS.Identifier) ? new JS.Literal(m.key.name) : m.key;
          assignments.push(assignment(m.value, dynamicMemberAccess(e, propName), valueUsed));
        }
        break;
      case !assignee['instanceof'](JS.Identifier, JS.GenSym):
        assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
        break;
      case !assignee['instanceof'](JS.MemberExpression):
        if (assignee.computed && !(typeof assignee.property.value === 'string')) {
          assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
        } else if (assignee.computed) {
          assignments.push(helpers.set(assignee.object, assignee.property, expr(expression)));
        } else {
          assignments.push(helpers.set(assignee.object, new JS.Literal(assignee.property.name), expr(expression)));
        }
        break;
      default:
        throw new Error('compile: assignment: unassignable assignee: ' + assignee.type);
      }
      switch (assignments.length) {
      case 0:
        if (e === expression) {
          return helpers.undef();
        } else {
          return expression;
        }
      case 1:
        return assignments[0];
      default:
        return new JS.SequenceExpression(valueUsed ? [].slice.call(assignments).concat([e]) : assignments);
      }
    };
    hasSoak = function (node) {
      switch (false) {
      case !node['instanceof'](CS.SoakedFunctionApplication, CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
        return true;
      case !node['instanceof'](CS.FunctionApplication):
        return hasSoak(node['function']);
      case !node['instanceof'](CS.MemberAccessOps):
        return hasSoak(node.expression);
      default:
        return false;
      }
    };
    generateSoak = function () {
      var fn;
      fn = function (node) {
        var cache$2, cache$3, cache$4, cache$5, cache$6, ctor, e, memberName, sym, tests, typeofTest;
        switch (false) {
        case !node['instanceof'](CS.MemberAccessOp, CS.ProtoMemberAccessOp):
          cache$2 = fn(node.expression);
          tests = cache$2[0];
          e = cache$2[1];
          return [
            tests,
            new node.constructor(e, node.memberName)
          ];
        case !node['instanceof'](CS.DynamicMemberAccessOp, CS.DynamicProtoMemberAccessOp):
          cache$3 = fn(node.expression);
          tests = cache$3[0];
          e = cache$3[1];
          return [
            tests,
            new node.constructor(e, node.indexingExpr)
          ];
        case !node['instanceof'](CS.FunctionApplication):
          cache$4 = fn(node['function']);
          tests = cache$4[0];
          e = cache$4[1];
          return [
            tests,
            new CS.FunctionApplication(e, node['arguments'])
          ];
        case !node['instanceof'](CS.SoakedFunctionApplication):
          cache$5 = fn(node['function']);
          tests = cache$5[0];
          e = cache$5[1];
          typeofTest = function (e) {
            return new CS.EQOp(new CS.String('function'), new CS.TypeofOp(e));
          };
          if (needsCaching(e)) {
            sym = new CS.GenSym('cache');
            return [
              [].slice.call(tests).concat([typeofTest(new CS.AssignOp(sym, e))]),
              new CS.FunctionApplication(sym, node['arguments'])
            ];
          } else {
            return [
              [].slice.call(tests).concat([typeofTest(e)]),
              new CS.FunctionApplication(e, node['arguments'])
            ];
          }
        case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
          memberName = function () {
            switch (false) {
            case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp):
              return 'memberName';
            case !node['instanceof'](CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
              return 'indexingExpr';
            }
          }.call(this);
          ctor = function () {
            switch (false) {
            case !node['instanceof'](CS.SoakedMemberAccessOp):
              return CS.MemberAccessOp;
            case !node['instanceof'](CS.SoakedProtoMemberAccessOp):
              return CS.ProtoMemberAccessOp;
            case !node['instanceof'](CS.SoakedDynamicMemberAccessOp):
              return CS.DynamicMemberAccessOp;
            case !node['instanceof'](CS.SoakedDynamicProtoMemberAccessOp):
              return CS.DynamicProtoMemberAccessOp;
            }
          }.call(this);
          cache$6 = fn(node.expression);
          tests = cache$6[0];
          e = cache$6[1];
          if (needsCaching(e)) {
            sym = new CS.GenSym('cache');
            return [
              [].slice.call(tests).concat([new CS.UnaryExistsOp(new CS.AssignOp(sym, e))]),
              new ctor(sym, node[memberName])
            ];
          } else {
            return [
              [].slice.call(tests).concat([new CS.UnaryExistsOp(e)]),
              new ctor(e, node[memberName])
            ];
          }
        default:
          return [
            [],
            node
          ];
        }
      };
      return function (node) {
        var cache$2, e, tests;
        cache$2 = fn(node);
        tests = cache$2[0];
        e = cache$2[1];
        return new CS.Conditional(foldl1(tests, function (memo, t) {
          return new CS.LogicalAndOp(memo, t);
        }), e);
      };
    }();
    helperNames = {};
    helpers = {
      'extends': function () {
        var block, child, ctor, f, key, parent, protoAccess;
        protoAccess = function (e) {
          return memberAccess(e, 'prototype');
        };
        child = new JS.Identifier('child');
        parent = new JS.Identifier('parent');
        ctor = new JS.Identifier('ctor');
        key = new JS.Identifier('key');
        block = [
          new JS.ForInStatement(new JS.VariableDeclaration('var', [new JS.VariableDeclarator(key, null)]), parent, new JS.IfStatement(helpers.isOwn(parent, key), f = stmt(new JS.AssignmentExpression('=', new JS.MemberExpression(true, child, key), new JS.MemberExpression(true, parent, key))))),
          new JS.FunctionDeclaration(ctor, [], new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', memberAccess(new JS.ThisExpression, 'constructor'), child))])),
          new JS.AssignmentExpression('=', protoAccess(ctor), protoAccess(parent)),
          new JS.AssignmentExpression('=', protoAccess(child), new JS.NewExpression(ctor, [])),
          new JS.AssignmentExpression('=', memberAccess(child, '__super__'), protoAccess(parent)),
          new JS.ReturnStatement(child)
        ];
        return new JS.FunctionDeclaration(helperNames['extends'], [
          child,
          parent
        ], new JS.BlockStatement(map(block, stmt)));
      },
      construct: function () {
        var args, block, child, ctor, fn, result;
        child = new JS.Identifier('child');
        ctor = new JS.Identifier('ctor');
        fn = new JS.Identifier('fn');
        args = new JS.Identifier('args');
        result = new JS.Identifier('result');
        block = [
          new JS.VariableDeclaration('var', [new JS.VariableDeclarator(fn, new JS.FunctionExpression(null, [], new JS.BlockStatement([])))]),
          new JS.AssignmentExpression('=', memberAccess(fn, 'prototype'), memberAccess(ctor, 'prototype')),
          new JS.VariableDeclaration('var', [
            new JS.VariableDeclarator(child, new JS.NewExpression(fn, [])),
            new JS.VariableDeclarator(result, new JS.CallExpression(memberAccess(ctor, 'apply'), [
              child,
              args
            ]))
          ]),
          new JS.ReturnStatement(new JS.ConditionalExpression(new JS.BinaryExpression('===', result, new JS.CallExpression(new JS.Identifier('Object'), [result])), result, child))
        ];
        return new JS.FunctionDeclaration(helperNames.construct, [
          ctor,
          args
        ], new JS.BlockStatement(map(block, stmt)));
      },
      isOwn: function () {
        var args, functionBody, hop, params;
        hop = memberAccess(new JS.ObjectExpression([]), 'hasOwnProperty');
        params = args = [
          new JS.Identifier('o'),
          new JS.Identifier('p')
        ];
        functionBody = [new JS.CallExpression(memberAccess(hop, 'call'), args)];
        return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
      },
      'in': function () {
        var functionBody, i, length, list, loopBody, member, varDeclaration;
        member = new JS.Identifier('member');
        list = new JS.Identifier('list');
        i = new JS.Identifier('i');
        length = new JS.Identifier('length');
        varDeclaration = new JS.VariableDeclaration('var', [
          new JS.VariableDeclarator(i, new JS.Literal(0)),
          new JS.VariableDeclarator(length, memberAccess(list, 'length'))
        ]);
        loopBody = new JS.IfStatement(new JS.LogicalExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(new JS.Literal(true)));
        functionBody = [
          new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody),
          new JS.Literal(false)
        ];
        return new JS.FunctionDeclaration(helperNames['in'], [
          member,
          list
        ], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
      },
      get: function () {
        return new JS.VariableDeclaration('var', [new JS.VariableDeclarator(helperNames.get, memberAccess(new JS.Identifier('Ember'), 'get'))]);
      },
      set: function () {
        return new JS.VariableDeclaration('var', [new JS.VariableDeclarator(helperNames.set, memberAccess(new JS.Identifier('Ember'), 'set'))]);
      }
    };
    enabledHelpers = [];
    for (h in helpers) {
      if (!isOwn$(helpers, h))
        continue;
      fn = helpers[h];
      helperNames[h] = genSym(h);
      helpers[h] = function (h, fn) {
        return function () {
          enabledHelpers.push(fn());
          return (helpers[h] = function () {
            return new JS.CallExpression(helperNames[h], arguments);
          }).apply(this, arguments);
        };
      }(h, fn);
    }
    inlineHelpers = {
      exp: function () {
        return new JS.CallExpression(memberAccess(new JS.Identifier('Math'), 'pow'), arguments);
      },
      undef: function () {
        return new JS.UnaryExpression('void', new JS.Literal(0));
      },
      slice: function () {
        return new JS.CallExpression(memberAccess(memberAccess(new JS.ArrayExpression([]), 'slice'), 'call'), arguments);
      }
    };
    for (h in inlineHelpers) {
      if (!isOwn$(inlineHelpers, h))
        continue;
      fn = inlineHelpers[h];
      helpers[h] = fn;
    }
    exports.Compiler = function () {
      Compiler.compile = function (this$) {
        return function () {
          var cache$2;
          return (cache$2 = new this$).compile.apply(cache$2, [].slice.call(arguments));
        };
      }(Compiler);
      defaultRules = [
        [
          CS.Program,
          function (param$) {
            var block, body, cache$2, cache$3, decls, fnDeclHelpers, inScope, options, otherHelpers, pkg, program;
            {
              cache$2 = param$;
              body = cache$2.body;
              inScope = cache$2.inScope;
              options = cache$2.options;
            }
            if (!(null != body))
              return new JS.Program([]);
            block = stmt(body);
            block = block['instanceof'](JS.BlockStatement) ? block.body : [block];
            cache$3 = partition(enabledHelpers, function (helper) {
              return helper['instanceof'](JS.FunctionDeclaration);
            });
            fnDeclHelpers = cache$3[0];
            otherHelpers = cache$3[1];
            [].push.apply(block, fnDeclHelpers);
            [].unshift.apply(block, otherHelpers);
            decls = nub(concatMap(block, declarationsNeededRecursive));
            if (decls.length > 0)
              if (options.bare) {
                block.unshift(makeVarDeclaration(decls));
              } else {
                block = [stmt(new JS.UnaryExpression('void', new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), 'call'), [new JS.ThisExpression])))];
              }
            pkg = require('/package.json', module);
            program = new JS.Program(block);
            program.leadingComments = [{
                type: 'Line',
                value: ' Generated by EmberScript ' + pkg.version
              }];
            return program;
          }
        ],
        [
          CS.Block,
          function (param$) {
            var statements;
            statements = param$.statements;
            switch (statements.length) {
            case 0:
              return new JS.EmptyStatement;
            case 1:
              return new stmt(statements[0]);
            default:
              return new JS.BlockStatement(concatMap(statements, function (s) {
                if (s['instanceof'](JS.BlockStatement)) {
                  return map(s.body, stmt);
                } else if (s['instanceof'](JS.SequenceExpression)) {
                  return map(s.expressions, stmt);
                } else {
                  return [stmt(s)];
                }
              }));
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.SequenceExpression([
              left,
              right
            ]);
          }
        ],
        [
          CS.Conditional,
          function (param$) {
            var ancestry, cache$2, condition;
            var alternate, consequent;
            {
              cache$2 = param$;
              condition = cache$2.condition;
              consequent = cache$2.consequent;
              alternate = cache$2.alternate;
              ancestry = cache$2.ancestry;
            }
            if (null != alternate) {
              if (!(null != consequent))
                throw new Error('Conditional with non-null alternate requires non-null consequent');
              if (!alternate['instanceof'](JS.IfStatement))
                alternate = forceBlock(alternate);
            }
            if (null != alternate || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.Conditional) : void 0))
              consequent = forceBlock(consequent);
            return new JS.IfStatement(expr(condition), stmt(consequent), alternate);
          }
        ],
        [
          CS.ForIn,
          function (param$) {
            var block, body, cache$2, compile, e, filter, i, k, keyAssignee, length, op, step, target, update, valAssignee, varDeclaration;
            {
              cache$2 = param$;
              valAssignee = cache$2.valAssignee;
              keyAssignee = cache$2.keyAssignee;
              target = cache$2.target;
              step = cache$2.step;
              filter = cache$2.filter;
              body = cache$2.body;
              compile = cache$2.compile;
            }
            i = genSym('i');
            length = genSym('length');
            block = forceBlock(body);
            if (!block.body.length)
              block.body.push(stmt(helpers.undef()));
            if (this.target['instanceof'](CS.Range) && (this.target.left['instanceof'](CS.Int) || this.target.left['instanceof'](CS.UnaryNegateOp) && this.target.left.expression['instanceof'](CS.Int)) && (this.target.right['instanceof'](CS.Int) || this.target.right['instanceof'](CS.UnaryNegateOp) && this.target.right.expression['instanceof'](CS.Int))) {
              varDeclaration = new JS.AssignmentExpression('=', i, compile(this.target.left));
              update = new JS.UpdateExpression('++', true, i);
              if (null != keyAssignee) {
                k = genSym('k');
                varDeclaration = new JS.SequenceExpression([
                  new JS.AssignmentExpression('=', k, new JS.Literal(0)),
                  varDeclaration
                ]);
                update = new JS.SequenceExpression([
                  new JS.UpdateExpression('++', true, k),
                  update
                ]);
                block.body.unshift(stmt(new JS.AssignmentExpression('=', keyAssignee, k)));
              }
              if (null != valAssignee)
                block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, i)));
              op = this.target.isInclusive ? '<=' : '<';
              return new JS.ForStatement(varDeclaration, new JS.BinaryExpression(op, i, compile(this.target.right)), update, block);
            }
            e = needsCaching(this.target) ? genSym('cache') : target;
            varDeclaration = new JS.VariableDeclaration('var', [
              new JS.VariableDeclarator(i, new JS.Literal(0)),
              new JS.VariableDeclarator(length, memberAccess(e, 'length'))
            ]);
            if (!(e === target))
              varDeclaration.declarations.unshift(new JS.VariableDeclarator(e, target));
            if (null != this.filter)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
            if (null != keyAssignee)
              block.body.unshift(stmt(assignment(keyAssignee, i)));
            if (null != valAssignee)
              block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, i))));
            return new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), block);
          }
        ],
        [
          CS.ForOf,
          function (param$) {
            var block, body, cache$2, e, filter, keyAssignee, right, target, valAssignee;
            {
              cache$2 = param$;
              keyAssignee = cache$2.keyAssignee;
              valAssignee = cache$2.valAssignee;
              target = cache$2.target;
              filter = cache$2.filter;
              body = cache$2.body;
            }
            block = forceBlock(body);
            if (!block.body.length)
              block.body.push(stmt(helpers.undef()));
            e = this.isOwn && needsCaching(this.target) ? genSym('cache') : expr(target);
            if (null != this.filter)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
            if (null != valAssignee)
              block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, keyAssignee))));
            if (this.isOwn)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(e, keyAssignee)), new JS.ContinueStatement)));
            right = e === target ? e : new JS.AssignmentExpression('=', e, target);
            return new JS.ForInStatement(keyAssignee, right, block);
          }
        ],
        [
          CS.While,
          function (param$) {
            var body, cache$2, condition;
            {
              cache$2 = param$;
              condition = cache$2.condition;
              body = cache$2.body;
            }
            return new JS.WhileStatement(expr(condition), forceBlock(body));
          }
        ],
        [
          CS.Switch,
          function (param$) {
            var alternate, c, cache$2;
            var cases, expression;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              cases = cache$2.cases;
              alternate = cache$2.alternate;
            }
            cases = concat(cases);
            if (!(null != expression)) {
              expression = new JS.Literal(false);
              for (var i$ = 0, length$ = cases.length; i$ < length$; ++i$) {
                c = cases[i$];
                c.test = new JS.UnaryExpression('!', c.test);
              }
            }
            if (null != alternate)
              cases.push(new JS.SwitchCase(null, [stmt(alternate)]));
            for (var i$1 = 0, length$1 = cases.slice(0, -1).length; i$1 < length$1; ++i$1) {
              c = cases.slice(0, -1)[i$1];
              if (!((null != c.consequent ? c.consequent.length : void 0) > 0))
                continue;
              c.consequent.push(new JS.BreakStatement);
            }
            return new JS.SwitchStatement(expression, cases);
          }
        ],
        [
          CS.SwitchCase,
          function (param$) {
            var block, cache$2, cases, conditions, consequent;
            {
              cache$2 = param$;
              conditions = cache$2.conditions;
              consequent = cache$2.consequent;
            }
            cases = map(conditions, function (c) {
              return new JS.SwitchCase(c, []);
            });
            block = stmt(consequent);
            block = null != block ? block['instanceof'](JS.BlockStatement) ? block.body : [block] : [];
            cases[cases.length - 1].consequent = block;
            return cases;
          }
        ],
        [
          CS.Try,
          function (param$) {
            var body, cache$2, catchAssignee, catchBlock, catchBody, e, finallyBlock, finallyBody, handlers;
            {
              cache$2 = param$;
              body = cache$2.body;
              catchAssignee = cache$2.catchAssignee;
              catchBody = cache$2.catchBody;
              finallyBody = cache$2.finallyBody;
            }
            finallyBlock = null != this.finallyBody ? forceBlock(finallyBody) : null;
            if (null != this.catchBody || !(null != this.finallyBody)) {
              e = genSym('e');
              catchBlock = forceBlock(catchBody);
              if (null != catchAssignee)
                catchBlock.body.unshift(stmt(assignment(catchAssignee, e)));
              handlers = [new JS.CatchClause(e, catchBlock)];
            } else {
              handlers = [];
            }
            return new JS.TryStatement(forceBlock(body), handlers, finallyBlock);
          }
        ],
        [
          CS.Throw,
          function (param$) {
            var expression;
            expression = param$.expression;
            return new JS.ThrowStatement(expression);
          }
        ],
        [
          CS.Range,
          function (param$) {
            var accum, ancestry, body, cache$2, condition, conditionAlternate, conditionConsequent, conditionTest, i, left, left_, range, rawLeft, rawRight, right, right_, update, vars;
            {
              cache$2 = param$;
              left_ = cache$2.left;
              right_ = cache$2.right;
              ancestry = cache$2.ancestry;
            }
            if ((this.left['instanceof'](CS.Int) || this.left['instanceof'](CS.UnaryNegateOp) && this.left.expression['instanceof'](CS.Int)) && (this.right['instanceof'](CS.Int) || this.right['instanceof'](CS.UnaryNegateOp) && this.right.expression['instanceof'](CS.Int))) {
              rawLeft = this.left['instanceof'](CS.UnaryNegateOp) ? -this.left.expression.data : this.left.data;
              rawRight = this.right['instanceof'](CS.UnaryNegateOp) ? -this.right.expression.data : this.right.data;
              if (Math.abs(rawLeft - rawRight) <= 20) {
                range = this.isInclusive ? function () {
                  var accum$;
                  accum$ = [];
                  for (var i$ = rawLeft; rawLeft <= rawRight ? i$ <= rawRight : i$ >= rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                    accum$.push(i$);
                  return accum$;
                }.apply(this, arguments) : function () {
                  var accum$;
                  accum$ = [];
                  for (var i$ = rawLeft; rawLeft <= rawRight ? i$ < rawRight : i$ > rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                    accum$.push(i$);
                  return accum$;
                }.apply(this, arguments);
                return new JS.ArrayExpression(map(range, function (n) {
                  if (n < 0) {
                    return new JS.UnaryExpression('-', new JS.Literal(-n));
                  } else {
                    return new JS.Literal(n);
                  }
                }));
              }
            }
            accum = genSym('accum');
            body = [stmt(new JS.AssignmentExpression('=', accum, new JS.ArrayExpression([])))];
            if (needsCaching(left_)) {
              left = genSym('from');
              body.push(stmt(new JS.AssignmentExpression('=', left, left_)));
            } else {
              left = left_;
            }
            if (needsCaching(right_)) {
              right = genSym('to');
              body.push(stmt(new JS.AssignmentExpression('=', right, right_)));
            } else {
              right = right_;
            }
            i = genSym('i');
            vars = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, left)]);
            conditionTest = new JS.BinaryExpression('<=', left, right);
            conditionConsequent = new JS.BinaryExpression(this.isInclusive ? '<=' : '<', i, right);
            conditionAlternate = new JS.BinaryExpression(this.isInclusive ? '>=' : '>', i, right);
            condition = new JS.ConditionalExpression(conditionTest, conditionConsequent, conditionAlternate);
            update = new JS.ConditionalExpression(conditionTest, new JS.UpdateExpression('++', true, i), new JS.UpdateExpression('--', true, i));
            body.push(new JS.ForStatement(vars, condition, update, stmt(new JS.CallExpression(memberAccess(accum, 'push'), [i]))));
            body.push(new JS.ReturnStatement(accum));
            if (any(ancestry, function (ancestor) {
                return ancestor['instanceof'](CS.Functions);
              })) {
              return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'apply'), [
                new JS.ThisExpression,
                new JS.Identifier('arguments')
              ]);
            } else {
              return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'call'), [new JS.ThisExpression]);
            }
          }
        ],
        [
          CS.ArrayInitialiser,
          function () {
            var groupMembers;
            groupMembers = function (members) {
              var cache$2, cache$3, sliced, ys, zs;
              if (members.length === 0) {
                return [];
              } else {
                cache$2 = span(members, function (x) {
                  return !x.spread;
                });
                ys = cache$2[0];
                zs = cache$2[1];
                if (ys.length === 0) {
                  sliced = helpers.slice(zs[0].expression);
                  cache$3 = [
                    sliced,
                    zs.slice(1)
                  ];
                  ys = cache$3[0];
                  zs = cache$3[1];
                  cache$3;
                } else {
                  ys = new JS.ArrayExpression(map(ys, expr));
                }
                return [ys].concat(groupMembers(zs));
              }
            };
            return function (param$) {
              var cache$2, compile, grouped, members;
              {
                cache$2 = param$;
                members = cache$2.members;
                compile = cache$2.compile;
              }
              if (any(members, function (m) {
                  return m.spread;
                })) {
                grouped = map(groupMembers(members), expr);
                if (grouped.length <= 1) {
                  return grouped[0];
                } else {
                  return new JS.CallExpression(memberAccess(grouped[0], 'concat'), grouped.slice(1));
                }
              } else {
                return new JS.ArrayExpression(map(members, expr));
              }
            };
          }()
        ],
        [
          CS.Spread,
          function (param$) {
            var expression;
            expression = param$.expression;
            return {
              spread: true,
              expression: expr(expression)
            };
          }
        ],
        [
          CS.ObjectInitialiser,
          function (param$) {
            var members;
            members = param$.members;
            return new JS.ObjectExpression(members);
          }
        ],
        [
          CS.ObjectInitialiserMember,
          function (param$) {
            var args, cache$2, computed, keyName, observes, volatile;
            var expression, key;
            {
              cache$2 = param$;
              key = cache$2.key;
              expression = cache$2.expression;
            }
            expression = expr(expression);
            this.annotations || (this.annotations = []);
            if (computed = _.find(this.annotations, function (a) {
                return a['instanceof'](CS.Computed);
              }))
              expression = forceComputedProperty(expression, computed.parameters);
            if (volatile = _.find(this.annotations, function (a) {
                return a['instanceof'](CS.Volatile);
              })) {
              expression = forceComputedProperty(expression, volatile.parameters);
              expression = new JS.CallExpression(memberAccess(expression, 'volatile'), []);
            }
            if (observes = _.find(this.annotations, function (a) {
                return a['instanceof'](CS.Observes);
              })) {
              args = observes.parameters.map(function (p) {
                return new JS.Literal(p);
              }).concat(expression);
              expression = new JS.CallExpression(memberAccess(new JS.Identifier('Ember'), 'observer'), args);
            }
            keyName = this.key.data;
            key = isIdentifierName(keyName) ? new JS.Identifier(keyName) : new JS.Literal(keyName);
            return new JS.Property(key, expression);
          }
        ],
        [
          CS.DefaultParam,
          function (param$) {
            var cache$2, d, param;
            {
              cache$2 = param$;
              param = cache$2.param;
              d = cache$2['default'];
            }
            return {
              param: param,
              'default': d
            };
          }
        ],
        [
          CS.Function,
          CS.BoundFunction,
          CS.ComputedProperty,
          function () {
            var handleParam;
            handleParam = function (param, original, block, inScope) {
              var decls, p;
              switch (false) {
              case !original['instanceof'](CS.Rest):
                return param;
              case !original['instanceof'](CS.Identifier):
                return param;
              case !original['instanceof'](CS.MemberAccessOps, CS.ObjectInitialiser, CS.ArrayInitialiser):
                p = genSym('param');
                decls = map(intersect(inScope, beingDeclared(original)), function (i) {
                  return new JS.Identifier(i);
                });
                block.body.unshift(stmt(assignment(param, p)));
                if (decls.length)
                  block.body.unshift(makeVarDeclaration(decls));
                return p;
              case !original['instanceof'](CS.DefaultParam):
                p = handleParam.call(this, param.param, original.param, block, inScope);
                block.body.unshift(new JS.IfStatement(new JS.BinaryExpression('==', new JS.Literal(null), p), stmt(assignment(p, param['default']))));
                return p;
              default:
                throw new Error('Unsupported parameter type: ' + original.className);
              }
            };
            return function (param$) {
              var alternate, ancestry, block, cache$2, chains, consequent, i, index, inScope, last, newThis, numArgs, numParams, p, parameters_, paramName, performedRewrite, pIndex, reassignments, rewriteThis, test;
              var body, parameters;
              {
                cache$2 = param$;
                parameters = cache$2.parameters;
                body = cache$2.body;
                ancestry = cache$2.ancestry;
                inScope = cache$2.inScope;
              }
              if (!(null != ancestry[0] ? ancestry[0]['instanceof'](CS.Constructor) : void 0))
                body = makeReturn(body);
              block = forceBlock(body);
              last = block.body.slice(-1)[0];
              if ((null != last ? last['instanceof'](JS.ReturnStatement) : void 0) && !(null != last.argument))
                block.body = block.body.slice(0, -1);
              parameters_ = parameters.length === 0 ? [] : (pIndex = parameters.length, function (accum$) {
                while (pIndex--) {
                  accum$.push(handleParam.call(this, parameters[pIndex], this.parameters[pIndex], block, inScope));
                }
                return accum$;
              }.call(this, []));
              parameters = parameters_.reverse();
              if (parameters.length > 0) {
                if (parameters.slice(-1)[0].rest) {
                  paramName = parameters.pop().expression;
                  numParams = parameters.length;
                  test = new JS.BinaryExpression('>', memberAccess(new JS.Identifier('arguments'), 'length'), new JS.Literal(numParams));
                  consequent = helpers.slice(new JS.Identifier('arguments'), new JS.Literal(numParams));
                  alternate = new JS.ArrayExpression([]);
                  if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                    block.body.unshift(makeVarDeclaration([paramName]));
                  block.body.unshift(stmt(new JS.AssignmentExpression('=', paramName, new JS.ConditionalExpression(test, consequent, alternate))));
                } else if (any(parameters, function (p) {
                    return p.rest;
                  })) {
                  paramName = index = null;
                  for (var i$ = 0, length$ = parameters.length; i$ < length$; ++i$) {
                    p = parameters[i$];
                    i = i$;
                    if (!p.rest)
                      continue;
                    paramName = p.expression;
                    index = i;
                    break;
                  }
                  parameters.splice(index, 1);
                  numParams = parameters.length;
                  numArgs = genSym('numArgs');
                  reassignments = new JS.IfStatement(new JS.BinaryExpression('>', new JS.AssignmentExpression('=', numArgs, memberAccess(new JS.Identifier('arguments'), 'length')), new JS.Literal(numParams)), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, helpers.slice(new JS.Identifier('arguments'), new JS.Literal(index), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index)))))]), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, new JS.ArrayExpression([])))]));
                  for (var i$1 = 0, length$1 = parameters.slice(index).length; i$1 < length$1; ++i$1) {
                    p = parameters.slice(index)[i$1];
                    i = i$1;
                    reassignments.consequent.body.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, new JS.Identifier('arguments'), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index - i))))));
                  }
                  if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                    block.body.unshift(makeVarDeclaration([paramName]));
                  block.body.unshift(reassignments);
                }
                if (any(parameters, function (p) {
                    return p.rest;
                  }))
                  throw new Error('Parameter lists may not have more than one rest operator');
              }
              performedRewrite = false;
              if (this['instanceof'](CS.BoundFunction)) {
                newThis = genSym('this');
                rewriteThis = generateMutatingWalker(function () {
                  if (this['instanceof'](JS.ThisExpression)) {
                    performedRewrite = true;
                    return newThis;
                  } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
                    return this;
                  } else {
                    return rewriteThis(this);
                  }
                });
                rewriteThis(block);
              }
              fn = new JS.FunctionExpression(null, parameters, block);
              if (performedRewrite)
                fn = new JS.CallExpression(new JS.FunctionExpression(null, [newThis], new JS.BlockStatement([new JS.ReturnStatement(fn)])), [new JS.ThisExpression]);
              if (this['instanceof'](CS.ComputedProperty)) {
                chains = _.uniq(this.dependentKeys().map(function (c) {
                  return c.join('.');
                }));
                return emberComputedProperty(fn, chains);
              } else {
                return fn;
              }
            };
          }()
        ],
        [
          CS.Rest,
          function (param$) {
            var expression;
            expression = param$.expression;
            return {
              rest: true,
              expression: expression,
              isExpression: true,
              isStatement: true
            };
          }
        ],
        [
          CS.Mixin,
          function (param$) {
            var body, cache$2, compile, createArgs, iife, mixinExpr, mixins, name, nameAssignee;
            {
              cache$2 = param$;
              nameAssignee = cache$2.nameAssignee;
              name = cache$2.name;
              body = cache$2.body;
              mixins = cache$2.mixins;
              compile = cache$2.compile;
            }
            createArgs = mixins;
            if (body)
              createArgs.push(body);
            mixinExpr = memberAccess(new JS.Identifier('Ember'), 'Mixin');
            iife = new JS.CallExpression(memberAccess(mixinExpr, 'create'), createArgs);
            if (null != nameAssignee) {
              return assignment(nameAssignee, iife);
            } else {
              return iife;
            }
          }
        ],
        [
          CS.Class,
          function (param$) {
            var args, body, cache$2, compile, ctor, extendArgs, iife, mixins, name, nameAssignee, params, parent, parentExpr, parentRef;
            {
              cache$2 = param$;
              nameAssignee = cache$2.nameAssignee;
              parent = cache$2.parent;
              name = cache$2.name;
              ctor = cache$2.ctor;
              body = cache$2.body;
              mixins = cache$2.mixins;
              compile = cache$2.compile;
            }
            args = [];
            params = [];
            parentRef = genSym('super');
            extendArgs = mixins;
            if (body)
              extendArgs.push(body);
            parentExpr = null != parent ? parent : memberAccess(new JS.Identifier('Ember'), 'Object');
            iife = new JS.CallExpression(memberAccess(parentExpr, 'extend'), extendArgs);
            if (null != nameAssignee) {
              return assignment(nameAssignee, iife);
            } else {
              return iife;
            }
          }
        ],
        [
          CS.Constructor,
          function (param$) {
            var expression, tmpName;
            expression = param$.expression;
            tmpName = genSym('class');
            if (this.expression['instanceof'](CS.Functions)) {
              return new JS.FunctionDeclaration(tmpName, expression.params, forceBlock(expression.body));
            } else {
              return new JS.FunctionDeclaration(tmpName, [], new JS.BlockStatement([]));
            }
          }
        ],
        [
          CS.ClassProtoAssignOp,
          function (param$) {
            var assignee, cache$2, compile, expression, protoMember;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (this.expression['instanceof'](CS.BoundFunction)) {
              return compile(new CS.ClassProtoAssignOp(this.assignee, new CS.Function(this.expression.parameters, this.expression.body)));
            } else {
              protoMember = memberAccess(memberAccess(new JS.ThisExpression, 'prototype'), this.assignee.data);
              return new JS.Property(protoMember, expression);
            }
          }
        ],
        [
          CS.AssignOp,
          function (param$) {
            var ancestry, assignee, cache$2, expression;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              ancestry = cache$2.ancestry;
            }
            return assignment(assignee, expression, usedAsExpression(this, ancestry));
          }
        ],
        [
          CS.CompoundAssignOp,
          function (param$) {
            var assignee, cache$2, condition, expression, inScope, op;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              inScope = cache$2.inScope;
            }
            op = function () {
              switch (this.op) {
              case CS.LogicalAndOp.prototype.className:
                return '&&';
              case CS.LogicalOrOp.prototype.className:
                return '||';
              case CS.ExistsOp.prototype.className:
                return '?';
              case CS.BitOrOp.prototype.className:
                return '|';
              case CS.BitXorOp.prototype.className:
                return '^';
              case CS.BitAndOp.prototype.className:
                return '&';
              case CS.LeftShiftOp.prototype.className:
                return '<<';
              case CS.SignedRightShiftOp.prototype.className:
                return '>>';
              case CS.UnsignedRightShiftOp.prototype.className:
                return '>>>';
              case CS.PlusOp.prototype.className:
                return '+';
              case CS.SubtractOp.prototype.className:
                return '-';
              case CS.MultiplyOp.prototype.className:
                return '*';
              case CS.DivideOp.prototype.className:
                return '/';
              case CS.RemOp.prototype.className:
                return '%';
              case CS.ExpOp.prototype.className:
                return '**';
              default:
                throw new Error('Unrecognised compound assignment operator');
              }
            }.call(this);
            if ((op === '&&' || op === '||' || op === '?') && assignee['instanceof'](JS.Identifier) && !in$(assignee.name, inScope))
              throw new Error('the variable "' + assignee.name + '" can\'t be assigned with ?= because it has not been defined.');
            switch (op) {
            case '&&':
            case '||':
              return new JS.LogicalExpression(op, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
            case '?':
              condition = new JS.BinaryExpression('!=', new JS.Literal(null), assignee);
              return new JS.ConditionalExpression(condition, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
            case '**':
              return new JS.AssignmentExpression('=', assignee, helpers.exp(assignee, expr(expression)));
            default:
              return new JS.AssignmentExpression('' + op + '=', assignee, expr(expression));
            }
          }
        ],
        [
          CS.ChainedComparisonOp,
          function (param$) {
            var cache$2, compile, expression, left, lhs;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (!this.expression.left['instanceof'](CS.ComparisonOps))
              return expression;
            left = expression.left.right;
            lhs = compile(new CS.ChainedComparisonOp(this.expression.left));
            if (needsCaching(this.expression.left.right)) {
              left = genSym('cache');
              if (this.expression.left.left['instanceof'](CS.ComparisonOps)) {
                lhs.right.right = new JS.AssignmentExpression('=', left, lhs.right.right);
              } else {
                lhs.right = new JS.AssignmentExpression('=', left, lhs.right);
              }
            }
            return new JS.LogicalExpression('&&', lhs, new JS.BinaryExpression(expression.operator, left, expression.right));
          }
        ],
        [
          CS.FunctionApplication,
          function (param$) {
            var args, cache$2, compile, context, lhs;
            var fn;
            {
              cache$2 = param$;
              fn = cache$2['function'];
              args = cache$2['arguments'];
              compile = cache$2.compile;
            }
            if (any(args, function (m) {
                return m.spread;
              })) {
              lhs = this['function'];
              context = new CS.Null;
              if (needsCaching(this['function'])) {
                context = new CS.GenSym('cache');
                lhs = this['function']['instanceof'](CS.StaticMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].memberName) : this['function']['instanceof'](CS.DynamicMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].indexingExpr) : new CS.AssignOp(context, lhs);
              } else if (lhs['instanceof'](CS.MemberAccessOps)) {
                context = lhs.expression;
              }
              if (this['function']['instanceof'](CS.ProtoMemberAccessOp, CS.DynamicProtoMemberAccessOp)) {
                context = new CS.MemberAccessOp(context, 'prototype');
              } else if (this['function']['instanceof'](CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp)) {
                context = new CS.SoakedMemberAccessOp(context, 'prototype');
              }
              return compile(new CS.FunctionApplication(new CS.MemberAccessOp(lhs, 'apply'), [
                context,
                new CS.ArrayInitialiser(this['arguments'])
              ]));
            } else if (hasSoak(this)) {
              return compile(generateSoak(this));
            } else {
              return new JS.CallExpression(expr(fn), map(args, expr));
            }
          }
        ],
        [
          CS.SoakedFunctionApplication,
          function (param$) {
            var compile;
            compile = param$.compile;
            return compile(generateSoak(this));
          }
        ],
        [
          CS.NewOp,
          function (param$) {
            var args, cache$2, compile, ctor;
            {
              cache$2 = param$;
              ctor = cache$2.ctor;
              args = cache$2['arguments'];
              compile = cache$2.compile;
            }
            if (any(args, function (m) {
                return m.spread;
              })) {
              return helpers.construct(ctor, compile(new CS.ArrayInitialiser(this['arguments'])));
            } else {
              return new JS.NewExpression(ctor, map(args, expr));
            }
          }
        ],
        [
          CS.HeregExp,
          function (param$) {
            var args, expression, flag, flags;
            expression = param$.expression;
            args = [expression];
            if (flags = function (accum$) {
                for (var cache$2 = [
                      'g',
                      'i',
                      'm',
                      'y'
                    ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
                  flag = cache$2[i$];
                  if (!this.flags[flag])
                    continue;
                  accum$.push(flag);
                }
                return accum$;
              }.call(this, []).join(''))
              args.push(new JS.Literal(flags));
            return new JS.NewExpression(new JS.Identifier('RegExp'), args);
          }
        ],
        [
          CS.RegExp,
          function () {
            var flag, flags, re;
            flags = function (accum$) {
              for (var cache$2 = [
                    'g',
                    'i',
                    'm',
                    'y'
                  ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
                flag = cache$2[i$];
                if (!this.flags[flag])
                  continue;
                accum$.push(flag);
              }
              return accum$;
            }.call(this, []).join('');
            re = new RegExp(this.data, flags);
            return new JS.Literal(re);
          }
        ],
        [
          CS.ConcatOp,
          function (param$) {
            var ancestry, cache$2, left, leftmost, plusOp, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
              ancestry = cache$2.ancestry;
            }
            plusOp = new JS.BinaryExpression('+', expr(left), expr(right));
            if (!ancestry[0]['instanceof'](CS.ConcatOp)) {
              leftmost = plusOp;
              while (null != (null != leftmost.left ? leftmost.left.left : void 0)) {
                leftmost = leftmost.left;
              }
              if (!(leftmost.left['instanceof'](JS.Literal) && 'string' === typeof leftmost.left.value))
                leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
            }
            return plusOp;
          }
        ],
        [
          CS.MemberAccessOp,
          CS.SoakedMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, parent;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            parent = arguments[0].ancestry[0];
            this.isFunctionContext = parent['instanceof'](CS.FunctionApplications) && parent['function'] === this;
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else if (this.isAssignment || this.isFunctionContext || expression['instanceof'](JS.Literal) || parent['instanceof'](CS.DeleteOp) || expression.name === 'Ember') {
              return memberAccess(expression, this.memberName);
            } else {
              return helpers.get(expression, new JS.Literal(this.memberName));
            }
          }
        ],
        [
          CS.NativeMemberAccessOp,
          function (param$) {
            var access, cache$2, compile, expression, offset;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              access = memberAccess(expression, this.memberName);
              if (this.raw) {
                access.property.raw = this.memberName;
                access.property.line = this.line;
                offset = this.raw.length - this.memberName.length;
                access.property.column = this.column + offset - 1;
                access.property.offset = this.offset + offset - 1;
                this.column += this.expression.raw.length;
                this.offset += this.expression.raw.length;
              }
              return access;
            }
          }
        ],
        [
          CS.ProtoMemberAccessOp,
          CS.SoakedProtoMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return memberAccess(memberAccess(expression, 'prototype'), this.memberName);
            }
          }
        ],
        [
          CS.DynamicMemberAccessOp,
          CS.SoakedDynamicMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, indexingExpr;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              indexingExpr = cache$2.indexingExpr;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return dynamicMemberAccess(expression, indexingExpr);
            }
          }
        ],
        [
          CS.DynamicProtoMemberAccessOp,
          CS.SoakedDynamicProtoMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, indexingExpr;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              indexingExpr = cache$2.indexingExpr;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return dynamicMemberAccess(memberAccess(expression, 'prototype'), indexingExpr);
            }
          }
        ],
        [
          CS.Slice,
          function (param$) {
            var args, cache$2, expression, left, right;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              left = cache$2.left;
              right = cache$2.right;
            }
            args = null != left ? [left] : null != right ? [new JS.Literal(0)] : [];
            if (null != right)
              args.push(this.isInclusive ? right['instanceof'](JS.Literal) && typeof right.data === 'number' ? new JS.Literal(right.data + 1) : new JS.LogicalExpression('||', new JS.BinaryExpression('+', new JS.UnaryExpression('+', right), new JS.Literal(1)), new JS.Literal(9e9)) : right);
            return new JS.CallExpression(memberAccess(expression, 'slice'), args);
          }
        ],
        [
          CS.ExistsOp,
          function (param$) {
            var ancestry, cache$2, condition, e, inScope, node;
            var left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
              ancestry = cache$2.ancestry;
              inScope = cache$2.inScope;
            }
            left = expr(left);
            right = expr(right);
            e = needsCaching(this.left) ? genSym('cache') : left;
            condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
            if (e['instanceof'](JS.Identifier) && !in$(e.name, inScope))
              condition = new JS.LogicalExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
            node = new JS.ConditionalExpression(condition, e, right);
            if (e === left) {
              return node;
            } else {
              return new JS.SequenceExpression([
                new JS.AssignmentExpression('=', e, left),
                node
              ]);
            }
          }
        ],
        [
          CS.UnaryExistsOp,
          function (param$) {
            var cache$2, expression, inScope, nullTest, typeofTest;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              inScope = cache$2.inScope;
            }
            nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
            if (expression['instanceof'](JS.Identifier) && !in$(expression.name, inScope)) {
              typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
              return new JS.LogicalExpression('&&', typeofTest, nullTest);
            } else {
              return nullTest;
            }
          }
        ],
        [
          CS.DoOp,
          function () {
            var deriveArgsFromParams;
            deriveArgsFromParams = function (params) {
              var args, index, param;
              return args = function (accum$) {
                for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                  param = params[i$];
                  index = i$;
                  accum$.push(function () {
                    switch (false) {
                    case !param['instanceof'](CS.DefaultParam):
                      params[index] = param.param;
                      return param['default'];
                    case !param['instanceof'](CS.Identifier, CS.MemberAccessOp):
                      return param;
                    default:
                      return helpers.undef();
                    }
                  }.call(this));
                }
                return accum$;
              }.call(this, []);
            };
            return function (param$) {
              var args, cache$2, compile, expression;
              {
                cache$2 = param$;
                expression = cache$2.expression;
                compile = cache$2.compile;
              }
              args = [];
              if (this.expression['instanceof'](CS.AssignOp) && this.expression.expression['instanceof'](CS.Functions)) {
                args = deriveArgsFromParams(this.expression.expression.parameters);
              } else if (this.expression['instanceof'](CS.Functions)) {
                args = deriveArgsFromParams(this.expression.parameters);
              }
              return compile(new CS.FunctionApplication(this.expression, args));
            };
          }()
        ],
        [
          CS.Return,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.ReturnStatement(expr(e));
          }
        ],
        [
          CS.Break,
          function () {
            return new JS.BreakStatement;
          }
        ],
        [
          CS.Continue,
          function () {
            return new JS.ContinueStatement;
          }
        ],
        [
          CS.Debugger,
          function () {
            return new JS.DebuggerStatement;
          }
        ],
        [
          CS.ExpOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return helpers.exp(expr(left), expr(right));
          }
        ],
        [
          CS.DivideOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('/', expr(left), expr(right));
          }
        ],
        [
          CS.MultiplyOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('*', expr(left), expr(right));
          }
        ],
        [
          CS.RemOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('%', expr(left), expr(right));
          }
        ],
        [
          CS.PlusOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('+', expr(left), expr(right));
          }
        ],
        [
          CS.SubtractOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('-', expr(left), expr(right));
          }
        ],
        [
          CS.OfOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('in', expr(left), expr(right));
          }
        ],
        [
          CS.InOp,
          function (param$) {
            var cache$2, comparisons, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            if (right['instanceof'](JS.ArrayExpression) && right.elements.length < 5) {
              switch (right.elements.length) {
              case 0:
                if (needsCaching(this.left)) {
                  return new JS.SequenceExpression([
                    left,
                    new JS.Literal(false)
                  ]);
                } else {
                  return new JS.Literal(false);
                }
              case 1:
                return new JS.BinaryExpression('===', left, right.elements[0]);
              default:
                if (needsCaching(this.left)) {
                  return helpers['in'](expr(left), expr(right));
                } else {
                  comparisons = map(right.elements, function (e) {
                    return new JS.BinaryExpression('===', left, e);
                  });
                  return foldl1(comparisons, function (l, r) {
                    return new JS.LogicalExpression('||', l, r);
                  });
                }
              }
            } else {
              return helpers['in'](expr(left), expr(right));
            }
          }
        ],
        [
          CS.ExtendsOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return helpers['extends'](expr(left), expr(right));
          }
        ],
        [
          CS.InstanceofOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('instanceof', expr(left), expr(right));
          }
        ],
        [
          CS.LogicalAndOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.LogicalExpression('&&', expr(left), expr(right));
          }
        ],
        [
          CS.LogicalOrOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.LogicalExpression('||', expr(left), expr(right));
          }
        ],
        [
          CS.EQOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('===', expr(left), expr(right));
          }
        ],
        [
          CS.NEQOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('!==', expr(left), expr(right));
          }
        ],
        [
          CS.GTEOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>=', expr(left), expr(right));
          }
        ],
        [
          CS.GTOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>', expr(left), expr(right));
          }
        ],
        [
          CS.LTEOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<=', expr(left), expr(right));
          }
        ],
        [
          CS.LTOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<', expr(left), expr(right));
          }
        ],
        [
          CS.BitAndOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('&', expr(left), expr(right));
          }
        ],
        [
          CS.BitOrOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('|', expr(left), expr(right));
          }
        ],
        [
          CS.BitXorOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('^', expr(left), expr(right));
          }
        ],
        [
          CS.LeftShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<<', expr(left), expr(right));
          }
        ],
        [
          CS.SignedRightShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>>', expr(left), expr(right));
          }
        ],
        [
          CS.UnsignedRightShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>>>', expr(left), expr(right));
          }
        ],
        [
          CS.PreDecrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('--', true, expr(e));
          }
        ],
        [
          CS.PreIncrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('++', true, expr(e));
          }
        ],
        [
          CS.PostDecrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('--', false, expr(e));
          }
        ],
        [
          CS.PostIncrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('++', false, expr(e));
          }
        ],
        [
          CS.UnaryPlusOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('+', expr(e));
          }
        ],
        [
          CS.UnaryNegateOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('-', expr(e));
          }
        ],
        [
          CS.LogicalNotOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('!', expr(e));
          }
        ],
        [
          CS.BitNotOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('~', expr(e));
          }
        ],
        [
          CS.TypeofOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('typeof', expr(e));
          }
        ],
        [
          CS.DeleteOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('delete', expr(e));
          }
        ],
        [
          CS.Identifier,
          function () {
            return new JS.Identifier(this.data);
          }
        ],
        [
          CS.GenSym,
          function () {
            var memos, symbols;
            symbols = [];
            memos = [];
            return function () {
              var memo;
              if (in$(this, symbols)) {
                return memos[symbols.indexOf(this)];
              } else {
                symbols.push(this);
                memos.push(memo = genSym(this.data));
                return memo;
              }
            };
          }()
        ],
        [
          CS.Bool,
          CS.Int,
          CS.Float,
          CS.String,
          function () {
            return new JS.Literal(this.data);
          }
        ],
        [
          CS.Null,
          function () {
            return new JS.Literal(null);
          }
        ],
        [
          CS.Undefined,
          function () {
            return helpers.undef();
          }
        ],
        [
          CS.This,
          function () {
            return new JS.ThisExpression;
          }
        ],
        [
          CS.Super,
          function () {
            return memberAccess(new JS.ThisExpression, '_super');
          }
        ],
        [
          CS.JavaScript,
          function () {
            var js;
            js = new JS.CallExpression(new JS.Identifier('eval'), [new JS.Literal(this.data)]);
            js.verbatim = this.data;
            return js;
          }
        ],
        [
          CS.Volatile,
          CS.Computed,
          CS.Observes,
          function () {
            return new JS.EmptyStatement;
          }
        ]
      ];
      function Compiler() {
        var cache$2, ctor, ctors, handler, size$;
        this.rules = {};
        for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
          {
            cache$2 = defaultRules[i$];
            size$ = cache$2.length;
            ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
            handler = cache$2[size$ - 1];
          }
          for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
            ctor = ctors[i$1];
            this.addRule(ctor, handler);
          }
        }
      }
      Compiler.prototype.addRule = function (ctor, handler) {
        this.rules[ctor.prototype.className] = handler;
        return this;
      };
      Compiler.prototype.compile = function () {
        var defaultRule, generateSymbols, walk;
        walk = function (fn, inScope, ancestry, options) {
          var child, childName, children, jsNode, member;
          if ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Function, CS.BoundFunction, CS.ComputedProperty) : void 0) && this === ancestry[0].body)
            inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
          ancestry.unshift(this);
          children = {};
          for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
            childName = this.childNodes[i$];
            if (!(null != this[childName]))
              continue;
            children[childName] = in$(childName, this.listMembers) ? function (accum$) {
              for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
                member = this[childName][i$1];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                accum$.push(jsNode);
              }
              return accum$;
            }.call(this, []) : (child = this[childName], jsNode = walk.call(child, fn, inScope, ancestry), inScope = union(inScope, envEnrichments(child, inScope)), jsNode);
          }
          children.inScope = inScope;
          children.ancestry = ancestry;
          children.options = options;
          children.compile = function (node) {
            return walk.call(node, fn, inScope, ancestry);
          };
          ancestry.shift();
          jsNode = fn.call(this, children);
          jsNode.raw = this.raw;
          jsNode.line = this.line;
          jsNode.column = this.column - 1;
          jsNode.offset = this.offset;
          return jsNode;
        };
        generateSymbols = function () {
          var format, generatedSymbols, generateName;
          generatedSymbols = {};
          format = function (pre, counter) {
            var cache$2, div, mod;
            if (pre) {
              return '' + pre + '$' + (counter || '');
            } else if (counter < 26) {
              return String.fromCharCode(97 + counter);
            } else {
              cache$2 = divMod(counter, 26);
              div = cache$2[0];
              mod = cache$2[1];
              return format(pre, div - 1) + format(pre, mod);
            }
          };
          generateName = function (node, param$) {
            var cache$2, formatted, nsCounters, usedSymbols;
            {
              cache$2 = param$;
              usedSymbols = cache$2.usedSymbols;
              nsCounters = cache$2.nsCounters;
            }
            if (owns(generatedSymbols, node.uniqueId)) {
              return generatedSymbols[node.uniqueId];
            } else {
              nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
              while (in$(formatted = format(node.ns, nsCounters[node.ns]), usedSymbols)) {
                ++nsCounters[node.ns];
              }
              return generatedSymbols[node.uniqueId] = formatted;
            }
          };
          return generateMutatingWalker(function (state) {
            var alreadyDeclared, cache$2, declaredSymbols, declNames, decls, k, newNode, nsCounters, nsCounters_, params, undeclared, usedSymbols, v;
            state.declaredSymbols = union(state.declaredSymbols, map(declarationsNeeded(this), function (id) {
              return id.name;
            }));
            cache$2 = state;
            declaredSymbols = cache$2.declaredSymbols;
            usedSymbols = cache$2.usedSymbols;
            nsCounters = cache$2.nsCounters;
            newNode = this['instanceof'](JS.GenSym) ? (newNode = new JS.Identifier(generateName(this, state)), usedSymbols.push(newNode.name), newNode) : this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !this.generated ? (params = concatMap(this.params, collectIdentifiers), nsCounters_ = {}, function (accum$) {
              for (k in nsCounters) {
                if (!isOwn$(nsCounters, k))
                  continue;
                v = nsCounters[k];
                accum$.push(nsCounters_[k] = v);
              }
              return accum$;
            }.call(this, []), newNode = generateSymbols(this, {
              declaredSymbols: union(declaredSymbols, params),
              usedSymbols: union(usedSymbols, params),
              nsCounters: nsCounters_
            }), newNode.body = forceBlock(newNode.body), undeclared = map(declarationsNeededRecursive(this.body), function (id) {
              return id.name;
            }), undeclared = difference(undeclared, map(variableDeclarations(this.body), function (id) {
              return id.name;
            })), alreadyDeclared = union(declaredSymbols, concatMap(this.params, collectIdentifiers)), declNames = nub(difference(undeclared, alreadyDeclared)), decls = map(declNames, function (name) {
              return new JS.Identifier(name);
            }), decls.length > 0 ? newNode.body.body.unshift(makeVarDeclaration(decls)) : void 0, newNode) : generateSymbols(this, state);
            state.declaredSymbols = union(declaredSymbols, map(declarationsNeededRecursive(newNode), function (id) {
              return id.name;
            }));
            return newNode;
          });
        }();
        defaultRule = function () {
          throw new Error('compile: Non-exhaustive patterns in case: ' + this.className);
        };
        return function (ast, options) {
          var inScope, jsAST, rules;
          if (null == options)
            options = {};
          if (null != options.bare)
            options.bare;
          else
            options.bare = false;
          rules = this.rules;
          inScope = null != options.inScope ? options.inScope : [];
          jsAST = walk.call(ast, function () {
            return (null != rules[this.className] ? rules[this.className] : defaultRule).apply(this, arguments);
          }, inScope, [], options);
          return generateSymbols(jsAST, {
            declaredSymbols: inScope,
            usedSymbols: union(jsReserved.slice(), collectIdentifiers(jsAST)),
            nsCounters: {}
          });
        };
      }();
      return Compiler;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
  });
  require.define('/node_modules/lodash/index.js', function (module, exports, __dirname, __filename) {
    ;
    (function () {
      var undefined;
      var VERSION = '3.6.0';
      var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
      var HOT_COUNT = 150, HOT_SPAN = 16;
      var LAZY_DROP_WHILE_FLAG = 0, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
      var FUNC_ERROR_TEXT = 'Expected a function';
      var PLACEHOLDER = '__lodash_placeholder__';
      var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reComboMarks = /[\u0300-\u036f\ufe20-\ufe23]/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reHexPrefix = /^0[xX]/;
      var reHostCtor = /^\[object .+?Constructor\]$/;
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
      var reNoMatch = /($^)/;
      var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var reWords = function () {
          var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]', lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
          return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
        }();
      var whitespace = ' \t\x0B\f\xA0\uFEFF' + '\n\r\u2028\u2029' + '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000';
      var contextProps = [
          'Array',
          'ArrayBuffer',
          'Date',
          'Error',
          'Float32Array',
          'Float64Array',
          'Function',
          'Int8Array',
          'Int16Array',
          'Int32Array',
          'Math',
          'Number',
          'Object',
          'RegExp',
          'Set',
          'String',
          '_',
          'clearTimeout',
          'document',
          'isFinite',
          'parseInt',
          'setTimeout',
          'TypeError',
          'Uint8Array',
          'Uint8ClampedArray',
          'Uint16Array',
          'Uint32Array',
          'WeakMap',
          'window'
        ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
      var debounceOptions = {
          'leading': false,
          'maxWait': 0,
          'trailing': false
        };
      var deburredLetters = {
          '\xC0': 'A',
          '\xC1': 'A',
          '\xC2': 'A',
          '\xC3': 'A',
          '\xC4': 'A',
          '\xC5': 'A',
          '\xE0': 'a',
          '\xE1': 'a',
          '\xE2': 'a',
          '\xE3': 'a',
          '\xE4': 'a',
          '\xE5': 'a',
          '\xC7': 'C',
          '\xE7': 'c',
          '\xD0': 'D',
          '\xF0': 'd',
          '\xC8': 'E',
          '\xC9': 'E',
          '\xCA': 'E',
          '\xCB': 'E',
          '\xE8': 'e',
          '\xE9': 'e',
          '\xEA': 'e',
          '\xEB': 'e',
          '\xCC': 'I',
          '\xCD': 'I',
          '\xCE': 'I',
          '\xCF': 'I',
          '\xEC': 'i',
          '\xED': 'i',
          '\xEE': 'i',
          '\xEF': 'i',
          '\xD1': 'N',
          '\xF1': 'n',
          '\xD2': 'O',
          '\xD3': 'O',
          '\xD4': 'O',
          '\xD5': 'O',
          '\xD6': 'O',
          '\xD8': 'O',
          '\xF2': 'o',
          '\xF3': 'o',
          '\xF4': 'o',
          '\xF5': 'o',
          '\xF6': 'o',
          '\xF8': 'o',
          '\xD9': 'U',
          '\xDA': 'U',
          '\xDB': 'U',
          '\xDC': 'U',
          '\xF9': 'u',
          '\xFA': 'u',
          '\xFB': 'u',
          '\xFC': 'u',
          '\xDD': 'Y',
          '\xFD': 'y',
          '\xFF': 'y',
          '\xC6': 'Ae',
          '\xE6': 'ae',
          '\xDE': 'Th',
          '\xFE': 'th',
          '\xDF': 'ss'
        };
      var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '`': '&#96;'
        };
      var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'",
          '&#96;': '`'
        };
      var objectTypes = {
          'function': true,
          'object': true
        };
      var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsReflexive = value === value, othIsReflexive = other === other;
          if (value > other || !valIsReflexive || typeof value == 'undefined' && othIsReflexive) {
            return 1;
          }
          if (value < other || !othIsReflexive || typeof other == 'undefined' && valIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function baseIsFunction(value) {
        return typeof value == 'function' || false;
      }
      function baseToString(value) {
        if (typeof value == 'string') {
          return value;
        }
        return value == null ? '' : value + '';
      }
      function charAtCallback(string) {
        return string.charCodeAt(0);
      }
      function charsLeftIndex(string, chars) {
        var index = -1, length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {
        }
        return index;
      }
      function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {
        }
        return index;
      }
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            return result * (orders[index] ? 1 : -1);
          }
        }
        return object.index - other.index;
      }
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
      function isSpace(charCode) {
        return charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
      function sortedUniq(array, iteratee) {
        var seen, index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
      function trimmedLeftIndex(string) {
        var index = -1, length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {
        }
        return index;
      }
      function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {
        }
        return index;
      }
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
      function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayProto = Array.prototype, objectProto = Object.prototype, stringProto = String.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var getLength = baseProperty('length');
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, push = arrayProto.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = isNative(Set = context.Set) && Set, setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array, WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = function () {
            try {
              var func = isNative(func = context.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
            } catch (e) {
            }
            return result;
          }();
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsFinite = context.isFinite, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeNow = isNative(nativeNow = Date.now) && nativeNow, nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap;
        var realNames = {};
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function (x) {
          support.funcDecomp = /\bthis\b/.test(function () {
            return this;
          });
          support.funcNames = typeof Function.name == 'string';
          try {
            support.dom = document.createDocumentFragment().nodeType === 11;
          } catch (e) {
            support.dom = false;
          }
          try {
            support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
          } catch (e) {
            support.nonEnumArgs = true;
          }
        }(0, 0));
        lodash.templateSettings = {
          'escape': reEscape,
          'evaluate': reEvaluate,
          'interpolate': reInterpolate,
          'variable': '',
          'imports': { '_': lodash }
        };
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = null;
          this.__dir__ = 1;
          this.__dropCount__ = 0;
          this.__filtered__ = false;
          this.__iteratees__ = null;
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = null;
        }
        function lazyClone() {
          var actions = this.__actions__, iteratees = this.__iteratees__, views = this.__views__, result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = actions ? arrayCopy(actions) : null;
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = views ? arrayCopy(views) : null;
          return result;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
        function lazyValue() {
          var array = this.__wrapped__.value();
          if (!isArray(array)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var dir = this.__dir__, isRight = dir < 0, view = getView(0, array.length, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, takeCount = nativeMin(length, this.__takeCount__), iteratees = this.__iteratees__, iterLength = iteratees ? iteratees.length : 0, resIndex = 0, result = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type;
                if (type == LAZY_DROP_WHILE_FLAG) {
                  if (data.done && (isRight ? index > data.index : index < data.index)) {
                    data.count = 0;
                    data.done = false;
                  }
                  data.index = index;
                  if (!data.done) {
                    var limit = data.limit;
                    if (!(data.done = limit > -1 ? data.count++ >= limit : !iteratee(value))) {
                      continue outer;
                    }
                  }
                } else {
                  var computed = iteratee(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
              }
              result[resIndex++] = value;
            }
          return result;
        }
        function MapCache() {
          this.__data__ = {};
        }
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
        function SetCache(values) {
          var length = values ? values.length : 0;
          this.data = {
            'hash': nativeCreate(null),
            'set': new Set
          };
          while (length--) {
            this.push(values[length]);
          }
        }
        function cacheIndexOf(cache, value) {
          var data = cache.data, result = typeof value == 'string' || isObject(value) ? data.set.has(value) : data.hash[value];
          return result ? 0 : -1;
        }
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
        function arrayCopy(source, array) {
          var index = -1, length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = array.length, resIndex = -1, result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = array.length, result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayMax(array) {
          var index = -1, length = array.length, result = NEGATIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value > result) {
              result = value;
            }
          }
          return result;
        }
        function arrayMin(array) {
          var index = -1, length = array.length, result = POSITIVE_INFINITY;
          while (++index < length) {
            var value = array[index];
            if (value < result) {
              result = value;
            }
          }
          return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1, length = array.length;
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function arraySum(array) {
          var length = array.length, result = 0;
          while (length--) {
            result += +array[length] || 0;
          }
          return result;
        }
        function assignDefaults(objectValue, sourceValue) {
          return typeof objectValue == 'undefined' ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
        }
        function baseAssign(object, source, customizer) {
          var props = keys(source);
          if (!customizer) {
            return baseCopy(source, object, props);
          }
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
            if ((result === result ? result !== value : value === value) || typeof value == 'undefined' && !(key in object)) {
              object[key] = result;
            }
          }
          return object;
        }
        function baseAt(collection, props) {
          var index = -1, length = collection.length, isArr = isLength(length), propsLength = props.length, result = Array(propsLength);
          while (++index < propsLength) {
            var key = props[index];
            if (isArr) {
              key = parseFloat(key);
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = collection[key];
            }
          }
          return result;
        }
        function baseCopy(source, object, props) {
          if (!props) {
            props = object;
            object = {};
          }
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return typeof thisArg == 'undefined' ? func : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return typeof thisArg == 'undefined' ? baseProperty(func + '') : baseMatchesProperty(func + '', thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (typeof result != 'undefined') {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value), isFunc = tag == funcTag;
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseCopy(value, result, keys(value));
              }
            } else {
              return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          stackA.push(value);
          stackB.push(result);
          (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
        var baseCreate = function () {
            function Object() {
            }
            return function (prototype) {
              if (isObject(prototype)) {
                Object.prototype = prototype;
                var result = new Object;
                Object.prototype = null;
              }
              return result || context.Object();
            };
          }();
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function () {
            func.apply(undefined, args);
          }, wait);
        }
        function baseDifference(array, values) {
          var length = array ? array.length : 0, result = [];
          if (!length) {
            return result;
          }
          var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= 200 ? createCache(values) : null, valuesLength = values.length;
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer:
            while (++index < length) {
              var value = array[index];
              if (isCommon && value === value) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values[valuesIndex] === value) {
                    continue outer;
                  }
                }
                result.push(value);
              } else if (indexOf(values, value, 0) < 0) {
                result.push(value);
              }
            }
          return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function (value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = start == null ? 0 : +start || 0;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = typeof end == 'undefined' || end > length ? length : +end || 0;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end >>> 0;
          start >>>= 0;
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function (value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
        function baseFlatten(array, isDeep, isStrict) {
          var index = -1, length = array.length, resIndex = -1, result = [];
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
              if (isDeep) {
                value = baseFlatten(value, isDeep, isStrict);
              }
              var valIndex = -1, valLength = value.length;
              result.length += valLength;
              while (++valIndex < valLength) {
                result[++resIndex] = value[valIndex];
              }
            } else if (!isStrict) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
          var index = -1, length = props.length, resIndex = -1, result = [];
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return value !== 0 || 1 / value == 1 / other;
          }
          var valType = typeof value, othType = typeof other;
          if (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object' || value == null || other == null) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag || isLoose && objTag == funcTag, othIsObj = othTag == objectTag || isLoose && othTag == funcTag, isSameTag = objTag == othTag;
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (isLoose) {
            if (!isSameTag && !(objIsObj && othIsObj)) {
              return false;
            }
          } else {
            var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
            if (valWrapped || othWrapped) {
              return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
            if (!isSameTag) {
              return false;
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          stackA.push(object);
          stackB.push(other);
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
          stackA.pop();
          stackB.pop();
          return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
          var index = -1, length = props.length, noCustomizer = !customizer;
          while (++index < length) {
            if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !(props[index] in object)) {
              return false;
            }
          }
          index = -1;
          while (++index < length) {
            var key = props[index], objValue = object[key], srcValue = values[index];
            if (noCustomizer && strictCompareFlags[index]) {
              var result = typeof objValue != 'undefined' || key in object;
            } else {
              result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (typeof result == 'undefined') {
                result = baseIsEqual(srcValue, objValue, customizer, true);
              }
            }
            if (!result) {
              return false;
            }
          }
          return true;
        }
        function baseMap(collection, iteratee) {
          var result = [];
          baseEach(collection, function (value, key, collection) {
            result.push(iteratee(value, key, collection));
          });
          return result;
        }
        function baseMatches(source) {
          var props = keys(source), length = props.length;
          if (!length) {
            return constant(true);
          }
          if (length == 1) {
            var key = props[0], value = source[key];
            if (isStrictComparable(value)) {
              return function (object) {
                return object != null && object[key] === value && (typeof value != 'undefined' || key in toObject(object));
              };
            }
          }
          var values = Array(length), strictCompareFlags = Array(length);
          while (length--) {
            value = source[props[length]];
            values[length] = value;
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return function (object) {
            return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
          };
        }
        function baseMatchesProperty(key, value) {
          if (isStrictComparable(value)) {
            return function (object) {
              return object != null && object[key] === value && (typeof value != 'undefined' || key in toObject(object));
            };
          }
          return function (object) {
            return object != null && baseIsEqual(value, object[key], null, true);
          };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
          (isSrcArr ? arrayEach : baseForOwn)(source, function (srcValue, key, source) {
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == 'undefined';
            if (isCommon) {
              result = srcValue;
            }
            if ((isSrcArr || typeof result != 'undefined') && (isCommon || (result === result ? result !== value : value === value))) {
              object[key] = result;
            }
          });
          return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length, srcValue = source[key];
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == 'undefined';
          if (isCommon) {
            result = srcValue;
            if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value) ? value : value && value.length ? arrayCopy(value) : [];
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
            } else {
              isCommon = false;
            }
          }
          stackA.push(srcValue);
          stackB.push(result);
          if (isCommon) {
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? result !== value : value === value) {
            object[key] = result;
          }
        }
        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function (value, index, collection) {
            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          start = start == null ? 0 : +start || 0;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = typeof end == 'undefined' || end > length ? length : +end || 0;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
        function baseSome(collection, predicate) {
          var result;
          baseEach(collection, function (value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
        function baseSortByOrder(collection, props, orders) {
          var index = -1, length = collection.length, result = isLength(length) ? Array(length) : [];
          baseEach(collection, function (value) {
            var length = props.length, criteria = Array(length);
            while (length--) {
              criteria[length] = value == null ? undefined : value[props[length]];
            }
            result[++index] = {
              'criteria': criteria,
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, function (object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function (value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
        function baseUniq(array, iteratee) {
          var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= 200, seen = isLarge ? createCache() : null, result = [];
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
              if (isCommon && value === value) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              } else if (indexOf(seen, computed, 0) < 0) {
                if (iteratee || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
          return result;
        }
        function baseValues(object, props) {
          var index = -1, length = props.length, result = Array(length);
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1, length = actions.length;
          while (++index < length) {
            var args = [result], action = actions[index];
            push.apply(args, action.args);
            result = action.func.apply(action.thisArg, args);
          }
          return result;
        }
        function binaryIndex(array, value, retHighest) {
          var low = 0, high = array ? array.length : low;
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (retHighest ? computed <= value : computed < value) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
          var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsUndef = typeof value == 'undefined';
          while (low < high) {
            var mid = floor((low + high) / 2), computed = iteratee(array[mid]), isReflexive = computed === computed;
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || typeof computed != 'undefined');
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (typeof thisArg == 'undefined') {
            return func;
          }
          switch (argCount) {
          case 1:
            return function (value) {
              return func.call(thisArg, value);
            };
          case 3:
            return function (value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
          case 4:
            return function (accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
          case 5:
            return function (value, other, key, object, source) {
              return func.call(thisArg, value, other, key, object, source);
            };
          }
          return function () {
            return func.apply(thisArg, arguments);
          };
        }
        function bufferClone(buffer) {
          return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
          bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function (buffer) {
            var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
            if (floatLength) {
              var view = new Float64Array(result, 0, floatLength);
              view.set(new Float64Array(buffer, 0, floatLength));
            }
            if (byteLength != offset) {
              view = new Uint8Array(result, offset);
              view.set(new Uint8Array(buffer, offset));
            }
            return result;
          };
        }
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(argsLength + leftLength);
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var pad = argsIndex;
          while (++rightIndex < rightLength) {
            result[pad + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[pad + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
        function createAggregator(setter, initializer) {
          return function (collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
            if (isArray(collection)) {
              var index = -1, length = collection.length;
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function (value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
        function createAssigner(assigner) {
          return function () {
            var args = arguments, length = args.length, object = args[0];
            if (length < 2 || object == null) {
              return object;
            }
            var customizer = args[length - 2], thisArg = args[length - 1], guard = args[3];
            if (length > 3 && typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = length > 2 && typeof thisArg == 'function' ? thisArg : null;
              length -= customizer ? 1 : 0;
            }
            if (guard && isIterateeCall(args[1], args[2], guard)) {
              customizer = length == 3 ? null : customizer;
              length = 2;
            }
            var index = 0;
            while (++index < length) {
              var source = args[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          };
        }
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee) {
            var length = collection ? collection.length : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1, iterable = toObject(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
            while (fromRight ? index-- : ++index < length) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function (values) {
            return new SetCache(values);
          };
        function createCompounder(callback) {
          return function (string) {
            var index = -1, array = words(deburr(string)), length = array.length, result = '';
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
        function createCtorWrapper(Ctor) {
          return function () {
            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, arguments);
            return isObject(result) ? result : thisBinding;
          };
        }
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = null;
            }
            var result = createWrapper(func, flag, null, null, null, null, null, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
        function createExtremum(arrayFunc, isMin) {
          return function (collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var func = getCallback(), noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
              noIteratee = false;
              iteratee = func(iteratee, thisArg, 3);
            }
            if (noIteratee) {
              var isArr = isArray(collection);
              if (!isArr && isString(collection)) {
                iteratee = charAtCallback;
              } else {
                return arrayFunc(isArr ? collection : toIterable(collection));
              }
            }
            return extremumBy(collection, iteratee, isMin);
          };
        }
        function createFind(eachFunc, fromRight) {
          return function (collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
        function createFindIndex(fromRight) {
          return function (array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
        function createFindKey(objectFunc) {
          return function (object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
        function createFlow(fromRight) {
          return function () {
            var length = arguments.length;
            if (!length) {
              return function () {
                return arguments[0];
              };
            }
            var wrapper, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length);
            while (fromRight ? index-- : ++index < length) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var funcName = wrapper ? '' : getFuncName(func);
              wrapper = funcName == 'wrapper' ? new LodashWrapper([]) : wrapper;
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
              funcName = getFuncName(func);
              var data = funcName == 'wrapper' ? getData(func) : null;
              if (data && isLaziable(data[0])) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function () {
              var args = arguments;
              if (wrapper && args.length == 1 && isArray(args[0])) {
                return wrapper.plant(args[0]).value();
              }
              var index = 0, result = funcs[index].apply(this, args);
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
        function createForEach(arrayFunc, eachFunc) {
          return function (collection, iteratee, thisArg) {
            return typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
        function createForIn(objectFunc) {
          return function (object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
        function createForOwn(objectFunc) {
          return function (object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
        function createPadDir(fromRight) {
          return function (string, length, chars) {
            string = baseToString(string);
            return string && (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
        function createPartial(flag) {
          var partialFunc = restParam(function (func, partials) {
              var holders = replaceHolders(partials, partialFunc.placeholder);
              return createWrapper(func, flag, null, partials, holders);
            });
          return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
          return function (collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG;
          var Ctor = !isBindKey && createCtorWrapper(func), key = func;
          function wrapper() {
            var length = arguments.length, index = length, args = Array(length);
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : null, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : null, newHoldersRight = isCurry ? null : argsHolders, newPartials = isCurry ? args : null, newPartialsRight = isCurry ? null : args;
                bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newsHolders,
                    newPartialsRight,
                    newHoldersRight,
                    newArgPos,
                    ary,
                    newArity
                  ], result = createHybridWrapper.apply(undefined, newData);
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this;
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor || createCtorWrapper(func) : func;
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : chars + '';
          return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createSortedIndex(retHighest) {
          return function (array, value, iteratee, thisArg) {
            var func = getCallback(iteratee);
            return func === baseCallback && iteratee == null ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
          };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = null;
          }
          length -= holders ? holders.length : 0;
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = null;
          }
          var data = isBindKey ? null : getData(func), newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary,
              arity
            ];
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1, arrLength = array.length, othLength = other.length, result = true;
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          while (result && ++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            result = undefined;
            if (customizer) {
              result = isLoose ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
            }
            if (typeof result == 'undefined') {
              if (isLoose) {
                var othIndex = othLength;
                while (othIndex--) {
                  othValue = other[othIndex];
                  result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                  if (result) {
                    break;
                  }
                }
              } else {
                result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              }
            }
          }
          return !!result;
        }
        function equalByTag(object, other, tag) {
          switch (tag) {
          case boolTag:
          case dateTag:
            return +object == +other;
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case numberTag:
            return object != +object ? other != +other : object == 0 ? 1 / object == 1 / other : object == +other;
          case regexpTag:
          case stringTag:
            return object == other + '';
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var skipCtor = isLoose, index = -1;
          while (++index < objLength) {
            var key = objProps[index], result = isLoose ? key in other : hasOwnProperty.call(other, key);
            if (result) {
              var objValue = object[key], othValue = other[key];
              result = undefined;
              if (customizer) {
                result = isLoose ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
              }
              if (typeof result == 'undefined') {
                result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
              }
            }
            if (!result) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
        function extremumBy(collection, iteratee, isMin) {
          var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY, computed = exValue, result = computed;
          baseEach(collection, function (value, index, collection) {
            var current = iteratee(value, index, collection);
            if ((isMin ? current < computed : current > computed) || current === exValue && current === result) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };
        var getFuncName = function () {
            if (!support.funcNames) {
              return constant('');
            }
            if (constant.name == 'constant') {
              return baseProperty('name');
            }
            return function (func) {
              var result = func.name, array = realNames[result], length = array ? array.length : 0;
              while (length--) {
                var data = array[length], otherFunc = data.func;
                if (otherFunc == null || otherFunc == func) {
                  return data.name;
                }
              }
              return result;
            };
          }();
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms ? transforms.length : 0;
          while (++index < length) {
            var data = transforms[index], size = data.size;
            switch (data.type) {
            case 'drop':
              start += size;
              break;
            case 'dropRight':
              end -= size;
              break;
            case 'take':
              end = nativeMin(end, start + size);
              break;
            case 'takeRight':
              start = nativeMax(start, end - size);
              break;
            }
          }
          return {
            'start': start,
            'end': end
          };
        }
        function initCloneArray(array) {
          var length = array.length, result = new array.constructor(length);
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
          case arrayBufferTag:
            return bufferClone(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            var buffer = object.buffer;
            return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            var result = new Ctor(object.source, reFlags.exec(object));
            result.lastIndex = object.lastIndex;
          }
          return result;
        }
        function isIndex(value, length) {
          value = +value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number') {
            var length = object.length, prereq = isLength(length) && isIndex(index, length);
          } else {
            prereq = type == 'string' && index in object;
          }
          if (prereq) {
            var other = object[index];
            return value === value ? value === other : other !== other;
          }
          return false;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func);
          return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
        }
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
          return value === value && (value === 0 ? 1 / value > 0 : !isObject(value));
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
          var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function pickByArray(object, props) {
          object = toObject(object);
          var index = -1, length = props.length, result = {};
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function (value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
        var setData = function () {
            var count = 0, lastCalled = 0;
            return function (key, value) {
              var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return key;
                }
              } else {
                count = 0;
              }
              return baseSetData(key, value);
            };
          }();
        function shimIsPlainObject(value) {
          var Ctor, support = lodash.support;
          if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) {
            return false;
          }
          var result;
          baseForIn(value, function (subValue, key) {
            result = key;
          });
          return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
          var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, support = lodash.support;
          var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));
          var index = -1, result = [];
          while (++index < propsLength) {
            var key = props[index];
            if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isLength(value.length)) {
            return values(value);
          }
          return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
          return isObject(value) ? value : Object(value);
        }
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(+size || 1, 1);
          }
          var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(ceil(length / size));
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, index += size);
          }
          return result;
        }
        function compact(array) {
          var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
        var difference = restParam(function (array, values) {
            return isArray(array) || isArguments(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
          });
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
          return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
          return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
          return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value), other = array[index];
            if (value === value ? value === other : other !== other) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
          return dropRight(array, 1);
        }
        function intersection() {
          var args = [], argsIndex = -1, argsLength = arguments.length, caches = [], indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf;
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
            if (isArray(value) || isArguments(value)) {
              args.push(value);
              caches.push(isCommon && value.length >= 120 ? createCache(argsIndex && value) : null);
            }
          }
          argsLength = args.length;
          var array = args[0], index = -1, length = array ? array.length : 0, result = [], seen = caches[0];
          outer:
            while (++index < length) {
              value = array[index];
              if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                argsIndex = argsLength;
                while (--argsIndex) {
                  var cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(value);
                }
                result.push(value);
              }
            }
          return result;
        }
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? value === other : other !== other) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function pull() {
          var args = arguments, array = args[0];
          if (!(array && array.length)) {
            return array;
          }
          var index = 0, indexOf = getIndexOf(), length = args.length;
          while (++index < length) {
            var fromIndex = 0, value = args[index];
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        var pullAt = restParam(function (array, indexes) {
            array || (array = []);
            indexes = baseFlatten(indexes);
            var length = indexes.length, result = baseAt(array, indexes);
            indexes.sort(baseCompareAscending);
            while (length--) {
              var index = parseFloat(indexes[length]);
              if (index != previous && isIndex(index)) {
                var previous = index;
                splice.call(array, index, 1);
              }
            }
            return result;
          });
        function remove(array, predicate, thisArg) {
          var index = -1, length = array ? array.length : 0, result = [];
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              splice.call(array, index--, 1);
              length--;
            }
          }
          return result;
        }
        function rest(array) {
          return drop(array, 1);
        }
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
          return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
          return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function (arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
          });
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
            isSorted = false;
          }
          var func = getCallback();
          if (!(func === baseCallback && iteratee == null)) {
            iteratee = func(iteratee, thisArg, 3);
          }
          return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
          var index = -1, length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0, result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
        var without = restParam(function (array, values) {
            return isArray(array) || isArguments(array) ? baseDifference(array, values) : [];
          });
        function xor() {
          var index = -1, length = arguments.length;
          while (++index < length) {
            var array = arguments[index];
            if (isArray(array) || isArguments(array)) {
              var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
          var index = -1, length = props ? props.length : 0, result = {};
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
          var result, parent = this;
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            if (this.__actions__.length) {
              value = new LazyWrapper(this);
            }
            return new LodashWrapper(value.reverse(), this.__chain__);
          }
          return this.thru(function (value) {
            return value.reverse();
          });
        }
        function wrapperToString() {
          return this.value() + '';
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function (collection, props) {
            var length = collection ? collection.length : 0;
            if (isLength(length)) {
              collection = toIterable(collection);
            }
            return baseAt(collection, baseFlatten(props));
          });
        var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
          });
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = null;
          }
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              result[key] = [value];
            }
          });
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? collection.length : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (!length) {
            return false;
          }
          if (typeof fromIndex != 'number' || guard && isIterateeCall(target, fromIndex, guard)) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
          }
          return typeof collection == 'string' || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
        }
        var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
          });
        var invoke = restParam(function (collection, methodName, args) {
            var index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = isLength(length) ? Array(length) : [];
            baseEach(collection, function (value) {
              var func = isFunc ? methodName : value != null && value[methodName];
              result[++index] = func ? func.apply(value, args) : undefined;
            });
            return result;
          });
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
        var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () {
            return [
              [],
              []
            ];
          });
        function pluck(collection, key) {
          return map(collection, baseProperty(key));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function (value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(n < 0 ? 0 : +n || 0, result.length);
          return result;
        }
        function shuffle(collection) {
          collection = toIterable(collection);
          var index = -1, length = collection.length, result = Array(length);
          while (++index < length) {
            var rand = baseRandom(0, index);
            if (index != rand) {
              result[index] = result[rand];
            }
            result[rand] = collection[index];
          }
          return result;
        }
        function size(collection) {
          var length = collection ? collection.length : 0;
          return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = null;
          }
          if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          var index = -1, length = collection.length, result = isLength(length) ? Array(length) : [];
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          baseEach(collection, function (value, key, collection) {
            result[++index] = {
              'criteria': iteratee(value, key, collection),
              'index': index,
              'value': value
            };
          });
          return baseSortBy(result, compareAscending);
        }
        function sortByAll() {
          var args = arguments, collection = args[0], guard = args[3], index = 0, length = args.length - 1;
          if (collection == null) {
            return [];
          }
          var props = Array(length);
          while (index < length) {
            props[index] = args[++index];
          }
          if (guard && isIterateeCall(args[1], args[2], guard)) {
            props = args[1];
          }
          return baseSortByOrder(collection, baseFlatten(props), []);
        }
        function sortByOrder(collection, props, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(props, orders, guard)) {
            orders = null;
          }
          if (!isArray(props)) {
            props = props == null ? [] : [props];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, props, orders);
        }
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function () {
            return new Date().getTime();
          };
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = null;
          }
          n = func && n == null ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function () {
            if (--n > 0) {
              result = func.apply(this, arguments);
            } else {
              func = null;
            }
            return result;
          };
        }
        var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bind.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
          });
        var bindAll = restParam(function (object, methodNames) {
            methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
            var index = -1, length = methodNames.length;
            while (++index < length) {
              var key = methodNames[index];
              object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
          });
        var bindKey = restParam(function (object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bindKey.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
          });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
          var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : +wait || 0;
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
          function maxDelayed() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || maxWait !== wait) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          }
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              } else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            } else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
        var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
          });
        var delay = restParam(function (func, wait, args) {
            return baseDelay(func, wait, args);
          });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
          if (typeof func != 'function' || resolver && typeof resolver != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function () {
            var args = arguments, cache = memoized.cache, key = resolver ? resolver.apply(this, args) : args[0];
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function () {
            return !predicate.apply(this, arguments);
          };
        }
        function once(func) {
          return before(func, 2);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function (func, indexes) {
            return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
          });
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(typeof start == 'undefined' ? func.length - 1 : +start || 0, 0);
          return function () {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
            case 0:
              return func.call(this, rest);
            case 1:
              return func.call(this, args[0], rest);
            case 2:
              return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function (array) {
            return func.apply(this, array);
          };
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          debounceOptions.leading = leading;
          debounceOptions.maxWait = +wait;
          debounceOptions.trailing = trailing;
          return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          } else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
          return baseClone(value, true, customizer);
        }
        function isArguments(value) {
          var length = isObjectLike(value) ? value.length : undefined;
          return isLength(length) && objToString.call(value) == argsTag;
        }
        var isArray = nativeIsArray || function (value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
          };
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag;
        }
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf('Element') > -1;
        }
        if (!support.dom) {
          isElement = function (value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
          };
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          var length = value.length;
          if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
            return !length;
          }
          return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
            return value === other;
          }
          var result = customizer ? customizer(value, other) : undefined;
          return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        var isFinite = nativeNumIsFinite || function (value) {
            return typeof value == 'number' && nativeIsFinite(value);
          };
        var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function (value) {
            return objToString.call(value) == funcTag;
          };
        function isObject(value) {
          var type = typeof value;
          return type == 'function' || !!value && type == 'object';
        }
        function isMatch(object, source, customizer, thisArg) {
          var props = keys(source), length = props.length;
          if (!length) {
            return true;
          }
          if (object == null) {
            return false;
          }
          customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
          if (!customizer && length == 1) {
            var key = props[0], value = source[key];
            if (isStrictComparable(value)) {
              return value === object[key] && (typeof value != 'undefined' || key in toObject(object));
            }
          }
          var values = Array(length), strictCompareFlags = Array(length);
          while (length--) {
            value = values[length] = source[props[length]];
            strictCompareFlags[length] = isStrictComparable(value);
          }
          return baseIsMatch(toObject(object), props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (objToString.call(value) == funcTag) {
            return reNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && reHostCtor.test(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNumber(value) {
          return typeof value == 'number' || isObjectLike(value) && objToString.call(value) == numberTag;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
            if (!(value && objToString.call(value) == objectTag)) {
              return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
          };
        function isRegExp(value) {
          return isObjectLike(value) && objToString.call(value) == regexpTag || false;
        }
        function isString(value) {
          return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
        }
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
        function toArray(value) {
          var length = value ? value.length : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return arrayCopy(value);
        }
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(baseAssign);
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = null;
          }
          return properties ? baseCopy(properties, result, keys(properties)) : result;
        }
        var defaults = restParam(function (args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(assignDefaults);
            return assign.apply(undefined, args);
          });
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = null;
          }
          var index = -1, props = keys(object), length = props.length, result = {};
          while (++index < length) {
            var key = props[index], value = object[key];
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            } else {
              result[value] = key;
            }
          }
          return result;
        }
        var keys = !nativeKeys ? shimKeys : function (object) {
            if (object) {
              var Ctor = object.constructor, length = object.length;
            }
            if (typeof Ctor == 'function' && Ctor.prototype === object || typeof object != 'function' && (length && isLength(length))) {
              return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
          };
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length;
          length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
          var Ctor = object.constructor, index = -1, isProto = typeof Ctor == 'function' && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
          while (++index < length) {
            result[index] = index + '';
          }
          for (var key in object) {
            if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
        function mapValues(object, iteratee, thisArg) {
          var result = {};
          iteratee = getCallback(iteratee, thisArg, 3);
          baseForOwn(object, function (value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
        var merge = createAssigner(baseMerge);
        var omit = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            if (typeof props[0] != 'function') {
              var props = arrayMap(baseFlatten(props), String);
              return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
              return !predicate(value, key, object);
            });
          });
        function pairs(object) {
          var index = -1, props = keys(object), length = props.length, result = Array(length);
          while (++index < length) {
            var key = props[index];
            result[index] = [
              key,
              object[key]
            ];
          }
          return result;
        }
        var pick = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
          });
        function result(object, key, defaultValue) {
          var value = object == null ? undefined : object[key];
          if (typeof value == 'undefined') {
            value = defaultValue;
          }
          return isFunction(value) ? value.call(object) : value;
        }
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
        function values(object) {
          return baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
          start = +start || 0;
          if (typeof end === 'undefined') {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= start && value < end;
        }
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = null;
          }
          var noMin = min == null, noMax = max == null;
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            } else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max);
          }
          return baseRandom(min, max);
        }
        var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
          });
        function capitalize(string) {
          string = baseToString(string);
          return string && string.charAt(0).toUpperCase() + string.slice(1);
        }
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMarks, '');
        }
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = target + '';
          var length = string.length;
          position = typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
          string = baseToString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = baseToString(string);
          return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, '\\$&') : string;
        }
        var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2, leftLength = floor(mid), rightLength = ceil(mid);
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
          if (guard && isIterateeCall(string, radix, guard)) {
            radix = 0;
          }
          return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + '08') != 8) {
          parseInt = function (string, radix, guard) {
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
          };
        }
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          do {
            if (n % 2) {
              result += string;
            }
            n = floor(n / 2);
            string += string;
          } while (n);
          return result;
        }
        var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });
        var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
          });
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
          return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
          var settings = lodash.templateSettings;
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = null;
          }
          string = baseToString(string);
          options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
          var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
          var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
          string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
          source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
          var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = chars + '';
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, chars + ''));
        }
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, chars + '') + 1);
        }
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = null;
          }
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? +options.length || 0 : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, newEnd, substring = string.slice(0, end);
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
        function unescape(string) {
          string = baseToString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = null;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function (func, args) {
            try {
              return func.apply(undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = null;
          }
          return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
          return function () {
            return value;
          };
        }
        function identity(value) {
          return value;
        }
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
        function matchesProperty(key, value) {
          return baseMatchesProperty(key + '', baseClone(value, true));
        }
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index], func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function (func) {
                return function () {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  var args = [this.value()];
                  push.apply(args, arguments);
                  return func.apply(object, args);
                };
              }(func);
            }
          }
          return object;
        }
        function noConflict() {
          context._ = oldDash;
          return this;
        }
        function noop() {
        }
        function property(key) {
          return baseProperty(key + '');
        }
        function propertyOf(object) {
          return function (key) {
            return object == null ? undefined : object[key];
          };
        }
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = null;
          }
          start = +start || 0;
          step = step == null ? 1 : +step || 0;
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          var index = -1, length = nativeMax(ceil((end - start) / (step || 1)), 0), result = Array(length);
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
        function times(n, iteratee, thisArg) {
          n = +n;
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
        function add(augend, addend) {
          return augend + addend;
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = null;
          }
          var func = getCallback(), noIteratee = iteratee == null;
          if (!(func === baseCallback && noIteratee)) {
            noIteratee = false;
            iteratee = func(iteratee, thisArg, 3);
          }
          return noIteratee ? arraySum(isArray(collection) ? collection : toIterable(collection)) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, function () {
          var source = {};
          baseForOwn(lodash, function (func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }(), false);
        lodash.sample = sample;
        lodash.prototype.sample = function (n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function (value) {
            return sample(value, n);
          });
        };
        lodash.VERSION = VERSION;
        arrayEach([
          'bind',
          'bindKey',
          'curry',
          'curryRight',
          'partial',
          'partialRight'
        ], function (methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach([
          'dropWhile',
          'filter',
          'map',
          'takeWhile'
        ], function (methodName, type) {
          var isFilter = type != LAZY_MAP_FLAG, isDropWhile = type == LAZY_DROP_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
            var filtered = this.__filtered__, result = filtered && isDropWhile ? new LazyWrapper(this) : this.clone(), iteratees = result.__iteratees__ || (result.__iteratees__ = []);
            iteratees.push({
              'done': false,
              'count': 0,
              'index': 0,
              'iteratee': getCallback(iteratee, thisArg, 1),
              'limit': -1,
              'type': type
            });
            result.__filtered__ = filtered || isFilter;
            return result;
          };
        });
        arrayEach([
          'drop',
          'take'
        ], function (methodName, index) {
          var whileName = methodName + 'While';
          LazyWrapper.prototype[methodName] = function (n) {
            var filtered = this.__filtered__, result = filtered && !index ? this.dropWhile() : this.clone();
            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
            if (filtered) {
              if (index) {
                result.__takeCount__ = nativeMin(result.__takeCount__, n);
              } else {
                last(result.__iteratees__).limit = n;
              }
            } else {
              var views = result.__views__ || (result.__views__ = []);
              views.push({
                'size': n,
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
          LazyWrapper.prototype[methodName + 'Right'] = function (n) {
            return this.reverse()[methodName](n).reverse();
          };
          LazyWrapper.prototype[methodName + 'RightWhile'] = function (predicate, thisArg) {
            return this.reverse()[whileName](predicate, thisArg).reverse();
          };
        });
        arrayEach([
          'first',
          'last'
        ], function (methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach([
          'initial',
          'rest'
        ], function (methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
          LazyWrapper.prototype[methodName] = function () {
            return this[dropName](1);
          };
        });
        arrayEach([
          'pluck',
          'where'
        ], function (methodName, index) {
          var operationName = index ? 'filter' : 'map', createCallback = index ? baseMatches : baseProperty;
          LazyWrapper.prototype[methodName] = function (value) {
            return this[operationName](createCallback(value));
          };
        });
        LazyWrapper.prototype.compact = function () {
          return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function (predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function (value) {
            return !predicate(value);
          });
        };
        LazyWrapper.prototype.slice = function (start, end) {
          start = start == null ? 0 : +start || 0;
          var result = start < 0 ? this.takeRight(-start) : this.drop(start);
          if (typeof end != 'undefined') {
            end = +end || 0;
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
        LazyWrapper.prototype.toArray = function () {
          return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash[methodName];
          if (!lodashFunc) {
            return;
          }
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName);
          lodash.prototype[methodName] = function () {
            var args = arguments, length = args.length, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              isLazy = useLazy = false;
            }
            var onlyLazy = isLazy && !isHybrid;
            if (retUnwrapped && !chainAll) {
              return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
            }
            var interceptor = function (value) {
              var otherArgs = [value];
              push.apply(otherArgs, args);
              return lodashFunc.apply(lodash, otherArgs);
            };
            if (useLazy) {
              var wrapper = onlyLazy ? value : new LazyWrapper(this), result = func.apply(wrapper, args);
              if (!retUnwrapped && (isHybrid || result.__actions__)) {
                var actions = result.__actions__ || (result.__actions__ = []);
                actions.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': lodash
                });
              }
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
        arrayEach([
          'concat',
          'join',
          'pop',
          'push',
          'replace',
          'shift',
          'sort',
          'splice',
          'split',
          'unshift'
        ], function (methodName) {
          var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
          lodash.prototype[methodName] = function () {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function (value) {
              return func.apply(value, args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name, names = realNames[key] || (realNames[key] = []);
            names.push({
              'name': methodName,
              'func': lodashFunc
            });
          }
        });
        realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{
            'name': 'wrapper',
            'func': null
          }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
      }
      var _ = runInContext();
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define(function () {
          return _;
        });
      } else if (freeExports && freeModule) {
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        } else {
          freeExports._ = _;
        }
      } else {
        root._ = _;
      }
    }.call(this));
  });
  require.define('/src/js-nodes.coffee', function (module, exports, __dirname, __filename) {
    var ArrayExpression, AssignmentExpression, BinaryExpression, BlockStatement, CallExpression, createNode, ctor, difference, exports, FunctionDeclaration, FunctionExpression, GenSym, handleLists, handlePrimitives, Identifier, isStatement, Literal, LogicalExpression, MemberExpression, NewExpression, node, nodeData, Nodes, ObjectExpression, params, Program, SequenceExpression, SwitchCase, SwitchStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclaration;
    difference = require('/src/functional-helpers.coffee', module).difference;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    createNode = function (type, props) {
      return function (super$) {
        extends$(class$, super$);
        function class$() {
          var i, prop;
          for (var i$ = 0, length$ = props.length; i$ < length$; ++i$) {
            prop = props[i$];
            i = i$;
            this[prop] = arguments[i];
          }
        }
        class$.prototype.type = type;
        class$.prototype.childNodes = props;
        return class$;
      }(Nodes);
    };
    this.Nodes = Nodes = function () {
      function Nodes() {
      }
      Nodes.prototype.listMembers = [];
      Nodes.prototype['instanceof'] = function (ctors) {
        var ctor;
        ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
        for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
          ctor = ctors[i$];
          if (!(this.type === ctor.prototype.type))
            continue;
          return true;
        }
        return false;
      };
      Nodes.prototype.toBasicObject = function () {
        var child, obj, p;
        obj = { type: this.type };
        if (null != this.leadingComments)
          obj.leadingComments = this.leadingComments;
        for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
          child = this.childNodes[i$];
          if (in$(child, this.listMembers)) {
            obj[child] = function (accum$) {
              for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
                p = this[child][i$1];
                accum$.push('undefined' !== typeof p && null != p ? p.toBasicObject() : void 0);
              }
              return accum$;
            }.call(this, []);
          } else {
            obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
          }
        }
        if (null != this.line && null != this.column)
          obj.loc = {
            start: {
              line: this.line,
              column: this.column
            }
          };
        if (null != this.offset)
          obj.range = [
            this.offset,
            null != this.raw ? this.offset + this.raw.length : void 0
          ];
        if (null != this.raw)
          obj.raw = this.raw;
        if (null != this.verbatim)
          obj.verbatim = this.verbatim;
        return obj;
      };
      return Nodes;
    }();
    nodeData = [
      [
        'ArrayExpression',
        false,
        ['elements']
      ],
      [
        'AssignmentExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'BinaryExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'BlockStatement',
        true,
        ['body']
      ],
      [
        'BreakStatement',
        true,
        ['label']
      ],
      [
        'CallExpression',
        false,
        [
          'callee',
          'arguments'
        ]
      ],
      [
        'CatchClause',
        true,
        [
          'param',
          'body'
        ]
      ],
      [
        'ConditionalExpression',
        false,
        [
          'test',
          'consequent',
          'alternate'
        ]
      ],
      [
        'ContinueStatement',
        true,
        ['label']
      ],
      [
        'DebuggerStatement',
        true,
        []
      ],
      [
        'DoWhileStatement',
        true,
        [
          'body',
          'test'
        ]
      ],
      [
        'EmptyStatement',
        true,
        []
      ],
      [
        'ExpressionStatement',
        true,
        ['expression']
      ],
      [
        'ForInStatement',
        true,
        [
          'left',
          'right',
          'body'
        ]
      ],
      [
        'ForStatement',
        true,
        [
          'init',
          'test',
          'update',
          'body'
        ]
      ],
      [
        'FunctionDeclaration',
        true,
        [
          'id',
          'params',
          'body'
        ]
      ],
      [
        'FunctionExpression',
        false,
        [
          'id',
          'params',
          'body'
        ]
      ],
      [
        'GenSym',
        false,
        [
          'ns',
          'uniqueId'
        ]
      ],
      [
        'Identifier',
        false,
        ['name']
      ],
      [
        'IfStatement',
        true,
        [
          'test',
          'consequent',
          'alternate'
        ]
      ],
      [
        'LabeledStatement',
        true,
        [
          'label',
          'body'
        ]
      ],
      [
        'Literal',
        false,
        ['value']
      ],
      [
        'LogicalExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'MemberExpression',
        false,
        [
          'computed',
          'object',
          'property'
        ]
      ],
      [
        'NewExpression',
        false,
        [
          'callee',
          'arguments'
        ]
      ],
      [
        'ObjectExpression',
        false,
        ['properties']
      ],
      [
        'Program',
        true,
        ['body']
      ],
      [
        'Property',
        true,
        [
          'key',
          'value'
        ]
      ],
      [
        'ReturnStatement',
        true,
        ['argument']
      ],
      [
        'SequenceExpression',
        false,
        ['expressions']
      ],
      [
        'SwitchCase',
        true,
        [
          'test',
          'consequent'
        ]
      ],
      [
        'SwitchStatement',
        true,
        [
          'discriminant',
          'cases'
        ]
      ],
      [
        'ThisExpression',
        false,
        []
      ],
      [
        'ThrowStatement',
        true,
        ['argument']
      ],
      [
        'TryStatement',
        true,
        [
          'block',
          'handlers',
          'finalizer'
        ]
      ],
      [
        'UnaryExpression',
        false,
        [
          'operator',
          'argument'
        ]
      ],
      [
        'UpdateExpression',
        false,
        [
          'operator',
          'prefix',
          'argument'
        ]
      ],
      [
        'VariableDeclaration',
        true,
        [
          'kind',
          'declarations'
        ]
      ],
      [
        'VariableDeclarator',
        true,
        [
          'id',
          'init'
        ]
      ],
      [
        'WhileStatement',
        true,
        [
          'test',
          'body'
        ]
      ],
      [
        'WithStatement',
        true,
        [
          'object',
          'body'
        ]
      ]
    ];
    for (var i$ = 0, length$ = nodeData.length; i$ < length$; ++i$) {
      {
        cache$ = nodeData[i$];
        node = cache$[0];
        isStatement = cache$[1];
        params = cache$[2];
      }
      exports[node] = ctor = createNode(node, params);
      ctor.prototype.isStatement = isStatement;
      ctor.prototype.isExpression = !isStatement;
    }
    cache$1 = exports;
    Program = cache$1.Program;
    BlockStatement = cache$1.BlockStatement;
    Literal = cache$1.Literal;
    Identifier = cache$1.Identifier;
    FunctionExpression = cache$1.FunctionExpression;
    CallExpression = cache$1.CallExpression;
    SequenceExpression = cache$1.SequenceExpression;
    ArrayExpression = cache$1.ArrayExpression;
    BinaryExpression = cache$1.BinaryExpression;
    UnaryExpression = cache$1.UnaryExpression;
    NewExpression = cache$1.NewExpression;
    VariableDeclaration = cache$1.VariableDeclaration;
    ObjectExpression = cache$1.ObjectExpression;
    MemberExpression = cache$1.MemberExpression;
    UpdateExpression = cache$1.UpdateExpression;
    AssignmentExpression = cache$1.AssignmentExpression;
    LogicalExpression = cache$1.LogicalExpression;
    GenSym = cache$1.GenSym;
    FunctionDeclaration = cache$1.FunctionDeclaration;
    VariableDeclaration = cache$1.VariableDeclaration;
    SwitchStatement = cache$1.SwitchStatement;
    SwitchCase = cache$1.SwitchCase;
    TryStatement = cache$1.TryStatement;
    handlePrimitives = function (ctor, primitives) {
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$1 = 0, length$1 = primitives.length; i$1 < length$1; ++i$1) {
          primitive = primitives[i$1];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(AssignmentExpression, ['operator']);
    handlePrimitives(BinaryExpression, ['operator']);
    handlePrimitives(LogicalExpression, ['operator']);
    handlePrimitives(GenSym, [
      'ns',
      'uniqueId'
    ]);
    handlePrimitives(Identifier, ['name']);
    handlePrimitives(Literal, ['value']);
    handlePrimitives(MemberExpression, ['computed']);
    handlePrimitives(UnaryExpression, ['operator']);
    handlePrimitives(UpdateExpression, [
      'operator',
      'prefix'
    ]);
    handlePrimitives(VariableDeclaration, ['kind']);
    handleLists = function (ctor, listProps) {
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayExpression, ['elements']);
    handleLists(BlockStatement, ['body']);
    handleLists(CallExpression, ['arguments']);
    handleLists(FunctionDeclaration, ['params']);
    handleLists(FunctionExpression, ['params']);
    handleLists(NewExpression, ['arguments']);
    handleLists(ObjectExpression, ['properties']);
    handleLists(Program, ['body']);
    handleLists(SequenceExpression, ['expressions']);
    handleLists(SwitchCase, ['consequent']);
    handleLists(SwitchStatement, ['cases']);
    handleLists(TryStatement, ['handlers']);
    handleLists(VariableDeclaration, ['declarations']);
    FunctionDeclaration.prototype.generated = FunctionExpression.prototype.generated = false;
    FunctionDeclaration.prototype.g = FunctionExpression.prototype.g = function () {
      this.generated = true;
      return this;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/functional-helpers.coffee', function (module, exports, __dirname, __filename) {
    var concat, foldl, map, nub, span;
    this.any = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (fn(e))
          return true;
      }
      return false;
    };
    this.all = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (!fn(e))
          return false;
      }
      return true;
    };
    this.foldl = foldl = function (memo, list, fn) {
      var i;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        memo = fn(memo, i);
      }
      return memo;
    };
    this.foldl1 = function (list, fn) {
      return foldl(list[0], list.slice(1), fn);
    };
    this.map = map = function (list, fn) {
      var e;
      return function (accum$) {
        for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
          e = list[i$];
          accum$.push(fn(e));
        }
        return accum$;
      }.call(this, []);
    };
    this.concat = concat = function (list) {
      var cache$;
      return (cache$ = []).concat.apply(cache$, [].slice.call(list));
    };
    this.concatMap = function (list, fn) {
      return concat(map(list, fn));
    };
    this.intersect = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.difference = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.nub = nub = function (list) {
      var i, result;
      result = [];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        if (!!in$(i, result))
          continue;
        result.push(i);
      }
      return result;
    };
    this.union = function (listA, listB) {
      var b;
      return listA.concat(function (accum$) {
        for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          b = cache$[i$];
          if (!!in$(b, listA))
            continue;
          accum$.push(b);
        }
        return accum$;
      }.call(this, []));
    };
    this.flip = function (fn) {
      return function (b, a) {
        return fn.call(this, a, b);
      };
    };
    this.owns = function (hop) {
      return function (a, b) {
        return hop.call(a, b);
      };
    }({}.hasOwnProperty);
    this.span = span = function (list, f) {
      var cache$, ys, zs;
      if (list.length === 0) {
        return [
          [],
          []
        ];
      } else if (f(list[0])) {
        cache$ = span(list.slice(1), f);
        ys = cache$[0];
        zs = cache$[1];
        return [
          [list[0]].concat([].slice.call(ys)),
          zs
        ];
      } else {
        return [
          [],
          list
        ];
      }
    };
    this.divMod = function (a, b) {
      var c, div, mod;
      c = a % b;
      mod = c < 0 ? c + b : c;
      div = Math.floor(a / b);
      return [
        div,
        mod
      ];
    };
    this.partition = function (list, fn) {
      var item, result;
      result = [
        [],
        []
      ];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        item = list[i$];
        result[+!fn(item)].push(item);
      }
      return result;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/nodes.coffee', function (module, exports, __dirname, __filename) {
    var _, Annotations, ArrayInitialiser, AssignOp, Block, Bool, Class, CompoundAssignOp, ComputedProperty, concat, concatMap, Conditional, createNodes, difference, enumerableMethods, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, MemberAccessOp, Mixin, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, ObjectInitialiserMember, PostDecrementOp, PostIncrementOp, Primitives, Range, RegExp, RegExps, Slice, SoakedMemberAccessOp, StaticMemberAccessOps, Super, Switch, SwitchCase, This, union, While;
    cache$ = require('/src/functional-helpers.coffee', module);
    map = cache$.map;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    nub = cache$.nub;
    union = cache$.union;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    _ = require('/node_modules/lodash/index.js', module);
    createNodes = function (subclasses, superclasses) {
      var className, specs;
      if (null == superclasses)
        superclasses = [];
      for (className in subclasses) {
        if (!isOwn$(subclasses, className))
          continue;
        specs = subclasses[className];
        (function (className) {
          var externalCtor$, isCategory, klass, params, superclass;
          superclass = null != superclasses[0] ? superclasses[0] : function () {
          };
          isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
          params = 'undefined' !== typeof specs && null != specs ? function () {
            switch (specs.length) {
            case 0:
              return [];
            case 1:
            case 2:
              return specs[0];
            }
          }.call(this) : null;
          if (null != params)
            params;
          else
            params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
          klass = function (super$) {
            extends$(class$, super$);
            externalCtor$ = isCategory ? function () {
            } : function () {
              var i, param;
              for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                param = params[i$];
                i = i$;
                this[param] = arguments[i];
              }
              if (null != this.initialise)
                this.initialise.apply(this, arguments);
              return this;
            };
            function class$() {
              return externalCtor$.apply(this, arguments);
            }
            class$.prototype.className = className;
            class$.superclasses = superclasses;
            return class$;
          }(superclass);
          if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
            klass.prototype.childNodes = specs[0];
          if (isCategory)
            createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
          return exports[className] = klass;
        }(className));
      }
    };
    createNodes({
      Nodes: [
        [],
        {
          BinOps: [
            [
              'left',
              'right'
            ],
            {
              AssignOps: [
                [
                  'assignee',
                  'expression'
                ],
                {
                  AssignOp: null,
                  ClassProtoAssignOp: null,
                  CompoundAssignOp: [[
                      'op',
                      'assignee',
                      'expression'
                    ]]
                }
              ],
              BitOps: [
                null,
                {
                  BitAndOp: null,
                  BitOrOp: null,
                  BitXorOp: null,
                  LeftShiftOp: null,
                  SignedRightShiftOp: null,
                  UnsignedRightShiftOp: null
                }
              ],
              ComparisonOps: [
                null,
                {
                  EQOp: null,
                  GTEOp: null,
                  GTOp: null,
                  LTEOp: null,
                  LTOp: null,
                  NEQOp: null
                }
              ],
              ConcatOp: null,
              ExistsOp: null,
              ExtendsOp: null,
              InOp: null,
              InstanceofOp: null,
              LogicalOps: [
                null,
                {
                  LogicalAndOp: null,
                  LogicalOrOp: null
                }
              ],
              MathsOps: [
                null,
                {
                  ExpOp: null,
                  DivideOp: null,
                  MultiplyOp: null,
                  RemOp: null,
                  SubtractOp: null
                }
              ],
              OfOp: null,
              PlusOp: null,
              Range: [[
                  'isInclusive',
                  'left',
                  'right'
                ]],
              SeqOp: null
            }
          ],
          Statements: [
            [],
            {
              Break: null,
              Continue: null,
              Debugger: null,
              Return: [['expression']],
              Throw: [['expression']]
            }
          ],
          UnaryOps: [
            ['expression'],
            {
              BitNotOp: null,
              DeleteOp: null,
              DoOp: null,
              LogicalNotOp: null,
              NewOp: [[
                  'ctor',
                  'arguments'
                ]],
              PreDecrementOp: null,
              PreIncrementOp: null,
              PostDecrementOp: null,
              PostIncrementOp: null,
              TypeofOp: null,
              UnaryExistsOp: null,
              UnaryNegateOp: null,
              UnaryPlusOp: null
            }
          ],
          MemberAccessOps: [
            null,
            {
              StaticMemberAccessOps: [
                [
                  'expression',
                  'memberName'
                ],
                {
                  MemberAccessOp: null,
                  NativeMemberAccessOp: null,
                  ProtoMemberAccessOp: null,
                  SoakedMemberAccessOp: null,
                  SoakedProtoMemberAccessOp: null
                }
              ],
              DynamicMemberAccessOps: [
                [
                  'expression',
                  'indexingExpr'
                ],
                {
                  DynamicMemberAccessOp: null,
                  DynamicProtoMemberAccessOp: null,
                  SoakedDynamicMemberAccessOp: null,
                  SoakedDynamicProtoMemberAccessOp: null
                }
              ]
            }
          ],
          ChainedComparisonOp: [['expression']],
          FunctionApplications: [
            [
              'function',
              'arguments'
            ],
            {
              FunctionApplication: null,
              SoakedFunctionApplication: null
            }
          ],
          Super: null,
          Program: [['body']],
          Block: [['statements']],
          Conditional: [[
              'condition',
              'consequent',
              'alternate'
            ]],
          ForIn: [[
              'valAssignee',
              'keyAssignee',
              'target',
              'step',
              'filter',
              'body'
            ]],
          ForOf: [[
              'isOwn',
              'keyAssignee',
              'valAssignee',
              'target',
              'filter',
              'body'
            ]],
          Switch: [[
              'expression',
              'cases',
              'alternate'
            ]],
          SwitchCase: [[
              'conditions',
              'consequent'
            ]],
          Try: [[
              'body',
              'catchAssignee',
              'catchBody',
              'finallyBody'
            ]],
          While: [[
              'condition',
              'body'
            ]],
          ArrayInitialiser: [['members']],
          ObjectInitialiser: [['members']],
          ObjectInitialiserMember: [[
              'key',
              'expression',
              'annotations'
            ]],
          Mixin: [[
              'nameAssignee',
              'body',
              'mixins'
            ]],
          Class: [[
              'nameAssignee',
              'parent',
              'ctor',
              'body',
              'mixins',
              'boundMembers'
            ]],
          Constructor: [['expression']],
          Functions: [
            [
              'parameters',
              'body'
            ],
            {
              Function: null,
              BoundFunction: null,
              ComputedProperty: null
            }
          ],
          DefaultParam: [[
              'param',
              'default'
            ]],
          Annotations: [
            ['parameters'],
            {
              Volatile: null,
              Computed: null,
              Observes: null
            }
          ],
          Identifiers: [
            ['data'],
            {
              Identifier: null,
              GenSym: null
            }
          ],
          Null: null,
          Primitives: [
            ['data'],
            {
              Bool: null,
              JavaScript: null,
              Numbers: [
                null,
                {
                  Int: null,
                  Float: null
                }
              ],
              String: null
            }
          ],
          RegExps: [
            null,
            {
              RegExp: [[
                  'data',
                  'flags'
                ]],
              HeregExp: [[
                  'expression',
                  'flags'
                ]]
            }
          ],
          This: null,
          Undefined: null,
          Slice: [[
              'expression',
              'isInclusive',
              'left',
              'right'
            ]],
          Rest: [['expression']],
          Spread: [['expression']]
        }
      ]
    });
    cache$1 = exports;
    Nodes = cache$1.Nodes;
    Primitives = cache$1.Primitives;
    CompoundAssignOp = cache$1.CompoundAssignOp;
    StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
    Range = cache$1.Range;
    ArrayInitialiser = cache$1.ArrayInitialiser;
    ObjectInitialiser = cache$1.ObjectInitialiser;
    NegatedConditional = cache$1.NegatedConditional;
    Conditional = cache$1.Conditional;
    Identifier = cache$1.Identifier;
    ForOf = cache$1.ForOf;
    Functions = cache$1.Functions;
    While = cache$1.While;
    Mixin = cache$1.Mixin;
    Class = cache$1.Class;
    Block = cache$1.Block;
    NewOp = cache$1.NewOp;
    Bool = cache$1.Bool;
    FunctionApplications = cache$1.FunctionApplications;
    RegExps = cache$1.RegExps;
    RegExp = cache$1.RegExp;
    HeregExp = cache$1.HeregExp;
    Super = cache$1.Super;
    Slice = cache$1.Slice;
    Switch = cache$1.Switch;
    Identifiers = cache$1.Identifiers;
    SwitchCase = cache$1.SwitchCase;
    GenSym = cache$1.GenSym;
    ComputedProperty = cache$1.ComputedProperty;
    ObjectInitialiserMember = cache$1.ObjectInitialiserMember;
    Annotations = cache$1.Annotations;
    PostIncrementOp = cache$1.PostIncrementOp;
    PostDecrementOp = cache$1.PostDecrementOp;
    MemberAccessOp = cache$1.MemberAccessOp;
    This = cache$1.This;
    AssignOp = cache$1.AssignOp;
    SoakedMemberAccessOp = cache$1.SoakedMemberAccessOp;
    Nodes.fromBasicObject = function (obj) {
      return exports[obj.type].fromBasicObject(obj);
    };
    Nodes.prototype.listMembers = [];
    Nodes.prototype.toBasicObject = function () {
      var child, obj, p;
      obj = { type: this.className };
      if (null != this.line)
        obj.line = this.line;
      if (null != this.column)
        obj.column = this.column;
      if (null != this.raw) {
        obj.raw = this.raw;
        if (null != this.offset)
          obj.range = [
            this.offset,
            this.offset + this.raw.length
          ];
      }
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          obj[child] = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.toBasicObject());
            }
            return accum$;
          }.call(this, []);
        } else {
          obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
        }
      }
      return obj;
    };
    Nodes.prototype.fold = function (memo, fn) {
      var child, p;
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          memo = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.fold(memo, fn));
            }
            return accum$;
          }.call(this, []);
        } else {
          memo = this[child].fold(memo, fn);
        }
      }
      return fn(memo, this);
    };
    Nodes.prototype.clone = function () {
      var ctor, k, n, v;
      ctor = function () {
      };
      ctor.prototype = this.constructor.prototype;
      n = new ctor;
      for (k in this) {
        if (!isOwn$(this, k))
          continue;
        v = this[k];
        n[k] = v;
      }
      return n;
    };
    Nodes.prototype['instanceof'] = function (ctors) {
      var ctor, superclasses;
      ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      superclasses = map(this.constructor.superclasses, function (c) {
        return c.prototype.className;
      });
      for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
        ctor = ctors[i$];
        if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
          continue;
        return true;
      }
      return false;
    };
    Nodes.prototype.r = function (param$) {
      this.raw = param$;
      return this;
    };
    Nodes.prototype.p = function (param$, param$1, param$2) {
      this.line = param$;
      this.column = param$1;
      this.offset = param$2;
      return this;
    };
    Nodes.prototype.generated = false;
    Nodes.prototype.g = function () {
      this.generated = true;
      return this;
    };
    handlePrimitives = function (ctor, primitives) {
      primitives = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
          primitive = primitives[i$];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(Class, 'boundMembers');
    handlePrimitives(CompoundAssignOp, 'op');
    handlePrimitives(ForOf, 'isOwn');
    handlePrimitives(HeregExp, 'flags');
    handlePrimitives(Identifiers, 'data');
    handlePrimitives(Primitives, 'data');
    handlePrimitives(Range, 'isInclusive');
    handlePrimitives(RegExp, 'data', 'flags');
    handlePrimitives(Slice, 'isInclusive');
    handlePrimitives(StaticMemberAccessOps, 'memberName');
    handlePrimitives(ComputedProperty, 'chains');
    handlePrimitives(ObjectInitialiserMember, 'annotations');
    handlePrimitives(Annotations, 'parameters');
    handleLists = function (ctor, listProps) {
      listProps = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayInitialiser, 'members');
    handleLists(Block, 'statements');
    handleLists(Functions, 'parameters');
    handleLists(FunctionApplications, 'arguments');
    handleLists(NewOp, 'arguments');
    handleLists(ObjectInitialiser, 'members');
    handleLists(Super, 'arguments');
    handleLists(Switch, 'cases');
    handleLists(SwitchCase, 'conditions');
    handleLists(Class, 'mixins');
    handleLists(Mixin, 'mixins');
    Block.wrap = function (s) {
      return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
    };
    Class.prototype.initialise = function () {
      if (null != this.boundMembers)
        this.boundMembers;
      else
        this.boundMembers = [];
      this.name = new GenSym('class');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Class.prototype.childNodes.push('name');
    Mixin.prototype.initialise = function () {
      this.name = new GenSym('mixin');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Mixin.prototype.childNodes.push('name');
    ObjectInitialiser.prototype.keys = function () {
      return map(this.members, function (m) {
        return m.key;
      });
    };
    ObjectInitialiser.prototype.vals = function () {
      return map(this.members, function (m) {
        return m.expression;
      });
    };
    RegExps.prototype.initialise = function (_, flags) {
      var flag;
      this.flags = {};
      for (var cache$2 = [
            'g',
            'i',
            'm',
            'y'
          ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
        flag = cache$2[i$];
        this.flags[flag] = in$(flag, flags);
      }
    };
    PostIncrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    PostDecrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    Nodes.prototype.dependentKeys = function (scope) {
      var chains, child, childName, member;
      if (null == scope)
        scope = {};
      chains = [];
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            chains = chains.concat(member.dependentKeys(scope));
          }
        } else {
          child = this[childName];
          chains = chains.concat(child.dependentKeys(scope));
        }
      }
      return chains;
    };
    This.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return [[]];
    };
    MemberAccessOp.prototype.dependentKeys = function (scope) {
      var memberName;
      if (null == scope)
        scope = {};
      memberName = this.memberName;
      return this.expression.dependentKeys(scope).map(function (c) {
        if (!(memberName === 'constructor'))
          c.push(memberName);
        return c;
      });
    };
    SoakedMemberAccessOp.prototype.dependentKeys = MemberAccessOp.prototype.dependentKeys;
    enumerableMethods = [
      'nextObject',
      'firstObject',
      'lastObject',
      'contains',
      'forEach',
      'getEach',
      'setEach',
      'map',
      'mapProperty',
      'filter',
      'reject',
      'filterProperty',
      'rejectProperty',
      'find',
      'findProperty',
      'every',
      'everyProperty',
      'some',
      'someProperty',
      'reduce',
      'invoke',
      'toArray',
      'compact',
      'without',
      'uniq'
    ];
    FunctionApplications.prototype.dependentKeys = function (scope) {
      var argument, res;
      if (null == scope)
        scope = {};
      res = this['function'].dependentKeys(scope);
      if (this['function']['instanceof'](MemberAccessOp) || this['function']['instanceof'](SoakedMemberAccessOp)) {
        res = res.map(function (c) {
          c.pop();
          return c;
        });
        if (_.contains(enumerableMethods, this['function'].memberName))
          res = res.map(function (c) {
            c.push('[]');
            return c;
          });
      }
      for (var i$ = 0, length$ = this['arguments'].length; i$ < length$; ++i$) {
        argument = this['arguments'][i$];
        argument.dependentKeys(scope).map(function (c) {
          return res.push(c);
        });
      }
      return res;
    };
    Block.prototype.dependentKeys = function (scope) {
      var key, newScope, res;
      if (null == scope)
        scope = {};
      res = [];
      newScope = _.clone(scope);
      for (var i$ = 0, length$ = newScope.length; i$ < length$; ++i$) {
        key = newScope[i$];
        newScope[key] = _.clone(newScope[key]);
      }
      this.statements.forEach(function (s) {
        return res = res.concat(s.dependentKeys(scope));
      });
      for (var i$1 = 0, length$1 = scope.length; i$1 < length$1; ++i$1) {
        key = scope[i$1];
        scope[key] = scope[key].concat(newScope[key]);
      }
      return res;
    };
    AssignOp.prototype.dependentKeys = function (scope) {
      var res;
      if (null == scope)
        scope = {};
      res = this.expression.dependentKeys(scope);
      if (this.assignee['instanceof'](Identifier))
        scope[this.assignee.data] = (scope[this.assignee.data] || []).concat(res);
      return res;
    };
    Identifier.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return _.clone(scope[this.data]) || [];
    };
    exports.NegatedConditional = function (super$) {
      extends$(NegatedConditional, super$);
      function NegatedConditional() {
        Conditional.apply(this, arguments);
      }
      return NegatedConditional;
    }(Conditional);
    exports.NegatedWhile = function (super$1) {
      extends$(NegatedWhile, super$1);
      function NegatedWhile() {
        While.apply(this, arguments);
      }
      return NegatedWhile;
    }(While);
    exports.Loop = function (super$2) {
      extends$(Loop, super$2);
      function Loop(body) {
        While.call(this, new Bool(true).g(), body);
      }
      return Loop;
    }(While);
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/helpers.coffee', function (module, exports, __dirname, __filename) {
    var beingDeclared, cleanMarkers, colourise, COLOURS, concat, concatMap, CS, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, pointToErrorLocation, SUPPORTS_COLOUR, usedAsExpression, usedAsExpression_;
    cache$ = require('/src/functional-helpers.coffee', module);
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    foldl = cache$.foldl;
    map = cache$.map;
    nub = cache$.nub;
    CS = require('/src/nodes.coffee', module);
    COLOURS = {
      red: '\x1B[31m',
      green: '\x1B[32m',
      yellow: '\x1B[33m',
      blue: '\x1B[34m',
      magenta: '\x1B[35m',
      cyan: '\x1B[36m'
    };
    SUPPORTS_COLOUR = ('undefined' !== typeof process && null != process && null != process.stderr ? process.stderr.isTTY : void 0) && !process.env.NODE_DISABLE_COLORS;
    colourise = function (colour, str) {
      if (SUPPORTS_COLOUR) {
        return '' + COLOURS[colour] + str + '\x1B[39m';
      } else {
        return str;
      }
    };
    this.numberLines = numberLines = function (input, startLine) {
      var currLine, i, line, lines, numbered, pad, padSize;
      if (null == startLine)
        startLine = 1;
      lines = input.split('\n');
      padSize = ('' + (lines.length + startLine - 1)).length;
      numbered = function (accum$) {
        for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
          line = lines[i$];
          i = i$;
          currLine = '' + (i + startLine);
          pad = Array(padSize + 1).join('0').slice(currLine.length);
          accum$.push('' + pad + currLine + ' : ' + lines[i]);
        }
        return accum$;
      }.call(this, []);
      return numbered.join('\n');
    };
    cleanMarkers = function (str) {
      return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
    };
    this.humanReadable = humanReadable = function (str) {
      return str.replace(/\uEFEF/g, '(INDENT)').replace(/\uEFFE/g, '(DEDENT)').replace(/\uEFFF/g, '(TERM)');
    };
    this.formatParserError = function (input, e) {
      var found, message, realColumn, unicode;
      realColumn = cleanMarkers(('' + input.split('\n')[e.line - 1] + '\n').slice(0, e.column)).length;
      if (!(null != e.found))
        return 'Syntax error on line ' + e.line + ', column ' + realColumn + ': unexpected end of input';
      found = JSON.stringify(humanReadable(e.found));
      found = found.replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
      unicode = e.found.charCodeAt(0).toString(16).toUpperCase();
      unicode = '\\u' + '0000'.slice(unicode.length) + unicode;
      message = 'Syntax error on line ' + e.line + ', column ' + realColumn + ": unexpected '" + found + "' (" + unicode + ')';
      return '' + message + '\n' + pointToErrorLocation(input, e.line, realColumn);
    };
    this.pointToErrorLocation = pointToErrorLocation = function (source, line, column, numLinesOfContext) {
      var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
      if (null == numLinesOfContext)
        numLinesOfContext = 3;
      lines = source.split('\n');
      if (!lines[lines.length - 1])
        lines.pop();
      currentLineOffset = line - 1;
      startLine = currentLineOffset - numLinesOfContext;
      if (startLine < 0)
        startLine = 0;
      preLines = lines.slice(startLine, +currentLineOffset + 1 || 9e9);
      preLines[preLines.length - 1] = colourise('yellow', preLines[preLines.length - 1]);
      postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1 || 9e9);
      numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
      preLines = numberedLines.slice(0, preLines.length);
      postLines = numberedLines.slice(preLines.length);
      column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
      padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
      return [].slice.call(preLines).concat(['' + colourise('red', Array(padSize + 1).join('^')) + ' : ' + Array(column).join(' ') + colourise('red', '^')], [].slice.call(postLines)).join('\n');
    };
    this.beingDeclared = beingDeclared = function (assignment) {
      switch (false) {
      case !!(null != assignment):
        return [];
      case !assignment['instanceof'](CS.Identifiers):
        return [assignment.data];
      case !assignment['instanceof'](CS.Rest):
        return beingDeclared(assignment.expression);
      case !assignment['instanceof'](CS.MemberAccessOps):
        return [];
      case !assignment['instanceof'](CS.DefaultParam):
        return beingDeclared(assignment.param);
      case !assignment['instanceof'](CS.ArrayInitialiser):
        return concatMap(assignment.members, beingDeclared);
      case !assignment['instanceof'](CS.ObjectInitialiser):
        return concatMap(assignment.vals(), beingDeclared);
      default:
        throw new Error('beingDeclared: Non-exhaustive patterns in case: ' + assignment.className);
      }
    };
    this.declarationsFor = function (node, inScope) {
      var vars;
      vars = envEnrichments(node, inScope);
      return foldl(new CS.Undefined().g(), vars, function (expr, v) {
        return new CS.AssignOp(new CS.Identifier(v).g(), expr).g();
      });
    };
    usedAsExpression_ = function (ancestors) {
      var grandparent, parent;
      parent = ancestors[0];
      grandparent = ancestors[1];
      switch (false) {
      case !!(null != parent):
        return true;
      case !parent['instanceof'](CS.Program, CS.Mixin, CS.Class):
        return false;
      case !parent['instanceof'](CS.SeqOp):
        return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
      case !(parent['instanceof'](CS.Block) && parent.statements.indexOf(this) !== parent.statements.length - 1):
        return false;
      case !(parent['instanceof'](CS.Functions) && parent.body === this && null != grandparent && grandparent['instanceof'](CS.Constructor)):
        return false;
      default:
        return true;
      }
    };
    this.usedAsExpression = usedAsExpression = function (node, ancestors) {
      return usedAsExpression_.call(node, ancestors);
    };
    envEnrichments_ = function (inScope) {
      var possibilities;
      if (null == inScope)
        inScope = [];
      possibilities = nub(function () {
        switch (false) {
        case !this['instanceof'](CS.AssignOp):
          return concat([
            beingDeclared(this.assignee),
            envEnrichments(this.expression)
          ]);
        case !this['instanceof'](CS.Mixin):
          return concat([
            beingDeclared(this.nameAssignee),
            'undefined' !== typeof name && null != name ? [name] : []
          ]);
        case !this['instanceof'](CS.Class):
          return concat([
            beingDeclared(this.nameAssignee),
            envEnrichments(this.parent)
          ]);
        case !this['instanceof'](CS.ForIn, CS.ForOf):
          return concat([
            beingDeclared(this.keyAssignee),
            beingDeclared(this.valAssignee),
            envEnrichments(this.target),
            envEnrichments(this.step),
            envEnrichments(this.filter),
            envEnrichments(this.body)
          ]);
        case !this['instanceof'](CS.Try):
          return concat([
            beingDeclared(this.catchAssignee),
            envEnrichments(this.body),
            envEnrichments(this.catchBody),
            envEnrichments(this.finallyBody)
          ]);
        case !this['instanceof'](CS.Functions):
          return [];
        default:
          return concatMap(this.childNodes, function (this$) {
            return function (child) {
              if (in$(child, this$.listMembers)) {
                return concatMap(this$[child], function (m) {
                  return envEnrichments(m, inScope);
                });
              } else {
                return envEnrichments(this$[child], inScope);
              }
            };
          }(this));
        }
      }.call(this));
      return difference(possibilities, inScope);
    };
    this.envEnrichments = envEnrichments = function (node, args) {
      args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      if (null != node) {
        return envEnrichments_.apply(node, args);
      } else {
        return [];
      }
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/optimiser.coffee', function (module, exports, __dirname, __filename) {
    var all, any, beingDeclared, concat, concatMap, CS, declarationsFor, defaultRules, difference, envEnrichments, exports, foldl, foldl1, isFalsey, isTruthy, makeDispatcher, mayHaveSideEffects, union, usedAsExpression;
    cache$ = require('/src/functional-helpers.coffee', module);
    all = cache$.all;
    any = cache$.any;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    foldl = cache$.foldl;
    foldl1 = cache$.foldl1;
    union = cache$.union;
    cache$1 = require('/src/helpers.coffee', module);
    beingDeclared = cache$1.beingDeclared;
    declarationsFor = cache$1.declarationsFor;
    usedAsExpression = cache$1.usedAsExpression;
    envEnrichments = cache$1.envEnrichments;
    CS = require('/src/nodes.coffee', module);
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    makeDispatcher = function (defaultValue, handlers, defaultHandler) {
      var cache$2, ctor, ctors, handler, handlers_, size$;
      if (null == defaultHandler)
        defaultHandler = function () {
        };
      handlers_ = {};
      for (var i$ = 0, length$ = handlers.length; i$ < length$; ++i$) {
        {
          cache$2 = handlers[i$];
          size$ = cache$2.length;
          ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
          handler = cache$2[size$ - 1];
        }
        for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
          ctor = ctors[i$1];
          handlers_[ctor.prototype.className] = handler;
        }
      }
      return function (node, args) {
        args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
        if (!(null != node))
          return defaultValue;
        handler = Object.prototype.hasOwnProperty.call(handlers_, node.className) ? handlers_[node.className] : defaultHandler;
        return handler.apply(node, args);
      };
    };
    isTruthy = makeDispatcher(false, [
      [
        CS.ArrayInitialiser,
        CS.Mixin,
        CS.Class,
        CS.DeleteOp,
        CS.ForIn,
        CS.ForOf,
        CS.Function,
        CS.BoundFunction,
        CS.ComputedProperty,
        CS.HeregExp,
        CS.ObjectInitialiser,
        CS.Range,
        CS.RegExp,
        CS.Slice,
        CS.TypeofOp,
        CS.While,
        function () {
          return true;
        }
      ],
      [
        CS.AssignOp,
        function () {
          return isTruthy(this.expression);
        }
      ],
      [
        CS.Block,
        function () {
          if (this.statements.length === 0) {
            return false;
          } else {
            return isTruthy(this.statements[this.statements.length - 1]);
          }
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Int,
        CS.String,
        function () {
          return !!this.data;
        }
      ],
      [
        CS.Conditional,
        function () {
          return isTruthy(this.condition) && isTruthy(this.consequent) || isFalsey(this.condition) && isTruthy(this.alternate);
        }
      ],
      [
        CS.LogicalAndOp,
        function () {
          return isTruthy(this.left) && isTruthy(this.right);
        }
      ],
      [
        CS.LogicalNotOp,
        function () {
          return isFalsey(this.expression);
        }
      ],
      [
        CS.LogicalOrOp,
        function () {
          return isTruthy(this.left) || isTruthy(this.right);
        }
      ],
      [
        CS.Program,
        function () {
          return isTruthy(this.body);
        }
      ],
      [
        CS.SeqOp,
        function () {
          return isTruthy(this.right);
        }
      ],
      [
        CS.Switch,
        function () {
          return all(this.cases, isTruthy) && (null != this.alternate ? isTruthy(this.alternate) : true);
        }
      ],
      [
        CS.SwitchCase,
        function () {
          return isTruthy(this.consequent);
        }
      ],
      [
        CS.UnaryExistsOp,
        function () {
          return isTruthy(this.expression) || this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp);
        }
      ]
    ], function () {
      return false;
    });
    isFalsey = makeDispatcher(false, [
      [
        CS.Null,
        CS.Undefined,
        function () {
          return true;
        }
      ],
      [
        CS.AssignOp,
        function () {
          return isFalsey(this.expression);
        }
      ],
      [
        CS.Block,
        function () {
          if (this.statements.length === 0) {
            return true;
          } else {
            return isFalsey(this.statements[this.statements.length - 1]);
          }
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Int,
        CS.String,
        function () {
          return !this.data;
        }
      ],
      [
        CS.Conditional,
        function () {
          return isTruthy(this.condition) && isFalsey(this.consequent) || isFalsey(this.condition) && isFalsey(this.alternate);
        }
      ],
      [
        CS.LogicalAndOp,
        function () {
          return isFalsey(this.left) || isFalsey(this.right);
        }
      ],
      [
        CS.LogicalNotOp,
        function () {
          return isTruthy(this.expression);
        }
      ],
      [
        CS.LogicalOrOp,
        function () {
          return isFalsey(this.left) && isFalsey(this.right);
        }
      ],
      [
        CS.Program,
        function () {
          return isFalsey(this.body);
        }
      ],
      [
        CS.SeqOp,
        function () {
          return isFalsey(this.right);
        }
      ],
      [
        CS.Switch,
        function () {
          return all(this.cases, isFalsey) && (null != this.alternate ? isFalsey(this.alternate) : true);
        }
      ],
      [
        CS.SwitchCase,
        function () {
          return isFalsey(this.block);
        }
      ],
      [
        CS.UnaryExistsOp,
        function () {
          return this.expression['instanceof'](CS.Null, CS.Undefined);
        }
      ]
    ], function () {
      return false;
    });
    mayHaveSideEffects = makeDispatcher(false, [
      [
        CS.Function,
        CS.BoundFunction,
        CS.ComputedProperty,
        CS.Null,
        CS.RegExp,
        CS.This,
        CS.Undefined,
        function () {
          return false;
        }
      ],
      [
        CS.Break,
        CS.Continue,
        CS.Debugger,
        CS.DeleteOp,
        CS.NewOp,
        CS.Return,
        CS.Super,
        CS.PreDecrementOp,
        CS.PreIncrementOp,
        CS.PostDecrementOp,
        CS.PostIncrementOp,
        CS.ClassProtoAssignOp,
        CS.Constructor,
        CS.Throw,
        CS.JavaScript,
        CS.ExtendsOp,
        function () {
          return true;
        }
      ],
      [
        CS.Class,
        CS.Mixin,
        function (inScope) {
          return mayHaveSideEffects(this.parent, inScope) || null != this.nameAssignee && (this.name || beingDeclared(this.nameAssignee).length > 0);
        }
      ],
      [
        CS.Conditional,
        function (inScope) {
          return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.consequent, inScope) || !isTruthy(this.condition) && mayHaveSideEffects(this.alternate, inScope);
        }
      ],
      [
        CS.DoOp,
        function (inScope) {
          var args, newScope, p;
          if (!this.expression['instanceof'](CS.Functions))
            return true;
          newScope = difference(inScope, concatMap(this.expression.parameters, beingDeclared));
          args = function (accum$) {
            for (var i$ = 0, length$ = this.expression.parameters.length; i$ < length$; ++i$) {
              p = this.expression.parameters[i$];
              accum$.push(p['instanceof'](CS.AssignOp) ? p.expression : p);
            }
            return accum$;
          }.call(this, []);
          if (any(args, function (a) {
              return mayHaveSideEffects(a, newScope);
            }))
            return true;
          return mayHaveSideEffects(this.expression.body, newScope);
        }
      ],
      [
        CS.ExistsOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (this.left['instanceof'](CS.Undefined, CS.Null))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.FunctionApplication,
        CS.SoakedFunctionApplication,
        function (inScope) {
          var newScope;
          if (!this['function']['instanceof'](CS.Function, CS.BoundFunction))
            return true;
          newScope = difference(inScope, concatMap(this['function'].parameters, beingDeclared));
          if (any(this['arguments'], function (a) {
              return mayHaveSideEffects(a, newScope);
            }))
            return true;
          return mayHaveSideEffects(this['function'].body, newScope);
        }
      ],
      [
        CS.LogicalAndOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (isFalsey(this.left))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.LogicalOrOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (isTruthy(this.left))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.While,
        function (inScope) {
          return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.body, inScope);
        }
      ],
      [
        CS.AssignOp,
        CS.ClassProtoAssignOp,
        CS.CompoundAssignOp,
        function (inScope) {
          return true;
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Identifier,
        CS.Int,
        CS.String,
        function () {
          return false;
        }
      ]
    ], function (inScope) {
      return any(this.childNodes, function (this$) {
        return function (child) {
          if (in$(child, this$.listMembers)) {
            return any(this$[child], function (m) {
              return mayHaveSideEffects(m, inScope);
            });
          } else {
            return mayHaveSideEffects(this$[child], inScope);
          }
        };
      }(this));
    });
    exports.Optimiser = function () {
      Optimiser.optimise = function (this$) {
        return function () {
          var cache$2;
          return (cache$2 = new this$).optimise.apply(cache$2, [].slice.call(arguments));
        };
      }(Optimiser);
      Optimiser.isTruthy = isTruthy;
      Optimiser.isFalsey = isFalsey;
      Optimiser.mayHaveSideEffects = mayHaveSideEffects;
      defaultRules = [
        [
          CS.Program,
          function () {
            if (!(null != this.body) || mayHaveSideEffects(this.body, [])) {
              return this;
            } else {
              return new CS.Program(null);
            }
          }
        ],
        [
          CS.Block,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            switch (this.statements.length) {
            case 0:
              return new CS.Undefined().g();
            case 1:
              return this.statements[0];
            default:
              return foldl(this.statements[0], this.statements.slice(1), function (expr, s) {
                return new CS.SeqOp(expr, s);
              });
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var ancestry, cache$2, canDropLast, inScope;
            {
              cache$2 = param$;
              inScope = cache$2.inScope;
              ancestry = cache$2.ancestry;
            }
            canDropLast = !usedAsExpression(this, ancestry);
            if (this.left['instanceof'](CS.Undefined)) {
              return this.right;
            } else if (this.left['instanceof'](CS.Return, CS.Throw)) {
              return this.left;
            } else if (mayHaveSideEffects(this.left, inScope)) {
              if (mayHaveSideEffects(this.right, inScope)) {
                return this;
              } else if (!canDropLast) {
                return this;
              } else if (this.right['instanceof'](CS.Undefined)) {
                return this.left;
              } else {
                return new CS.SeqOp(this.left, declarationsFor(this.right, union(inScope, envEnrichments(this.left, inScope))));
              }
            } else if (this.right['instanceof'](CS.Identifier) && this.right.data === 'eval' && ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.FunctionApplication) : void 0) && ancestry[0]['function'] === this || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.DoOp) : void 0) && ancestry[0].expression === this)) {
              if (this.left['instanceof'](CS.Int) && (0 <= this.left.data && this.left.data <= 9)) {
                return this;
              } else if (mayHaveSideEffects(this.left, inScope)) {
                return this;
              } else {
                return new CS.SeqOp(new CS.Int(0).g(), this.right);
              }
            } else if (mayHaveSideEffects(this.right, inScope)) {
              return new CS.SeqOp(declarationsFor(this.left, inScope), this.right);
            } else if (canDropLast) {
              return declarationsFor(this, inScope);
            } else {
              return this.right;
            }
          }
        ],
        [
          CS.AssignOp,
          function () {
            if (!this.expression['instanceof'](CS.SeqOp))
              return this;
            return new CS.SeqOp(this.expression.left, new CS.AssignOp(this.assignee, this.expression.right));
          }
        ],
        [
          CS.While,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (isFalsey(this.condition)) {
              return new CS.Block([
                mayHaveSideEffects(this.condition, inScope) ? new CS.SeqOp(this.condition, declarationsFor(this.body)) : null != this.body ? declarationsFor(this.body, inScope) : new CS.Undefined,
                new CS.ArrayInitialiser([])
              ]);
            } else if (isTruthy(this.condition)) {
              if (mayHaveSideEffects(this.condition, inScope)) {
                return this;
              } else if (null != this.body) {
                if (this instanceof CS.Loop) {
                  return this;
                } else {
                  return new CS.Loop(this.body).g();
                }
              } else {
                return new CS.ArrayInitialiser([]);
              }
            } else {
              return this;
            }
          }
        ],
        [
          CS.Conditional,
          function (param$) {
            var block, cache$2, cache$3, decls, inScope, removedBlock;
            inScope = param$.inScope;
            if (isFalsey(this.condition)) {
              cache$2 = [
                this.consequent,
                this.alternate
              ];
              removedBlock = cache$2[0];
              block = cache$2[1];
              cache$2;
            } else if (isTruthy(this.condition)) {
              cache$3 = [
                this.consequent,
                this.alternate
              ];
              block = cache$3[0];
              removedBlock = cache$3[1];
              cache$3;
            } else {
              return this;
            }
            decls = declarationsFor(removedBlock, inScope);
            block = null != block ? new CS.SeqOp(decls, block) : decls;
            if (mayHaveSideEffects(this.condition, inScope))
              block = new CS.SeqOp(this.condition, block);
            return block;
          }
        ],
        [
          CS.ForIn,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!(this.target['instanceof'](CS.ArrayInitialiser) && this.target.members.length === 0))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForOf,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!(this.isOwn && this.target['instanceof'](CS.ObjectInitialiser) && this.target.members.length === 0))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForIn,
          CS.ForOf,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!isFalsey(this.filter))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForIn,
          function () {
            if (!isTruthy(this.filter))
              return this;
            return new CS.ForIn(this.valAssignee, this.keyAssignee, this.target, this.step, null, this.body);
          }
        ],
        [
          CS.ForOf,
          function () {
            if (!isTruthy(this.filter))
              return this;
            return new CS.ForOf(this.isOwn, this.keyAssignee, this.valAssignee, this.target, null, this.body);
          }
        ],
        [
          CS.ArrayInitialiser,
          function (param$) {
            var ancestry, cache$2, inScope;
            {
              cache$2 = param$;
              inScope = cache$2.inScope;
              ancestry = cache$2.ancestry;
            }
            if (usedAsExpression(this, ancestry)) {
              return this;
            } else {
              return foldl(new CS.Undefined().g(), this.members, function (expr, m) {
                return new CS.SeqOp(expr, m);
              });
            }
          }
        ],
        [
          CS.ExistsOp,
          function () {
            if (this.left['instanceof'](CS.Null, CS.Undefined)) {
              return this.right;
            } else {
              return this;
            }
          }
        ],
        [
          CS.UnaryExistsOp,
          function () {
            if (this.expression['instanceof'](CS.Null, CS.Undefined)) {
              return new CS.Bool(false).g();
            } else {
              return this;
            }
          }
        ],
        [
          CS.LogicalNotOp,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            switch (false) {
            case !this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.Bool):
              return new CS.Bool(!this.expression.data).g();
            case !this.expression['instanceof'](CS.Functions):
              return new CS.Bool(false).g();
            case !this.expression['instanceof'](CS.Null, CS.Undefined):
              return new CS.Bool(true).g();
            case !this.expression['instanceof'](CS.ArrayInitialiser, CS.ObjectInitialiser):
              if (mayHaveSideEffects(this.expression, inScope)) {
                return this;
              } else {
                return new CS.SeqOp(declarationsFor(this.expression, inScope), new CS.Bool(false).g());
              }
            case !this.expression['instanceof'](CS.LogicalNotOp):
              if (this.expression.expression['instanceof'](CS.LogicalNotOp)) {
                return this.expression.expression;
              } else {
                return this;
              }
            default:
              return this;
            }
          }
        ],
        [
          CS.TypeofOp,
          function () {
            switch (false) {
            case !this.expression['instanceof'](CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp):
              return new CS.String('number').g();
            case !this.expression['instanceof'](CS.String):
              return new CS.String('string').g();
            case !this.expression['instanceof'](CS.Functions):
              return new CS.String('function').g();
            case !this.expression['instanceof'](CS.Undefined):
              return new CS.String('undefined').g();
            default:
              return this;
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var ancestry;
            ancestry = param$.ancestry;
            if (!((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Functions) : void 0) && ancestry[0].body === this))
              return this;
            if (this.right['instanceof'](CS.Return) && null != this.right.expression) {
              return new CS.SeqOp(this.left, this.right.expression);
            } else if (this.right['instanceof'](CS.Undefined)) {
              return new CS.SeqOp(this.left, new CS.Return);
            } else {
              return this;
            }
          }
        ],
        [
          CS.Function,
          CS.BoundFunction,
          function () {
            if (!(null != this.block && (this.block['instanceof'](CS.Undefined) || this.block['instanceof'](CS.Return) && !(null != this.block.expression))))
              return this;
            return new this.constructor(this.parameters, null);
          }
        ],
        [
          CS.Return,
          function () {
            if (null != this.expression ? this.expression['instanceof'](CS.Undefined) : void 0) {
              return new CS.Return;
            } else {
              return this;
            }
          }
        ],
        [
          CS.Slice,
          function () {
            if ((null != this.left ? this.left['instanceof'](CS.Int, CS.String) : void 0) && +this.left.data === 0) {
              return new CS.Slice(this.expression, this.isInclusive, null, this.right);
            } else if (this.isInclusive && (null != this.right ? this.right['instanceof'](CS.UnaryNegateOp) : void 0) && this.right.expression['instanceof'](CS.Int) && this.right.expression.data === 1) {
              return new CS.Slice(this.expression, true, this.left, null);
            } else {
              return this;
            }
          }
        ]
      ];
      function Optimiser() {
        var cache$2, ctor, ctors, handler, size$;
        this.rules = {};
        for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
          {
            cache$2 = defaultRules[i$];
            size$ = cache$2.length;
            ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
            handler = cache$2[size$ - 1];
          }
          for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
            ctor = ctors[i$1];
            this.addRule(ctor.prototype.className, handler);
          }
        }
      }
      Optimiser.prototype.addRule = function (ctor, handler) {
        (null != this.rules[ctor] ? this.rules[ctor] : this.rules[ctor] = []).push(handler);
        return this;
      };
      Optimiser.prototype.optimise = function () {
        var walk;
        walk = function (fn, inScope, ancestry) {
          var childName, member, n, p, replacementNode;
          if (null == inScope)
            inScope = [];
          if (null == ancestry)
            ancestry = [];
          ancestry.unshift(this);
          for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
            childName = this.childNodes[i$];
            if (!(null != this[childName]))
              continue;
            if (in$(childName, this.listMembers)) {
              for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
                member = this[childName][i$1];
                n = i$1;
                while (this[childName][n] !== walk.call(this[childName][n] = fn.call(this[childName][n], {
                    inScope: inScope,
                    ancestry: ancestry
                  }), fn, inScope, ancestry)) {
                }
                inScope = union(inScope, envEnrichments(this[childName][n], inScope));
              }
            } else {
              while (this[childName] !== walk.call(this[childName] = fn.call(this[childName], {
                  inScope: inScope,
                  ancestry: ancestry
                }), fn, inScope, ancestry)) {
              }
              inScope = union(inScope, envEnrichments(this[childName], inScope));
            }
          }
          ancestry.shift();
          replacementNode = fn.call(this, {
            inScope: inScope,
            ancestry: ancestry
          });
          if (this !== replacementNode) {
            while (replacementNode !== walk.call(replacementNode = fn.call(replacementNode, {
                inScope: inScope,
                ancestry: ancestry
              }), fn, inScope, ancestry)) {
            }
            for (var cache$2 = [
                  'raw',
                  'line',
                  'column',
                  'offset'
                ], i$2 = 0, length$2 = cache$2.length; i$2 < length$2; ++i$2) {
              p = cache$2[i$2];
              replacementNode[p] = this[p];
            }
          }
          return replacementNode;
        };
        return function (ast) {
          var rules;
          rules = this.rules;
          return walk.call(ast, function (param$) {
            var ancestry, memo, rule;
            ancestry = param$.ancestry;
            if (!(null != this) || this === global)
              throw new Error('Optimiser rules must produce a node. `null` is not a node.');
            if (in$(this, ancestry))
              return this;
            memo = this;
            for (var cache$2 = null != rules[memo.className] ? rules[memo.className] : [], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
              rule = cache$2[i$];
              memo = rule.apply(memo, arguments);
              if (memo !== this)
                break;
            }
            return memo;
          });
        };
      }();
      return Optimiser;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/parser.coffee', function (module, exports, __dirname, __filename) {
    module.exports = function () {
      function subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
      }
      function quote(s) {
        return '"' + s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
      }
      var result = {
          parse: function (input) {
            var parseFunctions = { 'program': parse_program };
            var options = arguments.length > 1 ? arguments[1] : {}, startRule;
            if (options.startRule !== undefined) {
              startRule = options.startRule;
              if (parseFunctions[startRule] === undefined) {
                throw new Error("Can't start parsing from rule " + quote(startRule) + '.');
              }
            } else {
              startRule = 'program';
            }
            var pos = 0;
            var reportedPos = 0;
            var cachedReportedPos = 0;
            var cachedReportedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
              };
            var reportFailures = 0;
            var rightmostFailuresPos = 0;
            var rightmostFailuresExpected = [];
            var cache = {};
            function padLeft(input, padding, length) {
              var result = input;
              var padLength = length - input.length;
              for (var i = 0; i < padLength; i++) {
                result = padding + result;
              }
              return result;
            }
            function escape(ch) {
              var charCode = ch.charCodeAt(0);
              var escapeChar;
              var length;
              if (charCode <= 255) {
                escapeChar = 'x';
                length = 2;
              } else {
                escapeChar = 'u';
                length = 4;
              }
              return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
            }
            function computeReportedPosDetails() {
              function advanceCachedReportedPos() {
                var ch;
                for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
                  ch = input.charAt(cachedReportedPos);
                  if (ch === '\n') {
                    if (!cachedReportedPosDetails.seenCR) {
                      cachedReportedPosDetails.line++;
                    }
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = false;
                  } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
                    cachedReportedPosDetails.line++;
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = true;
                  } else {
                    cachedReportedPosDetails.column++;
                    cachedReportedPosDetails.seenCR = false;
                  }
                }
              }
              if (cachedReportedPos !== reportedPos) {
                if (cachedReportedPos > reportedPos) {
                  cachedReportedPos = 0;
                  cachedReportedPosDetails = {
                    line: 1,
                    column: 1,
                    seenCR: false
                  };
                }
                advanceCachedReportedPos();
              }
              return cachedReportedPosDetails;
            }
            function text() {
              return input.substring(reportedPos, pos);
            }
            function offset() {
              return reportedPos;
            }
            function line() {
              return computeReportedPosDetails().line;
            }
            function column() {
              return computeReportedPosDetails().column;
            }
            function matchFailed(failure) {
              if (pos < rightmostFailuresPos) {
                return;
              }
              if (pos > rightmostFailuresPos) {
                rightmostFailuresPos = pos;
                rightmostFailuresExpected = [];
              }
              rightmostFailuresExpected.push(failure);
            }
            function parse_program() {
              var cacheKey = 'program@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_toplevelBlock();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (leader, b) {
                  return rp(new CS.Program(b || null));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_toplevelBlock() {
              var cacheKey = 'toplevelBlock@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_toplevelStatement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_toplevelStatement();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_toplevelStatement();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s, ss) {
                  return rp(new CS.Block([s].concat(ss.map(function (s) {
                    return s[3];
                  }))));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_toplevelStatement() {
              var cacheKey = 'toplevelStatement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_return();
              if (r3 === null) {
                r3 = parse_continue();
                if (r3 === null) {
                  r3 = parse_break();
                }
              }
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_statement();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s) {
                  return s;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_block() {
              var cacheKey = 'block@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_statement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_statement();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_statement();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s, ss) {
                  return rp(new CS.Block([s].concat(ss.map(function (s) {
                    return s[3];
                  }))));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_statement() {
              var cacheKey = 'statement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expression();
              if (r0 === null) {
                r0 = parse_return();
                if (r0 === null) {
                  r0 = parse_continue();
                  if (r0 === null) {
                    r0 = parse_break();
                    if (r0 === null) {
                      r0 = parse_throw();
                      if (r0 === null) {
                        r0 = parse_debugger();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_expression() {
              var cacheKey = 'expression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_seqExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryStatement() {
              var cacheKey = 'secondaryStatement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_secondaryExpression();
              if (r0 === null) {
                r0 = parse_return();
                if (r0 === null) {
                  r0 = parse_continue();
                  if (r0 === null) {
                    r0 = parse_break();
                    if (r0 === null) {
                      r0 = parse_throw();
                      if (r0 === null) {
                        r0 = parse_debugger();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryExpression() {
              var cacheKey = 'secondaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_assignmentExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryExpressionNoImplicitObjectCall() {
              var cacheKey = 'secondaryExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_assignmentExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_expressionworthy() {
              var cacheKey = 'expressionworthy@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_functionLiteral();
              if (r0 === null) {
                r0 = parse_conditional();
                if (r0 === null) {
                  r0 = parse_while();
                  if (r0 === null) {
                    r0 = parse_loop();
                    if (r0 === null) {
                      r0 = parse_try();
                      if (r0 === null) {
                        r0 = parse_forOf();
                        if (r0 === null) {
                          r0 = parse_forIn();
                          if (r0 === null) {
                            r0 = parse_switch();
                            if (r0 === null) {
                              r0 = parse_implicitObjectLiteral();
                              if (r0 === null) {
                                r0 = parse_class();
                                if (r0 === null) {
                                  r0 = parse_mixin();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_seqExpression() {
              var cacheKey = 'seqExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixControlFlowExpression();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  if (input.charCodeAt(pos) === 59) {
                    r7 = ';';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('";"');
                    }
                  }
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    r8 = r8 !== null ? r8 : '';
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_expression();
                        if (r10 !== null) {
                          r4 = [
                            r6,
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  if (!right)
                    return left;
                  return rp(new CS.SeqOp(left, right[4]));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixControlFlowExpression() {
              var cacheKey = 'postfixControlFlowExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_secondaryStatement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_postfixControlFlowOp();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_postfixControlFlowOp();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (expr, postfixes) {
                  return foldl(function (expr, postfixContainer) {
                    var constructor, cond, postfix = postfixContainer[1], indicator = postfix.type;
                    switch (indicator) {
                    case 'if':
                    case 'unless':
                      constructor = 'unless' === indicator ? CS.NegatedConditional : CS.Conditional;
                      cond = 'unless' === indicator ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                      return rp(new constructor(cond, expr, null));
                    case 'while':
                    case 'until':
                      constructor = 'until' === indicator ? CS.NegatedWhile : CS.While;
                      cond = 'until' === indicator ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                      return rp(new constructor(cond, expr));
                    case 'for-in':
                      return rp(new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr));
                    case 'for-of':
                      return rp(new CS.ForOf(postfix.own, postfix.key, postfix.val, postfix.obj, postfix.filter, expr));
                    }
                  }, expr, postfixes);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixControlFlowOp() {
              var cacheKey = 'postfixControlFlowOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
              r1 = pos;
              r2 = pos;
              r3 = parse_IF();
              if (r3 === null) {
                r3 = parse_UNLESS();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpression();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, e) {
                  return {
                    type: kw,
                    cond: e
                  };
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_WHILE();
                if (r3 === null) {
                  r3 = parse_UNTIL();
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_assignmentExpression();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (kw, e) {
                    return {
                      type: kw,
                      cond: e
                    };
                  }(r3, r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_FOR();
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r6 = pos;
                      r7 = parse_Assignable();
                      if (r7 !== null) {
                        r8 = parse__();
                        if (r8 !== null) {
                          r10 = pos;
                          if (input.charCodeAt(pos) === 44) {
                            r11 = ',';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('","');
                            }
                          }
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_Assignable();
                              if (r13 !== null) {
                                r14 = parse__();
                                if (r14 !== null) {
                                  r9 = [
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r9 = null;
                                  pos = r10;
                                }
                              } else {
                                r9 = null;
                                pos = r10;
                              }
                            } else {
                              r9 = null;
                              pos = r10;
                            }
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r5 = [
                              r7,
                              r8,
                              r9
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                      r5 = r5 !== null ? r5 : '';
                      if (r5 !== null) {
                        r6 = parse_IN();
                        if (r6 !== null) {
                          r7 = parse__();
                          if (r7 !== null) {
                            r8 = parse_assignmentExpression();
                            if (r8 !== null) {
                              r10 = pos;
                              r11 = parse__();
                              if (r11 !== null) {
                                r12 = parse_BY();
                                if (r12 !== null) {
                                  r13 = parse__();
                                  if (r13 !== null) {
                                    r14 = parse_assignmentExpression();
                                    if (r14 !== null) {
                                      r9 = [
                                        r11,
                                        r12,
                                        r13,
                                        r14
                                      ];
                                    } else {
                                      r9 = null;
                                      pos = r10;
                                    }
                                  } else {
                                    r9 = null;
                                    pos = r10;
                                  }
                                } else {
                                  r9 = null;
                                  pos = r10;
                                }
                              } else {
                                r9 = null;
                                pos = r10;
                              }
                              r9 = r9 !== null ? r9 : '';
                              if (r9 !== null) {
                                r11 = pos;
                                r12 = parse__();
                                if (r12 !== null) {
                                  r13 = parse_WHEN();
                                  if (r13 !== null) {
                                    r14 = parse__();
                                    if (r14 !== null) {
                                      r15 = parse_assignmentExpression();
                                      if (r15 !== null) {
                                        r10 = [
                                          r12,
                                          r13,
                                          r14,
                                          r15
                                        ];
                                      } else {
                                        r10 = null;
                                        pos = r11;
                                      }
                                    } else {
                                      r10 = null;
                                      pos = r11;
                                    }
                                  } else {
                                    r10 = null;
                                    pos = r11;
                                  }
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                                r10 = r10 !== null ? r10 : '';
                                if (r10 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (maybeVal, list, maybeStep, maybeFilter) {
                      var val = maybeVal ? maybeVal[0] : null, key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null, step = maybeStep ? maybeStep[3] : new CS.Int(1).r('1').g(), filter = maybeFilter ? maybeFilter[3] : null;
                      return 0, {
                        type: 'for-in',
                        val: val,
                        key: key,
                        list: list,
                        step: step,
                        filter: filter
                      };
                    }(r5, r8, r9, r10);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    r3 = parse_FOR();
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r6 = pos;
                        r7 = parse_OWN();
                        if (r7 !== null) {
                          r8 = parse__();
                          if (r8 !== null) {
                            r5 = [
                              r7,
                              r8
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                        r5 = r5 !== null ? r5 : '';
                        if (r5 !== null) {
                          r6 = parse_Assignable();
                          if (r6 !== null) {
                            r7 = parse__();
                            if (r7 !== null) {
                              r9 = pos;
                              if (input.charCodeAt(pos) === 44) {
                                r10 = ',';
                                pos++;
                              } else {
                                r10 = null;
                                if (reportFailures === 0) {
                                  matchFailed('","');
                                }
                              }
                              if (r10 !== null) {
                                r11 = parse__();
                                if (r11 !== null) {
                                  r12 = parse_Assignable();
                                  if (r12 !== null) {
                                    r13 = parse__();
                                    if (r13 !== null) {
                                      r8 = [
                                        r10,
                                        r11,
                                        r12,
                                        r13
                                      ];
                                    } else {
                                      r8 = null;
                                      pos = r9;
                                    }
                                  } else {
                                    r8 = null;
                                    pos = r9;
                                  }
                                } else {
                                  r8 = null;
                                  pos = r9;
                                }
                              } else {
                                r8 = null;
                                pos = r9;
                              }
                              r8 = r8 !== null ? r8 : '';
                              if (r8 !== null) {
                                r9 = parse_OF();
                                if (r9 !== null) {
                                  r10 = parse__();
                                  if (r10 !== null) {
                                    r11 = parse_assignmentExpression();
                                    if (r11 !== null) {
                                      r13 = pos;
                                      r14 = parse__();
                                      if (r14 !== null) {
                                        r15 = parse_WHEN();
                                        if (r15 !== null) {
                                          r16 = parse__();
                                          if (r16 !== null) {
                                            r17 = parse_assignmentExpression();
                                            if (r17 !== null) {
                                              r12 = [
                                                r14,
                                                r15,
                                                r16,
                                                r17
                                              ];
                                            } else {
                                              r12 = null;
                                              pos = r13;
                                            }
                                          } else {
                                            r12 = null;
                                            pos = r13;
                                          }
                                        } else {
                                          r12 = null;
                                          pos = r13;
                                        }
                                      } else {
                                        r12 = null;
                                        pos = r13;
                                      }
                                      r12 = r12 !== null ? r12 : '';
                                      if (r12 !== null) {
                                        r0 = [
                                          r3,
                                          r4,
                                          r5,
                                          r6,
                                          r7,
                                          r8,
                                          r9,
                                          r10,
                                          r11,
                                          r12
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (maybeOwn, key, maybeVal, obj, maybeFilter) {
                        var own = !!maybeOwn, val = maybeVal ? maybeVal[2] : null, filter = maybeFilter ? maybeFilter[3] : null;
                        return 0, {
                          type: 'for-of',
                          own: own,
                          key: key,
                          val: val,
                          obj: obj,
                          filter: filter
                        };
                      }(r5, r6, r8, r11, r12);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentExpression() {
              var cacheKey = 'assignmentExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_assignmentOp();
              if (r0 === null) {
                r0 = parse_compoundAssignmentOp();
                if (r0 === null) {
                  r0 = parse_existsAssignmentOp();
                  if (r0 === null) {
                    r0 = parse_binaryExpression();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentOp() {
              var cacheKey = 'assignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    reportFailures++;
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    reportFailures--;
                    if (r6 === null) {
                      r6 = '';
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpression();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpression();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.AssignOp(left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_compoundAssignmentOp() {
              var cacheKey = 'compoundAssignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 63) {
                    r5 = '?';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  reportFailures--;
                  if (r5 === null) {
                    r5 = '';
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  if (r5 !== null) {
                    r6 = parse_CompoundAssignmentOperators();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 61) {
                        r7 = '=';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"="');
                        }
                      }
                      if (r7 !== null) {
                        r9 = pos;
                        r10 = pos;
                        r11 = parse_TERMINDENT();
                        if (r11 !== null) {
                          r12 = parse_secondaryExpression();
                          if (r12 !== null) {
                            r13 = parse_DEDENT();
                            if (r13 !== null) {
                              r8 = [
                                r11,
                                r12,
                                r13
                              ];
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                        if (r8 !== null) {
                          reportedPos = r9;
                          r8 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r8 === null) {
                          pos = r9;
                        }
                        if (r8 === null) {
                          r9 = pos;
                          r10 = pos;
                          r11 = parse_TERMINATOR();
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_secondaryExpression();
                              if (r13 !== null) {
                                r8 = [
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r10;
                              }
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                          if (r8 !== null) {
                            reportedPos = r9;
                            r8 = function (e) {
                              return e;
                            }(r13);
                          }
                          if (r8 === null) {
                            pos = r9;
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, op, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
                }(r3, r6, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CompoundAssignmentOperators() {
              var cacheKey = 'CompoundAssignmentOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              if (input.substr(pos, 2) === '&&') {
                r0 = '&&';
                pos += 2;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"&&"');
                }
              }
              if (r0 === null) {
                r0 = parse_AND();
                if (r0 === null) {
                  if (input.substr(pos, 2) === '||') {
                    r0 = '||';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"||"');
                    }
                  }
                  if (r0 === null) {
                    r0 = parse_OR();
                    if (r0 === null) {
                      if (input.substr(pos, 2) === '**') {
                        r0 = '**';
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"**"');
                        }
                      }
                      if (r0 === null) {
                        if (/^[?&\^|*\/%]/.test(input.charAt(pos))) {
                          r0 = input.charAt(pos);
                          pos++;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('[?&\\^|*\\/%]');
                          }
                        }
                        if (r0 === null) {
                          r2 = pos;
                          if (input.charCodeAt(pos) === 43) {
                            r3 = '+';
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('"+"');
                            }
                          }
                          if (r3 !== null) {
                            r5 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 43) {
                              r4 = '+';
                              pos++;
                            } else {
                              r4 = null;
                              if (reportFailures === 0) {
                                matchFailed('"+"');
                              }
                            }
                            reportFailures--;
                            if (r4 === null) {
                              r4 = '';
                            } else {
                              r4 = null;
                              pos = r5;
                            }
                            if (r4 !== null) {
                              r0 = [
                                r3,
                                r4
                              ];
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                          if (r0 === null) {
                            r2 = pos;
                            if (input.charCodeAt(pos) === 45) {
                              r3 = '-';
                              pos++;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('"-"');
                              }
                            }
                            if (r3 !== null) {
                              r5 = pos;
                              reportFailures++;
                              if (input.charCodeAt(pos) === 45) {
                                r4 = '-';
                                pos++;
                              } else {
                                r4 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"-"');
                                }
                              }
                              reportFailures--;
                              if (r4 === null) {
                                r4 = '';
                              } else {
                                r4 = null;
                                pos = r5;
                              }
                              if (r4 !== null) {
                                r0 = [
                                  r3,
                                  r4
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                            if (r0 === null) {
                              if (input.substr(pos, 2) === '<<') {
                                r0 = '<<';
                                pos += 2;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"<<"');
                                }
                              }
                              if (r0 === null) {
                                if (input.substr(pos, 3) === '>>>') {
                                  r0 = '>>>';
                                  pos += 3;
                                } else {
                                  r0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('">>>"');
                                  }
                                }
                                if (r0 === null) {
                                  if (input.substr(pos, 2) === '>>') {
                                    r0 = '>>';
                                    pos += 2;
                                  } else {
                                    r0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('">>"');
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_existsAssignmentOp() {
              var cacheKey = 'existsAssignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 2) === '?=') {
                    r5 = '?=';
                    pos += 2;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpression();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpression();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentExpressionNoImplicitObjectCall() {
              var cacheKey = 'assignmentExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_assignmentOpNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_compoundAssignmentOpNoImplicitObjectCall();
                if (r0 === null) {
                  r0 = parse_existsAssignmentOpNoImplicitObjectCall();
                  if (r0 === null) {
                    r0 = parse_binaryExpressionNoImplicitObjectCall();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentOpNoImplicitObjectCall() {
              var cacheKey = 'assignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    reportFailures++;
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    reportFailures--;
                    if (r6 === null) {
                      r6 = '';
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpressionNoImplicitObjectCall();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.AssignOp(left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_compoundAssignmentOpNoImplicitObjectCall() {
              var cacheKey = 'compoundAssignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 63) {
                    r5 = '?';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  reportFailures--;
                  if (r5 === null) {
                    r5 = '';
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  if (r5 !== null) {
                    r6 = parse_CompoundAssignmentOperators();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 61) {
                        r7 = '=';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"="');
                        }
                      }
                      if (r7 !== null) {
                        r9 = pos;
                        r10 = pos;
                        r11 = parse_TERMINDENT();
                        if (r11 !== null) {
                          r12 = parse_secondaryExpressionNoImplicitObjectCall();
                          if (r12 !== null) {
                            r13 = parse_DEDENT();
                            if (r13 !== null) {
                              r8 = [
                                r11,
                                r12,
                                r13
                              ];
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                        if (r8 !== null) {
                          reportedPos = r9;
                          r8 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r8 === null) {
                          pos = r9;
                        }
                        if (r8 === null) {
                          r9 = pos;
                          r10 = pos;
                          r11 = parse_TERMINATOR();
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_secondaryExpressionNoImplicitObjectCall();
                              if (r13 !== null) {
                                r8 = [
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r10;
                              }
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                          if (r8 !== null) {
                            reportedPos = r9;
                            r8 = function (e) {
                              return e;
                            }(r13);
                          }
                          if (r8 === null) {
                            pos = r9;
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, op, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
                }(r3, r6, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_existsAssignmentOpNoImplicitObjectCall() {
              var cacheKey = 'existsAssignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 2) === '?=') {
                    r5 = '?=';
                    pos += 2;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpressionNoImplicitObjectCall();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryExpression() {
              var cacheKey = 'binaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_prefixExpression();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = pos;
                r8 = parse__();
                if (r8 !== null) {
                  r9 = parse_binaryOperator();
                  if (r9 !== null) {
                    r10 = parse_TERMINATOR();
                    r10 = r10 !== null ? r10 : '';
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        r12 = parse_expressionworthy();
                        if (r12 === null) {
                          r12 = parse_prefixExpression();
                        }
                        if (r12 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (o, e) {
                    return [
                      o,
                      e
                    ];
                  }(r9, r12);
                }
                if (r5 === null) {
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = pos;
                  r8 = parse__();
                  if (r8 !== null) {
                    r9 = parse_binaryOperator();
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_expressionworthy();
                          if (r12 === null) {
                            r12 = parse_prefixExpression();
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (o, e) {
                      return [
                        o,
                        e
                      ];
                    }(r9, r12);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, rights) {
                  switch (rights.length) {
                  case 0:
                    return left;
                  case 1:
                    return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                  default:
                    return rp(foldBinaryExpr([].concat.apply([left], rights)));
                  }
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryOperator() {
              var cacheKey = 'binaryOperator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignmentOperators();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                if (input.charCodeAt(pos) === 61) {
                  r4 = '=';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"="');
                  }
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                if (input.substr(pos, 2) === '<=') {
                  r0 = '<=';
                  pos += 2;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"<="');
                  }
                }
                if (r0 === null) {
                  if (input.substr(pos, 2) === '>=') {
                    r0 = '>=';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('">="');
                    }
                  }
                  if (r0 === null) {
                    if (input.charCodeAt(pos) === 60) {
                      r0 = '<';
                      pos++;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"<"');
                      }
                    }
                    if (r0 === null) {
                      if (input.charCodeAt(pos) === 62) {
                        r0 = '>';
                        pos++;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('">"');
                        }
                      }
                      if (r0 === null) {
                        if (input.substr(pos, 2) === '==') {
                          r0 = '==';
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"=="');
                          }
                        }
                        if (r0 === null) {
                          r0 = parse_IS();
                          if (r0 === null) {
                            if (input.substr(pos, 2) === '!=') {
                              r0 = '!=';
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed('"!="');
                              }
                            }
                            if (r0 === null) {
                              r0 = parse_ISNT();
                              if (r0 === null) {
                                r0 = parse_EXTENDS();
                                if (r0 === null) {
                                  r0 = parse_INSTANCEOF();
                                  if (r0 === null) {
                                    r0 = parse_IN();
                                    if (r0 === null) {
                                      r0 = parse_OF();
                                      if (r0 === null) {
                                        r1 = pos;
                                        r2 = pos;
                                        r3 = parse_NOT();
                                        if (r3 !== null) {
                                          r4 = parse__();
                                          if (r4 !== null) {
                                            r5 = parse_INSTANCEOF();
                                            if (r5 === null) {
                                              r5 = parse_IN();
                                              if (r5 === null) {
                                                r5 = parse_OF();
                                              }
                                            }
                                            if (r5 !== null) {
                                              r0 = [
                                                r3,
                                                r4,
                                                r5
                                              ];
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                        if (r0 !== null) {
                                          reportedPos = r1;
                                          r0 = function (op) {
                                            return 'not ' + op;
                                          }(r5);
                                        }
                                        if (r0 === null) {
                                          pos = r1;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryExpressionNoImplicitObjectCall() {
              var cacheKey = 'binaryExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_prefixExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = pos;
                r8 = parse__();
                if (r8 !== null) {
                  r9 = parse_binaryOperator();
                  if (r9 !== null) {
                    r10 = parse_TERMINATOR();
                    r10 = r10 !== null ? r10 : '';
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        r12 = parse_expressionworthy();
                        if (r12 === null) {
                          r12 = parse_prefixExpressionNoImplicitObjectCall();
                        }
                        if (r12 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (o, e) {
                    return [
                      o,
                      e
                    ];
                  }(r9, r12);
                }
                if (r5 === null) {
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = pos;
                  r8 = parse__();
                  if (r8 !== null) {
                    r9 = parse_binaryOperator();
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_expressionworthy();
                          if (r12 === null) {
                            r12 = parse_prefixExpressionNoImplicitObjectCall();
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (o, e) {
                      return [
                        o,
                        e
                      ];
                    }(r9, r12);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, rights) {
                  switch (rights.length) {
                  case 0:
                    return left;
                  case 1:
                    return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                  default:
                    return rp(foldBinaryExpr([].concat.apply([left], rights)));
                  }
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_prefixExpression() {
              var cacheKey = 'prefixExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r0 = parse_postfixExpression();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_DO();
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_nfe();
                    if (r5 === null) {
                      r5 = parse_expressionworthy();
                      if (r5 === null) {
                        r5 = parse_prefixExpression();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.DoOp(e));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r5 = pos;
                  r6 = parse_PrefixOperators();
                  if (r6 !== null) {
                    r7 = parse__();
                    if (r7 !== null) {
                      r4 = [
                        r6,
                        r7
                      ];
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                  if (r4 !== null) {
                    r3 = [];
                    while (r4 !== null) {
                      r3.push(r4);
                      r5 = pos;
                      r6 = parse_PrefixOperators();
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r4 = [
                            r6,
                            r7
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    }
                  } else {
                    r3 = null;
                  }
                  if (r3 !== null) {
                    r4 = parse_expressionworthy();
                    if (r4 === null) {
                      r4 = parse_prefixExpression();
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (ops, e) {
                      return rp(foldr(function (e, op) {
                        return new prefixConstructorLookup[op[0]](e);
                      }, e, ops));
                    }(r3, r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_PrefixOperators() {
              var cacheKey = 'PrefixOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.substr(pos, 2) === '++') {
                r0 = '++';
                pos += 2;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"++"');
                }
              }
              if (r0 === null) {
                if (input.substr(pos, 2) === '--') {
                  r0 = '--';
                  pos += 2;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"--"');
                  }
                }
                if (r0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    r0 = '+';
                    pos++;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"+"');
                    }
                  }
                  if (r0 === null) {
                    if (input.charCodeAt(pos) === 45) {
                      r0 = '-';
                      pos++;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"-"');
                      }
                    }
                    if (r0 === null) {
                      if (input.charCodeAt(pos) === 33) {
                        r0 = '!';
                        pos++;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"!"');
                        }
                      }
                      if (r0 === null) {
                        r0 = parse_NOT();
                        if (r0 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            r0 = '~';
                            pos++;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed('"~"');
                            }
                          }
                          if (r0 === null) {
                            r0 = parse_DO();
                            if (r0 === null) {
                              r0 = parse_TYPEOF();
                              if (r0 === null) {
                                r0 = parse_DELETE();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_nfe() {
              var cacheKey = 'nfe@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_unassignable();
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_Assignable();
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_functionLiteral();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, f) {
                  return rp(new CS.AssignOp(a, f));
                }(r4, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_prefixExpressionNoImplicitObjectCall() {
              var cacheKey = 'prefixExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r0 = parse_postfixExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_DO();
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_nfe();
                    if (r5 === null) {
                      r5 = parse_expressionworthy();
                      if (r5 === null) {
                        r5 = parse_prefixExpressionNoImplicitObjectCall();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.DoOp(e));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r5 = pos;
                  r6 = parse_PrefixOperators();
                  if (r6 !== null) {
                    r7 = parse__();
                    if (r7 !== null) {
                      r4 = [
                        r6,
                        r7
                      ];
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                  if (r4 !== null) {
                    r3 = [];
                    while (r4 !== null) {
                      r3.push(r4);
                      r5 = pos;
                      r6 = parse_PrefixOperators();
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r4 = [
                            r6,
                            r7
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    }
                  } else {
                    r3 = null;
                  }
                  if (r3 !== null) {
                    r4 = parse_expressionworthy();
                    if (r4 === null) {
                      r4 = parse_prefixExpressionNoImplicitObjectCall();
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (ops, e) {
                      return rp(foldr(function (e, op) {
                        return new prefixConstructorLookup[op[0]](e);
                      }, e, ops));
                    }(r3, r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixExpression() {
              var cacheKey = 'postfixExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_leftHandSideExpression();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_PostfixOperators();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_PostfixOperators();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, ops) {
                  return rp(foldl(function (e, op) {
                    return new postfixConstructorLookup[op](e);
                  }, e, ops));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_PostfixOperators() {
              var cacheKey = 'PostfixOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 63) {
                r0 = '?';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"?"');
                }
              }
              if (r0 === null) {
                if (input.substr(pos, 4) === '[..]') {
                  r0 = '[..]';
                  pos += 4;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"[..]"');
                  }
                }
                if (r0 === null) {
                  if (input.substr(pos, 2) === '++') {
                    r0 = '++';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"++"');
                    }
                  }
                  if (r0 === null) {
                    if (input.substr(pos, 2) === '--') {
                      r0 = '--';
                      pos += 2;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"--"');
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixExpressionNoImplicitObjectCall() {
              var cacheKey = 'postfixExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_leftHandSideExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_PostfixOperators();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_PostfixOperators();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, ops) {
                  return rp(foldl(function (e, op) {
                    return new postfixConstructorLookup[op](e);
                  }, e, ops));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_leftHandSideExpression() {
              var cacheKey = 'leftHandSideExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_callExpression();
              if (r0 === null) {
                r0 = parse_newExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argumentList() {
              var cacheKey = 'argumentList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 63) {
                r3 = '?';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"?"');
                }
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 40) {
                  r4 = '(';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"("');
                  }
                }
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_argumentListContents();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        if (input.charCodeAt(pos) === 41) {
                          r8 = ')';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('")"');
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (soaked, a) {
                  return rp({
                    op: soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication,
                    operands: [a || []]
                  });
                }(r3, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argumentListContents() {
              var cacheKey = 'argumentListContents@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_argument();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 === null) {
                    r8 = parse_TERMINATOR();
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_argument();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 === null) {
                      r8 = parse_TERMINATOR();
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_argument();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r5 = ',';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r5 === null) {
                    r5 = parse_TERMINATOR();
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_argumentListContents();
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r6 = parse_TERMINATOR();
                      r6 = r6 !== null ? r6 : '';
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (a) {
                    return a;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argument() {
              var cacheKey = 'argument@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_expression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentList() {
              var cacheKey = 'secondaryArgumentList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r6 = pos;
                if (/^[+-\/]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[+-\\/]');
                  }
                }
                if (r7 !== null) {
                  r8 = parse___();
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r5 = parse_secondaryArgument();
                  if (r5 !== null) {
                    r6 = [];
                    r8 = pos;
                    r9 = parse__();
                    if (r9 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r10 = ',';
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_TERMINATOR();
                          r12 = r12 !== null ? r12 : '';
                          if (r12 !== null) {
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_secondaryArgument();
                              if (r14 !== null) {
                                r7 = [
                                  r9,
                                  r10,
                                  r11,
                                  r12,
                                  r13,
                                  r14
                                ];
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_TERMINATOR();
                            r12 = r12 !== null ? r12 : '';
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_secondaryArgument();
                                if (r14 !== null) {
                                  r7 = [
                                    r9,
                                    r10,
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r8;
                                }
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      if (input.charCodeAt(pos) === 44) {
                        r9 = ',';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r10 = parse_TERMINDENT();
                        if (r10 !== null) {
                          r11 = parse_implicitObjectLiteral();
                          if (r11 !== null) {
                            r12 = parse_DEDENT();
                            if (r12 !== null) {
                              r7 = [
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es, obj) {
                  es = [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                  if (obj)
                    es.push(obj[2]);
                  return es;
                }(r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_implicitObjectLiteral();
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (o) {
                    return [o];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgument() {
              var cacheKey = 'secondaryArgument@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_singleLineImplicitObjectLiteral();
                if (r0 === null) {
                  r0 = parse_secondaryExpression();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_leftHandSideExpressionNoImplicitObjectCall() {
              var cacheKey = 'leftHandSideExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_callExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_newExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentListNoImplicitObjectCall() {
              var cacheKey = 'secondaryArgumentListNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r6 = pos;
                if (/^[+-\/]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[+-\\/]');
                  }
                }
                if (r7 !== null) {
                  r8 = parse___();
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r5 = parse_secondaryArgumentNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = [];
                    r8 = pos;
                    r9 = parse__();
                    if (r9 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r10 = ',';
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_TERMINATOR();
                          r12 = r12 !== null ? r12 : '';
                          if (r12 !== null) {
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_secondaryArgumentNoImplicitObjectCall();
                              if (r14 !== null) {
                                r7 = [
                                  r9,
                                  r10,
                                  r11,
                                  r12,
                                  r13,
                                  r14
                                ];
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_TERMINATOR();
                            r12 = r12 !== null ? r12 : '';
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_secondaryArgumentNoImplicitObjectCall();
                                if (r14 !== null) {
                                  r7 = [
                                    r9,
                                    r10,
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r8;
                                }
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  es = [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                  return es;
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentNoImplicitObjectCall() {
              var cacheKey = 'secondaryArgumentNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spreadNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_secondaryExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpression() {
              var cacheKey = 'callExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_memberExpression();
              if (r3 !== null) {
                r4 = parse_callExpressionAccesses();
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  if (input.charCodeAt(pos) === 63) {
                    r7 = '?';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse_secondaryArgumentList();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (fn, accesses, secondaryArgs) {
                  if (accesses)
                    fn = createMemberExpression(fn, accesses);
                  var soaked, secondaryCtor;
                  if (secondaryArgs) {
                    soaked = secondaryArgs[0];
                    secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                    fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
                  }
                  return fn;
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpressionAccesses() {
              var cacheKey = 'callExpressionAccesses@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_callExpressionAccesses();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (as) {
                  return as;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = parse_argumentList();
                if (r4 === null) {
                  r4 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r3 = [];
                  while (r4 !== null) {
                    r3.push(r4);
                    r4 = parse_argumentList();
                    if (r4 === null) {
                      r4 = parse_MemberAccessOps();
                    }
                  }
                } else {
                  r3 = null;
                }
                if (r3 !== null) {
                  r4 = parse_callExpressionAccesses();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (as, bs) {
                    return as.concat(bs || []);
                  }(r3, r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpressionNoImplicitObjectCall() {
              var cacheKey = 'callExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_memberExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_argumentList();
                if (r5 === null) {
                  r5 = parse_MemberAccessOps();
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_argumentList();
                  if (r5 === null) {
                    r5 = parse_MemberAccessOps();
                  }
                }
                if (r4 !== null) {
                  r6 = pos;
                  if (input.charCodeAt(pos) === 63) {
                    r7 = '?';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse_secondaryArgumentListNoImplicitObjectCall();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (fn, accesses, secondaryArgs) {
                  if (accesses)
                    fn = createMemberExpression(fn, accesses);
                  var soaked, secondaryCtor;
                  if (secondaryArgs) {
                    soaked = secondaryArgs[0];
                    secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                    fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
                  }
                  return fn;
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_newExpression() {
              var cacheKey = 'newExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_memberExpression();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_expressionworthy();
                    if (r5 === null) {
                      r5 = parse_newExpression();
                      if (r5 === null) {
                        r5 = parse_prefixExpression();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.NewOp(e, []));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_newExpressionNoImplicitObjectCall() {
              var cacheKey = 'newExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_memberExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_expressionworthy();
                    if (r5 === null) {
                      r5 = parse_newExpressionNoImplicitObjectCall();
                      if (r5 === null) {
                        r5 = parse_prefixExpressionNoImplicitObjectCall();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.NewOp(e, []));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberExpression() {
              var cacheKey = 'memberExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpression();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_MemberAccessOps();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  return createMemberExpression(e, accesses || []);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_memberExpression();
                    if (r5 !== null) {
                      r6 = parse_secondaryArgumentList();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e, args) {
                    return rp(new CS.NewOp(e, args));
                  }(r5, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberAccess() {
              var cacheKey = 'memberAccess@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpression();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r6 = pos;
                r7 = parse_argumentList();
                if (r7 !== null) {
                  r8 = parse_MemberAccessOps();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                if (r5 === null) {
                  r5 = parse_MemberAccessOps();
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    r7 = parse_argumentList();
                    if (r7 !== null) {
                      r8 = parse_MemberAccessOps();
                      if (r8 !== null) {
                        r5 = [
                          r7,
                          r8
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                    if (r5 === null) {
                      r5 = parse_MemberAccessOps();
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  var acc = foldl(function (memo, a) {
                      return memo.concat(a);
                    }, [], accesses);
                  return createMemberExpression(e, acc);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_MemberAccessOps() {
              var cacheKey = 'MemberAccessOps@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 46) {
                  r4 = '.';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_identifierName();
                    if (r6 !== null) {
                      r7 = [];
                      r8 = parse_MemberAccessOps();
                      while (r8 !== null) {
                        r7.push(r8);
                        r8 = parse_MemberAccessOps();
                      }
                      if (r7 !== null) {
                        r8 = parse_DEDENT();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp({
                    op: CS.MemberAccessOp,
                    operands: [e]
                  });
                }(r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINATOR();
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 46) {
                      r5 = '.';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"."');
                      }
                    }
                    if (r5 !== null) {
                      r6 = parse_TERMINATOR();
                      r6 = r6 !== null ? r6 : '';
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r8 = parse_identifierName();
                          if (r8 !== null) {
                            r0 = [
                              r3,
                              r4,
                              r5,
                              r6,
                              r7,
                              r8
                            ];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp({
                      op: CS.MemberAccessOp,
                      operands: [e]
                    });
                  }(r8);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '?.') {
                    r3 = '?.';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?."');
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r5 = parse_identifierName();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (e) {
                      return rp({
                        op: CS.SoakedMemberAccessOp,
                        operands: [e]
                      });
                    }(r5);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.substr(pos, 2) === '*.') {
                      r3 = '*.';
                      pos += 2;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"*."');
                      }
                    }
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r5 = parse_identifierName();
                        if (r5 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (e) {
                        return rp({
                          op: CS.NativeMemberAccessOp,
                          operands: [e]
                        });
                      }(r5);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.charCodeAt(pos) === 91) {
                        r3 = '[';
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"["');
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_expression();
                          if (r5 !== null) {
                            r6 = parse__();
                            if (r6 !== null) {
                              if (input.charCodeAt(pos) === 93) {
                                r7 = ']';
                                pos++;
                              } else {
                                r7 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"]"');
                                }
                              }
                              if (r7 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5,
                                  r6,
                                  r7
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function (e) {
                          return rp({
                            op: CS.DynamicMemberAccessOp,
                            operands: [e]
                          });
                        }(r5);
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        r2 = pos;
                        if (input.substr(pos, 2) === '?[') {
                          r3 = '?[';
                          pos += 2;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('"?["');
                          }
                        }
                        if (r3 !== null) {
                          r4 = parse__();
                          if (r4 !== null) {
                            r5 = parse_expression();
                            if (r5 !== null) {
                              r6 = parse__();
                              if (r6 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                  r7 = ']';
                                  pos++;
                                } else {
                                  r7 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"]"');
                                  }
                                }
                                if (r7 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function (e) {
                            return rp({
                              op: CS.SoakedDynamicMemberAccessOp,
                              operands: [e]
                            });
                          }(r5);
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          r2 = pos;
                          if (input.substr(pos, 2) === '::') {
                            r3 = '::';
                            pos += 2;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('"::"');
                            }
                          }
                          if (r3 !== null) {
                            r4 = parse__();
                            if (r4 !== null) {
                              r5 = parse_identifierName();
                              if (r5 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function (e) {
                              return rp({
                                op: CS.ProtoMemberAccessOp,
                                operands: [e]
                              });
                            }(r5);
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            r2 = pos;
                            if (input.substr(pos, 3) === '::[') {
                              r3 = '::[';
                              pos += 3;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('"::["');
                              }
                            }
                            if (r3 !== null) {
                              r4 = parse__();
                              if (r4 !== null) {
                                r5 = parse_expression();
                                if (r5 !== null) {
                                  r6 = parse__();
                                  if (r6 !== null) {
                                    if (input.charCodeAt(pos) === 93) {
                                      r7 = ']';
                                      pos++;
                                    } else {
                                      r7 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"]"');
                                      }
                                    }
                                    if (r7 !== null) {
                                      r0 = [
                                        r3,
                                        r4,
                                        r5,
                                        r6,
                                        r7
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function (e) {
                                return rp({
                                  op: CS.DynamicProtoMemberAccessOp,
                                  operands: [e]
                                });
                              }(r5);
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              r2 = pos;
                              if (input.substr(pos, 3) === '?::') {
                                r3 = '?::';
                                pos += 3;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"?::"');
                                }
                              }
                              if (r3 !== null) {
                                r4 = parse__();
                                if (r4 !== null) {
                                  r5 = parse_identifierName();
                                  if (r5 !== null) {
                                    r0 = [
                                      r3,
                                      r4,
                                      r5
                                    ];
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                              if (r0 !== null) {
                                reportedPos = r1;
                                r0 = function (e) {
                                  return rp({
                                    op: CS.SoakedProtoMemberAccessOp,
                                    operands: [e]
                                  });
                                }(r5);
                              }
                              if (r0 === null) {
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                r2 = pos;
                                if (input.substr(pos, 4) === '?::[') {
                                  r3 = '?::[';
                                  pos += 4;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"?::["');
                                  }
                                }
                                if (r3 !== null) {
                                  r4 = parse__();
                                  if (r4 !== null) {
                                    r5 = parse_expression();
                                    if (r5 !== null) {
                                      r6 = parse__();
                                      if (r6 !== null) {
                                        if (input.charCodeAt(pos) === 93) {
                                          r7 = ']';
                                          pos++;
                                        } else {
                                          r7 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"]"');
                                          }
                                        }
                                        if (r7 !== null) {
                                          r0 = [
                                            r3,
                                            r4,
                                            r5,
                                            r6,
                                            r7
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                                if (r0 !== null) {
                                  reportedPos = r1;
                                  r0 = function (e) {
                                    return rp({
                                      op: CS.SoakedDynamicProtoMemberAccessOp,
                                      operands: [e]
                                    });
                                  }(r5);
                                }
                                if (r0 === null) {
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  r2 = pos;
                                  if (input.charCodeAt(pos) === 91) {
                                    r3 = '[';
                                    pos++;
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"["');
                                    }
                                  }
                                  if (r3 !== null) {
                                    r4 = parse__();
                                    if (r4 !== null) {
                                      r5 = parse_assignmentExpression();
                                      r5 = r5 !== null ? r5 : '';
                                      if (r5 !== null) {
                                        r6 = parse__();
                                        if (r6 !== null) {
                                          if (input.substr(pos, 2) === '..') {
                                            r7 = '..';
                                            pos += 2;
                                          } else {
                                            r7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('".."');
                                            }
                                          }
                                          if (r7 !== null) {
                                            if (input.charCodeAt(pos) === 46) {
                                              r8 = '.';
                                              pos++;
                                            } else {
                                              r8 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"."');
                                              }
                                            }
                                            r8 = r8 !== null ? r8 : '';
                                            if (r8 !== null) {
                                              r9 = parse__();
                                              if (r9 !== null) {
                                                r10 = parse_assignmentExpression();
                                                r10 = r10 !== null ? r10 : '';
                                                if (r10 !== null) {
                                                  r11 = parse__();
                                                  if (r11 !== null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      r12 = ']';
                                                      pos++;
                                                    } else {
                                                      r12 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed('"]"');
                                                      }
                                                    }
                                                    if (r12 !== null) {
                                                      r0 = [
                                                        r3,
                                                        r4,
                                                        r5,
                                                        r6,
                                                        r7,
                                                        r8,
                                                        r9,
                                                        r10,
                                                        r11,
                                                        r12
                                                      ];
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                  if (r0 !== null) {
                                    reportedPos = r1;
                                    r0 = function (left, exclusive, right) {
                                      return rp({
                                        op: CS.Slice,
                                        operands: [
                                          !exclusive,
                                          left || null,
                                          right || null
                                        ]
                                      });
                                    }(r5, r8, r10);
                                  }
                                  if (r0 === null) {
                                    pos = r1;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberExpressionNoImplicitObjectCall() {
              var cacheKey = 'memberExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpressionNoImplicitObjectCall();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_MemberAccessOps();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  return createMemberExpression(e, accesses || []);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_memberExpressionNoImplicitObjectCall();
                    if (r5 !== null) {
                      r6 = parse_secondaryArgumentListNoImplicitObjectCall();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e, args) {
                    return rp(new CS.NewOp(e, args));
                  }(r5, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_primaryExpression() {
              var cacheKey = 'primaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r0 = parse_macro();
              if (r0 === null) {
                r0 = parse_Numbers();
                if (r0 === null) {
                  r0 = parse_bool();
                  if (r0 === null) {
                    r0 = parse_null();
                    if (r0 === null) {
                      r0 = parse_undefined();
                      if (r0 === null) {
                        r0 = parse_contextVar();
                        if (r0 === null) {
                          r1 = pos;
                          r0 = parse_SUPER();
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function () {
                              return rp(new CS.Super);
                            }();
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            r0 = parse_THIS();
                            if (r0 === null) {
                              if (input.charCodeAt(pos) === 64) {
                                r0 = '@';
                                pos++;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"@"');
                                }
                              }
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function () {
                                return rp(new CS.This);
                              }();
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r0 = parse_identifier();
                              if (r0 === null) {
                                r0 = parse_range();
                                if (r0 === null) {
                                  r0 = parse_arrayLiteral();
                                  if (r0 === null) {
                                    r0 = parse_objectLiteral();
                                    if (r0 === null) {
                                      r0 = parse_interpolation();
                                      if (r0 === null) {
                                        r0 = parse_JSLiteral();
                                        if (r0 === null) {
                                          r0 = parse_string();
                                          if (r0 === null) {
                                            r0 = parse_regexp();
                                            if (r0 === null) {
                                              r1 = pos;
                                              r2 = pos;
                                              if (input.charCodeAt(pos) === 40) {
                                                r3 = '(';
                                                pos++;
                                              } else {
                                                r3 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"("');
                                                }
                                              }
                                              if (r3 !== null) {
                                                r4 = parse_TERMINDENT();
                                                if (r4 !== null) {
                                                  r5 = parse_expression();
                                                  if (r5 !== null) {
                                                    r6 = parse_DEDENT();
                                                    if (r6 !== null) {
                                                      r7 = parse_TERMINATOR();
                                                      r7 = r7 !== null ? r7 : '';
                                                      if (r7 !== null) {
                                                        if (input.charCodeAt(pos) === 41) {
                                                          r8 = ')';
                                                          pos++;
                                                        } else {
                                                          r8 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed('")"');
                                                          }
                                                        }
                                                        if (r8 !== null) {
                                                          r0 = [
                                                            r3,
                                                            r4,
                                                            r5,
                                                            r6,
                                                            r7,
                                                            r8
                                                          ];
                                                        } else {
                                                          r0 = null;
                                                          pos = r2;
                                                        }
                                                      } else {
                                                        r0 = null;
                                                        pos = r2;
                                                      }
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                              if (r0 !== null) {
                                                reportedPos = r1;
                                                r0 = function (e) {
                                                  return r(e.clone());
                                                }(r5);
                                              }
                                              if (r0 === null) {
                                                pos = r1;
                                              }
                                              if (r0 === null) {
                                                r1 = pos;
                                                r2 = pos;
                                                if (input.charCodeAt(pos) === 40) {
                                                  r3 = '(';
                                                  pos++;
                                                } else {
                                                  r3 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"("');
                                                  }
                                                }
                                                if (r3 !== null) {
                                                  r4 = parse__();
                                                  if (r4 !== null) {
                                                    r5 = parse_expression();
                                                    if (r5 !== null) {
                                                      r6 = parse__();
                                                      if (r6 !== null) {
                                                        r7 = parse_TERMINATOR();
                                                        r7 = r7 !== null ? r7 : '';
                                                        if (r7 !== null) {
                                                          r8 = parse__();
                                                          if (r8 !== null) {
                                                            if (input.charCodeAt(pos) === 41) {
                                                              r9 = ')';
                                                              pos++;
                                                            } else {
                                                              r9 = null;
                                                              if (reportFailures === 0) {
                                                                matchFailed('")"');
                                                              }
                                                            }
                                                            if (r9 !== null) {
                                                              r0 = [
                                                                r3,
                                                                r4,
                                                                r5,
                                                                r6,
                                                                r7,
                                                                r8,
                                                                r9
                                                              ];
                                                            } else {
                                                              r0 = null;
                                                              pos = r2;
                                                            }
                                                          } else {
                                                            r0 = null;
                                                            pos = r2;
                                                          }
                                                        } else {
                                                          r0 = null;
                                                          pos = r2;
                                                        }
                                                      } else {
                                                        r0 = null;
                                                        pos = r2;
                                                      }
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                                if (r0 !== null) {
                                                  reportedPos = r1;
                                                  r0 = function (e) {
                                                    return r(e.clone());
                                                  }(r5);
                                                }
                                                if (r0 === null) {
                                                  pos = r1;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_contextVar() {
              var cacheKey = 'contextVar@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 64) {
                r3 = '@';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"@"');
                }
              }
              if (r3 !== null) {
                reportedPos = r4;
                r3 = function () {
                  return rp(new CS.This);
                }();
              }
              if (r3 === null) {
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, m) {
                  return rp(new CS.MemberAccessOp(a, m));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_JSLiteral() {
              var cacheKey = 'JSLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 96) {
                r3 = '`';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"`"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                r4 = [];
                if (/^[^`]/.test(input.charAt(pos))) {
                  r6 = input.charAt(pos);
                  pos++;
                } else {
                  r6 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^`]');
                  }
                }
                while (r6 !== null) {
                  r4.push(r6);
                  if (/^[^`]/.test(input.charAt(pos))) {
                    r6 = input.charAt(pos);
                    pos++;
                  } else {
                    r6 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^`]');
                    }
                  }
                }
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 96) {
                    r5 = '`';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"`"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return rp(new CS.JavaScript(d));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_spread() {
              var cacheKey = 'spread@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixExpression();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Spread(e));
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_spreadNoImplicitObjectCall() {
              var cacheKey = 'spreadNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Spread(e));
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_conditional() {
              var cacheKey = 'conditional@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_IF();
              if (r3 === null) {
                r3 = parse_UNLESS();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r7 = parse_elseClause();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, cond, body, elseClause) {
                  var constructor = 'unless' === kw ? CS.NegatedConditional : CS.Conditional;
                  if ('unless' === kw)
                    cond = new CS.LogicalNotOp(cond).g();
                  return rp(new constructor(cond, body.block, elseClause || null));
                }(r3, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_conditionalBody() {
              var cacheKey = 'conditionalBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_block();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return { block: b };
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINATOR();
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_THEN();
                    if (r5 !== null) {
                      r6 = parse__();
                      if (r6 !== null) {
                        r7 = parse_statement();
                        if (r7 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (s) {
                    return { block: s };
                  }(r7);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse__();
                  if (r3 !== null) {
                    r4 = parse_THEN();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return { block: null };
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_elseClause() {
              var cacheKey = 'elseClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINATOR();
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_ELSE();
                    if (r6 !== null) {
                      r7 = parse_functionBody();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return b;
                }(r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_while() {
              var cacheKey = 'while@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_WHILE();
              if (r3 === null) {
                r3 = parse_UNTIL();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, cond, body) {
                  var constructor = 'until' === kw ? CS.NegatedWhile : CS.While;
                  if ('until' === kw)
                    cond = new CS.LogicalNotOp(cond).g();
                  return rp(new constructor(cond, body.block));
                }(r3, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_loop() {
              var cacheKey = 'loop@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_LOOP();
              if (r3 !== null) {
                r4 = parse_conditionalBody();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body) {
                  return rp(new CS.Loop(body.block));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_try() {
              var cacheKey = 'try@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_TRY();
              if (r3 !== null) {
                r4 = parse_tryBody();
                if (r4 !== null) {
                  r5 = parse_catchClause();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_finallyClause();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body, c, f) {
                  return rp(new CS.Try(body.block, c ? c.assignee : null, c ? c.block : null, f ? f.block : null));
                }(r4, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_tryBody() {
              var cacheKey = 'tryBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_functionBody();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return { block: b };
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_catchClause() {
              var cacheKey = 'catchClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_CATCH();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_Assignable();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r8 = parse_conditionalBody();
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, body) {
                  return r({
                    block: body ? body.block : new CS.Block([]),
                    assignee: e || null
                  });
                }(r7, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_finallyClause() {
              var cacheKey = 'finallyClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_FINALLY();
                  if (r5 !== null) {
                    r6 = parse_tryBody();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body) {
                  return r({ block: body ? body.block : null });
                }(r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixin() {
              var cacheKey = 'mixin@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_MIXIN();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_WITH();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_mixinList();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse__();
                    if (r8 !== null) {
                      r9 = parse_mixinBody();
                      if (r9 !== null) {
                        r6 = [
                          r8,
                          r9
                        ];
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, mixins, body) {
                  name = name ? name[1] : null;
                  if (mixins)
                    mixins = mixins[3];
                  body = body ? body[1] : null;
                  return rp(new CS.Mixin(name, body, mixins));
                }(r4, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixinList() {
              var cacheKey = 'mixinList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_secondaryExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r9 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r8 = [
                        r10,
                        r11
                      ];
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                  } else {
                    r8 = null;
                    pos = r9;
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_secondaryExpressionNoImplicitObjectCall();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r9 = pos;
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r8 = [
                          r10,
                          r11
                        ];
                      } else {
                        r8 = null;
                        pos = r9;
                      }
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixinBody() {
              var cacheKey = 'mixinBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_objectLiteral();
              if (r0 === null) {
                r0 = parse_implicitObjectLiteral();
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_objectLiteral();
                  if (r4 === null) {
                    r4 = parse_implicitObjectLiteral();
                  }
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (t, body, d) {
                    return body;
                  }(r3, r4, r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_class() {
              var cacheKey = 'class@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_CLASS();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_EXTENDS();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse__();
                    if (r8 !== null) {
                      r9 = parse_WITH();
                      if (r9 !== null) {
                        r10 = parse__();
                        if (r10 !== null) {
                          r11 = parse_mixinList();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_mixinBody();
                        if (r10 !== null) {
                          r7 = [
                            r9,
                            r10
                          ];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, parent, mixins, body) {
                  var ctor = null;
                  name = name ? name[1] : null;
                  parent = parent ? parent[3] : null;
                  var boundMembers = [];
                  body = body ? body[1] : null;
                  if (mixins)
                    mixins = mixins[3];
                  return rp(new CS.Class(name, parent, ctor, body, mixins, boundMembers));
                }(r4, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_forOf() {
              var cacheKey = 'forOf@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
              r1 = pos;
              r2 = pos;
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse_OWN();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_Assignable();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r9 = pos;
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_Assignable();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r8 = [
                                  r10,
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r9;
                              }
                            } else {
                              r8 = null;
                              pos = r9;
                            }
                          } else {
                            r8 = null;
                            pos = r9;
                          }
                        } else {
                          r8 = null;
                          pos = r9;
                        }
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r9 = parse_OF();
                          if (r9 !== null) {
                            r10 = parse__();
                            if (r10 !== null) {
                              r11 = parse_assignmentExpressionNoImplicitObjectCall();
                              if (r11 !== null) {
                                r12 = parse__();
                                if (r12 !== null) {
                                  r14 = pos;
                                  r15 = parse_WHEN();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r17 = parse_assignmentExpressionNoImplicitObjectCall();
                                      if (r17 !== null) {
                                        r18 = parse__();
                                        if (r18 !== null) {
                                          r13 = [
                                            r15,
                                            r16,
                                            r17,
                                            r18
                                          ];
                                        } else {
                                          r13 = null;
                                          pos = r14;
                                        }
                                      } else {
                                        r13 = null;
                                        pos = r14;
                                      }
                                    } else {
                                      r13 = null;
                                      pos = r14;
                                    }
                                  } else {
                                    r13 = null;
                                    pos = r14;
                                  }
                                  r13 = r13 !== null ? r13 : '';
                                  if (r13 !== null) {
                                    r14 = parse_conditionalBody();
                                    if (r14 !== null) {
                                      r0 = [
                                        r3,
                                        r4,
                                        r5,
                                        r6,
                                        r7,
                                        r8,
                                        r9,
                                        r10,
                                        r11,
                                        r12,
                                        r13,
                                        r14
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (own, key, maybeVal, obj, maybeFilter, body) {
                  var val = maybeVal ? maybeVal[2] : null;
                  var filter = maybeFilter ? maybeFilter[2] : null;
                  return rp(new CS.ForOf(!!own, key, val, obj, filter, body.block));
                }(r5, r6, r8, r11, r13, r14);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_forIn() {
              var cacheKey = 'forIn@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
              r1 = pos;
              r2 = pos;
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r10 = pos;
                      if (input.charCodeAt(pos) === 44) {
                        r11 = ',';
                        pos++;
                      } else {
                        r11 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r11 !== null) {
                        r12 = parse__();
                        if (r12 !== null) {
                          r13 = parse_Assignable();
                          if (r13 !== null) {
                            r14 = parse__();
                            if (r14 !== null) {
                              r9 = [
                                r11,
                                r12,
                                r13,
                                r14
                              ];
                            } else {
                              r9 = null;
                              pos = r10;
                            }
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                        } else {
                          r9 = null;
                          pos = r10;
                        }
                      } else {
                        r9 = null;
                        pos = r10;
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_IN();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_assignmentExpressionNoImplicitObjectCall();
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r11 = pos;
                            r12 = parse_BY();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_assignmentExpressionNoImplicitObjectCall();
                                if (r14 !== null) {
                                  r15 = parse__();
                                  if (r15 !== null) {
                                    r10 = [
                                      r12,
                                      r13,
                                      r14,
                                      r15
                                    ];
                                  } else {
                                    r10 = null;
                                    pos = r11;
                                  }
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                              } else {
                                r10 = null;
                                pos = r11;
                              }
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            r10 = r10 !== null ? r10 : '';
                            if (r10 !== null) {
                              r12 = pos;
                              r13 = parse_WHEN();
                              if (r13 !== null) {
                                r14 = parse__();
                                if (r14 !== null) {
                                  r15 = parse_assignmentExpressionNoImplicitObjectCall();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r11 = [
                                        r13,
                                        r14,
                                        r15,
                                        r16
                                      ];
                                    } else {
                                      r11 = null;
                                      pos = r12;
                                    }
                                  } else {
                                    r11 = null;
                                    pos = r12;
                                  }
                                } else {
                                  r11 = null;
                                  pos = r12;
                                }
                              } else {
                                r11 = null;
                                pos = r12;
                              }
                              r11 = r11 !== null ? r11 : '';
                              if (r11 !== null) {
                                r12 = parse_conditionalBody();
                                if (r12 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (maybeVal, list, maybeStep, maybeFilter, body) {
                  var val = maybeVal ? maybeVal[0] : null;
                  var key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null;
                  var step = maybeStep ? maybeStep[2] : new CS.Int(1).r('1').g();
                  var filter = maybeFilter ? maybeFilter[2] : null;
                  return rp(new CS.ForIn(val, key, list, step, filter, body.block));
                }(r5, r8, r10, r11, r12);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switch() {
              var cacheKey = 'switch@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_SWITCH();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_expressionworthy();
                  if (r5 === null) {
                    r5 = parse_assignmentExpression();
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_switchBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, body) {
                  return rp(new CS.Switch(e || null, body.cases, body['else'] || null));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switchBody() {
              var cacheKey = 'switchBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_switchBlock();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return r({
                    cases: b.cases,
                    'else': b['else']
                  });
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_THEN();
                  if (r4 !== null) {
                    r5 = parse__();
                    if (r5 !== null) {
                      r6 = parse_case();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (c) {
                    return r({ cases: [c] });
                  }(r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse__();
                  if (r3 !== null) {
                    r4 = parse_THEN();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return r({ cases: [] });
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switchBlock() {
              var cacheKey = 'switchBlock@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_case();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_case();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_case();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_elseClause();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_TERMINATOR();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (c, cs, elseClause) {
                  var cases = [c].concat(cs.map(function (w) {
                      return w[3];
                    }));
                  return r({
                    cases: cases,
                    'else': elseClause ? elseClause[3] : null
                  });
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_case() {
              var cacheKey = 'case@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_WHEN();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_caseConditions();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (conditions, body) {
                  return rp(new CS.SwitchCase(conditions, body.block));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_caseConditions() {
              var cacheKey = 'caseConditions@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_assignmentExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_assignmentExpressionNoImplicitObjectCall();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_assignmentExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (c, cs) {
                  return [c].concat(cs.map(function (c) {
                    return c[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_functionLiteral() {
              var cacheKey = 'functionLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 40) {
                r5 = '(';
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed('"("');
                }
              }
              if (r5 !== null) {
                r6 = parse__();
                if (r6 !== null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINDENT();
                  if (r10 !== null) {
                    r11 = parse_parameterList();
                    if (r11 !== null) {
                      r12 = parse_DEDENT();
                      if (r12 !== null) {
                        r13 = parse_TERMINATOR();
                        if (r13 !== null) {
                          r7 = [
                            r10,
                            r11,
                            r12,
                            r13
                          ];
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = function (p) {
                      return p;
                    }(r11);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                  if (r7 === null) {
                    r7 = parse_parameterList();
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        r9 = ')';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('")"');
                        }
                      }
                      if (r9 !== null) {
                        r10 = parse__();
                        if (r10 !== null) {
                          r3 = [
                            r5,
                            r6,
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r3 = null;
                          pos = r4;
                        }
                      } else {
                        r3 = null;
                        pos = r4;
                      }
                    } else {
                      r3 = null;
                      pos = r4;
                    }
                  } else {
                    r3 = null;
                    pos = r4;
                  }
                } else {
                  r3 = null;
                  pos = r4;
                }
              } else {
                r3 = null;
                pos = r4;
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.substr(pos, 2) === '->') {
                  r4 = '->';
                  pos += 2;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"->"');
                  }
                }
                if (r4 === null) {
                  if (input.substr(pos, 2) === '=>') {
                    r4 = '=>';
                    pos += 2;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('"=>"');
                    }
                  }
                  if (r4 === null) {
                    if (input.substr(pos, 2) === '~>') {
                      r4 = '~>';
                      pos += 2;
                    } else {
                      r4 = null;
                      if (reportFailures === 0) {
                        matchFailed('"~>"');
                      }
                    }
                  }
                }
                if (r4 !== null) {
                  r5 = parse_functionBody();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (params, arrow, body) {
                  var constructor;
                  switch (arrow) {
                  case '->':
                    constructor = CS.Function;
                    break;
                  case '=>':
                    constructor = CS.BoundFunction;
                    break;
                  case '~>':
                    constructor = CS.ComputedProperty;
                    break;
                  default:
                    throw new Error('parsed function arrow ("' + arrow + '") not associated with a constructor');
                  }
                  return rp(new constructor(params && params[2] || [], body || null));
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_functionBody() {
              var cacheKey = 'functionBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_block();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return b;
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_statement();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (s) {
                    return s;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_parameter() {
              var cacheKey = 'parameter@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_secondaryExpression();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (param, default_) {
                  return rp(new CS.DefaultParam(param, default_));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r0 = parse_rest();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_rest() {
              var cacheKey = 'rest@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, rest) {
                  return rp(rest ? new CS.Rest(a) : a);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_parameterList() {
              var cacheKey = 'parameterList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_parameter();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r9 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r8 = [
                        r10,
                        r11
                      ];
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                  } else {
                    r8 = null;
                    pos = r9;
                  }
                  if (r8 === null) {
                    r8 = parse_TERMINATOR();
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_parameter();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r9 = pos;
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r8 = [
                          r10,
                          r11
                        ];
                      } else {
                        r8 = null;
                        pos = r9;
                      }
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                    if (r8 === null) {
                      r8 = parse_TERMINATOR();
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_parameter();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_range() {
              var cacheKey = 'range@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.substr(pos, 2) === '..') {
                        r7 = '..';
                        pos += 2;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('".."');
                        }
                      }
                      if (r7 !== null) {
                        if (input.charCodeAt(pos) === 46) {
                          r8 = '.';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"."');
                          }
                        }
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r10 = parse_secondaryExpression();
                            if (r10 !== null) {
                              r11 = parse__();
                              if (r11 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                  r12 = ']';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"]"');
                                  }
                                }
                                if (r12 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, exclusiveDot, right) {
                  var inclusive = !exclusiveDot;
                  return rp(new CS.Range(inclusive, left, right));
                }(r5, r8, r10);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteral() {
              var cacheKey = 'arrayLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse_arrayLiteralBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 93) {
                        r7 = ']';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"]"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ArrayInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralBody() {
              var cacheKey = 'arrayLiteralBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_arrayLiteralMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_arrayLiteralMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMemberList() {
              var cacheKey = 'arrayLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_arrayLiteralMember();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = [];
                  r7 = pos;
                  r8 = parse_arrayLiteralMemberSeparator();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_arrayLiteralMember();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10,
                            r11
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    r7 = pos;
                    r8 = parse_arrayLiteralMemberSeparator();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_arrayLiteralMember();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse_arrayLiteralMemberSeparator();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[2];
                  }));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMember() {
              var cacheKey = 'arrayLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_expression();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_TERMINDENT();
                  if (r3 !== null) {
                    r4 = parse_implicitObjectLiteral();
                    if (r4 !== null) {
                      r5 = parse_DEDENT();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (o) {
                      return o;
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMemberSeparator() {
              var cacheKey = 'arrayLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r5 = ',';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                if (r3 !== null) {
                  r4 = parse_TERMINATOR();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r5 = parse__();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_annotation() {
              var cacheKey = 'annotation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 43) {
                r3 = '+';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"+"');
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 8) === 'computed') {
                    r5 = 'computed';
                    pos += 8;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"computed"');
                    }
                  }
                  if (r5 === null) {
                    if (input.substr(pos, 8) === 'observer') {
                      r5 = 'observer';
                      pos += 8;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"observer"');
                      }
                    }
                    if (r5 === null) {
                      if (input.substr(pos, 8) === 'volatile') {
                        r5 = 'volatile';
                        pos += 8;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"volatile"');
                        }
                      }
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse___();
                    if (r8 !== null) {
                      r9 = parse_annotationParameterList();
                      if (r9 !== null) {
                        r6 = [
                          r8,
                          r9
                        ];
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r7 = parse_TERMINATOR();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r8 = parse__();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, params) {
                  var constructor;
                  switch (name) {
                  case 'computed':
                    constructor = CS.Computed;
                    break;
                  case 'observer':
                    constructor = CS.Observes;
                    break;
                  case 'volatile':
                    constructor = CS.Volatile;
                    break;
                  default:
                    throw new Error('No such annotation: ' + name);
                  }
                  if (params)
                    params = params[1];
                  return rp(new constructor(params || []));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_annotationParameterList() {
              var cacheKey = 'annotationParameterList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_propertyChain();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r8 = pos;
                r9 = parse__();
                if (r9 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r7 = [
                          r9,
                          r10,
                          r11,
                          r12
                        ];
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
                if (r7 === null) {
                  r7 = parse___();
                }
                if (r7 !== null) {
                  r8 = parse_propertyChain();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r8 = pos;
                  r9 = parse__();
                  if (r9 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r12 = parse__();
                        if (r12 !== null) {
                          r7 = [
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                  if (r7 === null) {
                    r7 = parse___();
                  }
                  if (r7 !== null) {
                    r8 = parse_propertyChain();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteral() {
              var cacheKey = 'objectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 123) {
                r3 = '{';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"{"');
                }
              }
              if (r3 !== null) {
                r4 = parse_objectLiteralBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        r7 = '}';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"}"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralBody() {
              var cacheKey = 'objectLiteralBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_objectLiteralMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_objectLiteralMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralMemberList() {
              var cacheKey = 'objectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_objectLiteralMember();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = [];
                  r7 = pos;
                  r8 = parse_arrayLiteralMemberSeparator();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_objectLiteralMember();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10,
                            r11
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    r7 = pos;
                    r8 = parse_arrayLiteralMemberSeparator();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_objectLiteralMember();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r6 = ',';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[2];
                  }));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralMember() {
              var cacheKey = 'objectLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r0 = parse_implicitObjectLiteralMember();
              if (r0 === null) {
                r1 = pos;
                r0 = parse_contextVar();
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (v) {
                    var key = p(new CS.String(v.memberName).g());
                    return rp(new CS.ObjectInitialiserMember(key, v));
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r0 = parse_ObjectInitialiserKeys();
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (v) {
                      return rp(new CS.ObjectInitialiserMember(v, v));
                    }(r0);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ObjectInitialiserKeys() {
              var cacheKey = 'ObjectInitialiserKeys@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_identifierName();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (i) {
                  return rp(new CS.Identifier(i));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r0 = parse_string();
                if (r0 === null) {
                  r0 = parse_Numbers();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteral() {
              var cacheKey = 'implicitObjectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_implicitObjectLiteralMemberList();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberList() {
              var cacheKey = 'implicitObjectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_implicitObjectLiteralMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_implicitObjectLiteralMemberSeparator();
                if (r7 !== null) {
                  r8 = parse_implicitObjectLiteralMember();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_implicitObjectLiteralMemberSeparator();
                  if (r7 !== null) {
                    r8 = parse_implicitObjectLiteralMember();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberSeparator() {
              var cacheKey = 'implicitObjectLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = parse_TERMINATOR();
              if (r2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r0 = [
                      r2,
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = parse__();
                if (r2 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r3 = ',';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse_TERMINATOR();
                    r4 = r4 !== null ? r4 : '';
                    if (r4 !== null) {
                      r5 = parse__();
                      if (r5 !== null) {
                        r0 = [
                          r2,
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMember() {
              var cacheKey = 'implicitObjectLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = [];
              r4 = parse_annotation();
              while (r4 !== null) {
                r3.push(r4);
                r4 = parse_annotation();
              }
              if (r3 !== null) {
                r4 = parse_ObjectInitialiserKeys();
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      r6 = ':';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('":"');
                      }
                    }
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_implicitObjectLiteralMemberValue();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (annotations, key, val) {
                  return rp(new CS.ObjectInitialiserMember(key, val, annotations));
                }(r3, r4, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberValue() {
              var cacheKey = 'implicitObjectLiteralMemberValue@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_singleLineImplicitObjectLiteral();
              if (r0 === null) {
                r0 = parse_expression();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_TERMINDENT();
                  if (r3 !== null) {
                    r4 = parse_expression();
                    if (r4 !== null) {
                      r5 = parse_DEDENT();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (o) {
                      return o;
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteral() {
              var cacheKey = 'singleLineImplicitObjectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_singleLineImplicitObjectLiteralMemberList();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteralMemberList() {
              var cacheKey = 'singleLineImplicitObjectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_implicitObjectLiteralMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
                if (r7 !== null) {
                  r8 = parse_implicitObjectLiteralMember();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
                  if (r7 !== null) {
                    r8 = parse_implicitObjectLiteralMember();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteralMemberSeparator() {
              var cacheKey = 'singleLineImplicitObjectLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = parse__();
              if (r2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r0 = [
                      r2,
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_macro() {
              var cacheKey = 'macro@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              if (input.substr(pos, 8) === '__LINE__') {
                r0 = '__LINE__';
                pos += 8;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"__LINE__"');
                }
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Int(line()));
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                if (input.substr(pos, 12) === '__FILENAME__') {
                  r0 = '__FILENAME__';
                  pos += 12;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"__FILENAME__"');
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return rp(new CS.String(options.inputSource || ''));
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.substr(pos, 8) === '__DATE__') {
                    r0 = '__DATE__';
                    pos += 8;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"__DATE__"');
                    }
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return rp(new CS.String(new Date().toDateString().slice(4)));
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.substr(pos, 8) === '__TIME__') {
                      r0 = '__TIME__';
                      pos += 8;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"__TIME__"');
                      }
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function () {
                        return rp(new CS.String(new Date().toTimeString().slice(0, 8)));
                      }();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.substr(pos, 14) === '__DATETIMEMS__') {
                        r0 = '__DATETIMEMS__';
                        pos += 14;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"__DATETIMEMS__"');
                        }
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function () {
                          return rp(new CS.Int(+new Date));
                        }();
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.substr(pos, 18) === '__COFFEE_VERSION__') {
                          r0 = '__COFFEE_VERSION__';
                          pos += 18;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"__COFFEE_VERSION__"');
                          }
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function () {
                            return rp(new CS.String(require('/package.json', module).version));
                          }();
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_bool() {
              var cacheKey = 'bool@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_TRUE();
              if (r0 === null) {
                r0 = parse_YES();
                if (r0 === null) {
                  r0 = parse_ON();
                }
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Bool(true));
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r0 = parse_FALSE();
                if (r0 === null) {
                  r0 = parse_NO();
                  if (r0 === null) {
                    r0 = parse_OFF();
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return rp(new CS.Bool(false));
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_Numbers() {
              var cacheKey = 'Numbers@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === '0b') {
                r3 = '0b';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"0b"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                r6 = parse_bit();
                if (r6 !== null) {
                  r4 = [];
                  while (r6 !== null) {
                    r4.push(r6);
                    r6 = parse_bit();
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (bs) {
                  return rp(new CS.Int(parseInt(bs, 2)));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 2) === '0o') {
                  r3 = '0o';
                  pos += 2;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"0o"');
                  }
                }
                if (r3 !== null) {
                  r5 = pos;
                  r6 = parse_octalDigit();
                  if (r6 !== null) {
                    r4 = [];
                    while (r6 !== null) {
                      r4.push(r6);
                      r6 = parse_octalDigit();
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    r4 = input.substring(pos, r5);
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (os) {
                    return rp(new CS.Int(parseInt(os, 8)));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '0x') {
                    r3 = '0x';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"0x"');
                    }
                  }
                  if (r3 !== null) {
                    r5 = pos;
                    r6 = parse_hexDigit();
                    if (r6 !== null) {
                      r4 = [];
                      while (r6 !== null) {
                        r4.push(r6);
                        r6 = parse_hexDigit();
                      }
                    } else {
                      r4 = null;
                    }
                    if (r4 !== null) {
                      r4 = input.substring(pos, r5);
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (hs) {
                      return rp(new CS.Int(parseInt(hs, 16)));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    r3 = parse_decimal();
                    if (r3 !== null) {
                      if (/^[eE]/.test(input.charAt(pos))) {
                        r4 = input.charAt(pos);
                        pos++;
                      } else {
                        r4 = null;
                        if (reportFailures === 0) {
                          matchFailed('[eE]');
                        }
                      }
                      if (r4 !== null) {
                        if (/^[+\-]/.test(input.charAt(pos))) {
                          r5 = input.charAt(pos);
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('[+\\-]');
                          }
                        }
                        r5 = r5 !== null ? r5 : '';
                        if (r5 !== null) {
                          r6 = parse_decimal();
                          if (r6 !== null) {
                            r0 = [
                              r3,
                              r4,
                              r5,
                              r6
                            ];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (base, e, sign, exponent) {
                        return rp(new CS.Float(parseFloat('' + base.data + e + sign + exponent.data, 10)));
                      }(r3, r4, r5, r6);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r0 = parse_decimal();
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_decimal() {
              var cacheKey = 'decimal@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_integer();
              if (r3 !== null) {
                r5 = pos;
                r6 = pos;
                if (input.charCodeAt(pos) === 46) {
                  r7 = '.';
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r7 !== null) {
                  r9 = parse_decimalDigit();
                  if (r9 !== null) {
                    r8 = [];
                    while (r9 !== null) {
                      r8.push(r9);
                      r9 = parse_decimalDigit();
                    }
                  } else {
                    r8 = null;
                  }
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (integral, fractional) {
                  return fractional ? rp(new CS.Float(parseFloat(integral + fractional, 10))) : rp(new CS.Int(+integral));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_integer() {
              var cacheKey = 'integer@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              if (input.charCodeAt(pos) === 48) {
                r0 = '0';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"0"');
                }
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (/^[1-9]/.test(input.charAt(pos))) {
                  r3 = input.charAt(pos);
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('[1-9]');
                  }
                }
                if (r3 !== null) {
                  r4 = [];
                  r5 = parse_decimalDigit();
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_decimalDigit();
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_decimalDigit() {
              var cacheKey = 'decimalDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-9]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_hexDigit() {
              var cacheKey = 'hexDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9a-fA-F]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_octalDigit() {
              var cacheKey = 'octalDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-7]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-7]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_bit() {
              var cacheKey = 'bit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[01]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[01]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_string() {
              var cacheKey = 'string@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '"""') {
                r3 = '"""';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\"\\"\\""');
                }
              }
              if (r3 !== null) {
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r5 = "'";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\'"');
                    }
                  }
                  if (r5 === null) {
                    r6 = pos;
                    r7 = pos;
                    if (input.charCodeAt(pos) === 34) {
                      r8 = '"';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r9 = '"';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r11 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        reportFailures--;
                        if (r10 === null) {
                          r10 = '';
                        } else {
                          r10 = null;
                          pos = r11;
                        }
                        if (r10 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                    if (r5 !== null) {
                      r5 = input.substring(pos, r6);
                    }
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_stringData();
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r5 = "'";
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r8 = '"';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r8 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r9 = '"';
                            pos++;
                          } else {
                            r9 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r11 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r10 = '"';
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r10 === null) {
                              r10 = '';
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            if (r10 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          r5 = input.substring(pos, r6);
                        }
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '"""') {
                    r5 = '"""';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\"\\"\\""');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 3) === "'''") {
                  r3 = "'''";
                  pos += 3;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'''\"");
                  }
                }
                if (r3 !== null) {
                  r5 = parse_stringData();
                  if (r5 === null) {
                    if (input.charCodeAt(pos) === 34) {
                      r5 = '"';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 35) {
                        r5 = '#';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.charCodeAt(pos) === 39) {
                          r8 = "'";
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                        if (r8 !== null) {
                          if (input.charCodeAt(pos) === 39) {
                            r9 = "'";
                            pos++;
                          } else {
                            r9 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\'"');
                            }
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r11 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 39) {
                              r10 = "'";
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                            reportFailures--;
                            if (r10 === null) {
                              r10 = '';
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            if (r10 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          r5 = input.substring(pos, r6);
                        }
                      }
                    }
                  }
                  if (r5 !== null) {
                    r4 = [];
                    while (r5 !== null) {
                      r4.push(r5);
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 34) {
                          r5 = '"';
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 35) {
                            r5 = '#';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                          if (r5 === null) {
                            r6 = pos;
                            r7 = pos;
                            if (input.charCodeAt(pos) === 39) {
                              r8 = "'";
                              pos++;
                            } else {
                              r8 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                            if (r8 !== null) {
                              if (input.charCodeAt(pos) === 39) {
                                r9 = "'";
                                pos++;
                              } else {
                                r9 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\'"');
                                }
                              }
                              r9 = r9 !== null ? r9 : '';
                              if (r9 !== null) {
                                r11 = pos;
                                reportFailures++;
                                if (input.charCodeAt(pos) === 39) {
                                  r10 = "'";
                                  pos++;
                                } else {
                                  r10 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\'"');
                                  }
                                }
                                reportFailures--;
                                if (r10 === null) {
                                  r10 = '';
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                                if (r10 !== null) {
                                  r5 = [
                                    r8,
                                    r9,
                                    r10
                                  ];
                                } else {
                                  r5 = null;
                                  pos = r7;
                                }
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                            if (r5 !== null) {
                              r5 = input.substring(pos, r6);
                            }
                          }
                        }
                      }
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    if (input.substr(pos, 3) === "'''") {
                      r5 = "'''";
                      pos += 3;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'''\"");
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d) {
                    return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.charCodeAt(pos) === 34) {
                    r3 = '"';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\""');
                    }
                  }
                  if (r3 !== null) {
                    r4 = [];
                    r5 = parse_stringData();
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r5 = "'";
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                    }
                    while (r5 !== null) {
                      r4.push(r5);
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r5 = "'";
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                    }
                    if (r4 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r5 = '"';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (d) {
                      return rp(new CS.String(d.join('')));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.charCodeAt(pos) === 39) {
                      r3 = "'";
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\'"');
                      }
                    }
                    if (r3 !== null) {
                      r4 = [];
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 34) {
                          r5 = '"';
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 35) {
                            r5 = '#';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                        }
                      }
                      while (r5 !== null) {
                        r4.push(r5);
                        r5 = parse_stringData();
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 34) {
                            r5 = '"';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          if (r5 === null) {
                            if (input.charCodeAt(pos) === 35) {
                              r5 = '#';
                              pos++;
                            } else {
                              r5 = null;
                              if (reportFailures === 0) {
                                matchFailed('"#"');
                              }
                            }
                          }
                        }
                      }
                      if (r4 !== null) {
                        if (input.charCodeAt(pos) === 39) {
                          r5 = "'";
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                        if (r5 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (d) {
                        return rp(new CS.String(d.join('')));
                      }(r4);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_stringData() {
              var cacheKey = 'stringData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              if (/^[^"'\\#]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[^"\'\\\\#]');
                }
              }
              if (r0 === null) {
                r0 = parse_UnicodeEscapeSequence();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '\\x') {
                    r3 = '\\x';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\\\x"');
                    }
                  }
                  if (r3 !== null) {
                    r5 = pos;
                    r6 = pos;
                    r7 = parse_hexDigit();
                    if (r7 !== null) {
                      r8 = parse_hexDigit();
                      if (r8 !== null) {
                        r4 = [
                          r7,
                          r8
                        ];
                      } else {
                        r4 = null;
                        pos = r6;
                      }
                    } else {
                      r4 = null;
                      pos = r6;
                    }
                    if (r4 !== null) {
                      r4 = input.substring(pos, r5);
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (h) {
                      return String.fromCharCode(parseInt(h, 16));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.substr(pos, 2) === '\\0') {
                      r3 = '\\0';
                      pos += 2;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\\\0"');
                      }
                    }
                    if (r3 !== null) {
                      r5 = pos;
                      reportFailures++;
                      r4 = parse_decimalDigit();
                      reportFailures--;
                      if (r4 === null) {
                        r4 = '';
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                      if (r4 !== null) {
                        r0 = [
                          r3,
                          r4
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function () {
                        return '\0';
                      }();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.substr(pos, 2) === '\\0') {
                        r3 = '\\0';
                        pos += 2;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\\\0"');
                        }
                      }
                      if (r3 !== null) {
                        r5 = pos;
                        reportFailures++;
                        r4 = parse_decimalDigit();
                        reportFailures--;
                        if (r4 !== null) {
                          r4 = '';
                          pos = r5;
                        } else {
                          r4 = null;
                        }
                        if (r4 !== null) {
                          r0 = [
                            r3,
                            r4
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function () {
                          throw new SyntaxError(['string data'], 'octal escape sequence', offset(), line(), column());
                        }();
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.substr(pos, 2) === '\\b') {
                          r0 = '\\b';
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\\\b"');
                          }
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function () {
                            return '\b';
                          }();
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.substr(pos, 2) === '\\t') {
                            r0 = '\\t';
                            pos += 2;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\\\t"');
                            }
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function () {
                              return '\t';
                            }();
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.substr(pos, 2) === '\\n') {
                              r0 = '\\n';
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\\\n"');
                              }
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function () {
                                return '\n';
                              }();
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              if (input.substr(pos, 2) === '\\v') {
                                r0 = '\\v';
                                pos += 2;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\\\v"');
                                }
                              }
                              if (r0 !== null) {
                                reportedPos = r1;
                                r0 = function () {
                                  return '\x0B';
                                }();
                              }
                              if (r0 === null) {
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                if (input.substr(pos, 2) === '\\f') {
                                  r0 = '\\f';
                                  pos += 2;
                                } else {
                                  r0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\\\f"');
                                  }
                                }
                                if (r0 !== null) {
                                  reportedPos = r1;
                                  r0 = function () {
                                    return '\f';
                                  }();
                                }
                                if (r0 === null) {
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  if (input.substr(pos, 2) === '\\r') {
                                    r0 = '\\r';
                                    pos += 2;
                                  } else {
                                    r0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"\\\\r"');
                                    }
                                  }
                                  if (r0 !== null) {
                                    reportedPos = r1;
                                    r0 = function () {
                                      return '\r';
                                    }();
                                  }
                                  if (r0 === null) {
                                    pos = r1;
                                  }
                                  if (r0 === null) {
                                    r1 = pos;
                                    r2 = pos;
                                    if (input.charCodeAt(pos) === 92) {
                                      r3 = '\\';
                                      pos++;
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"\\\\"');
                                      }
                                    }
                                    if (r3 !== null) {
                                      if (input.length > pos) {
                                        r4 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        r4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('any character');
                                        }
                                      }
                                      if (r4 !== null) {
                                        r0 = [
                                          r3,
                                          r4
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                    if (r0 !== null) {
                                      reportedPos = r1;
                                      r0 = function (c) {
                                        return c;
                                      }(r4);
                                    }
                                    if (r0 === null) {
                                      pos = r1;
                                    }
                                    if (r0 === null) {
                                      r1 = pos;
                                      r2 = pos;
                                      if (input.charCodeAt(pos) === 35) {
                                        r3 = '#';
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"#"');
                                        }
                                      }
                                      if (r3 !== null) {
                                        r5 = pos;
                                        reportFailures++;
                                        if (input.charCodeAt(pos) === 123) {
                                          r4 = '{';
                                          pos++;
                                        } else {
                                          r4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"{"');
                                          }
                                        }
                                        reportFailures--;
                                        if (r4 === null) {
                                          r4 = '';
                                        } else {
                                          r4 = null;
                                          pos = r5;
                                        }
                                        if (r4 !== null) {
                                          r0 = [
                                            r3,
                                            r4
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                      if (r0 !== null) {
                                        reportedPos = r1;
                                        r0 = function (c) {
                                          return c;
                                        }(r3);
                                      }
                                      if (r0 === null) {
                                        pos = r1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_interpolation() {
              var cacheKey = 'interpolation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '"""') {
                r3 = '"""';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\"\\"\\""');
                }
              }
              if (r3 !== null) {
                r6 = pos;
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r7 = "'";
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\'"');
                    }
                  }
                  if (r7 === null) {
                    r8 = pos;
                    r9 = pos;
                    if (input.charCodeAt(pos) === 34) {
                      r10 = '"';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r10 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r11 = '"';
                        pos++;
                      } else {
                        r11 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r13 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 34) {
                          r12 = '"';
                          pos++;
                        } else {
                          r12 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        reportFailures--;
                        if (r12 === null) {
                          r12 = '';
                        } else {
                          r12 = null;
                          pos = r13;
                        }
                        if (r12 !== null) {
                          r7 = [
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                    if (r7 !== null) {
                      r7 = input.substring(pos, r8);
                    }
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r7 = "'";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r10 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r11 = '"';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r13 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r12 = '"';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r12 === null) {
                              r12 = '';
                            } else {
                              r12 = null;
                              pos = r13;
                            }
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          r7 = input.substring(pos, r8);
                        }
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (d) {
                    return rp(new CS.String(d.join('')));
                  }(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  r7 = pos;
                  if (input.substr(pos, 2) === '#{') {
                    r8 = '#{';
                    pos += 2;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('"#{"');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_expression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos) === 125) {
                            r12 = '}';
                            pos++;
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed('"}"');
                            }
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (e) {
                      return e;
                    }(r10);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r7 = "'";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r10 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r11 = '"';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r13 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r12 = '"';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r12 === null) {
                              r12 = '';
                            } else {
                              r12 = null;
                              pos = r13;
                            }
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          r7 = input.substring(pos, r8);
                        }
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        r7 = parse_stringData();
                        if (r7 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            r7 = "'";
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\'"');
                            }
                          }
                          if (r7 === null) {
                            r8 = pos;
                            r9 = pos;
                            if (input.charCodeAt(pos) === 34) {
                              r10 = '"';
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            if (r10 !== null) {
                              if (input.charCodeAt(pos) === 34) {
                                r11 = '"';
                                pos++;
                              } else {
                                r11 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\""');
                                }
                              }
                              r11 = r11 !== null ? r11 : '';
                              if (r11 !== null) {
                                r13 = pos;
                                reportFailures++;
                                if (input.charCodeAt(pos) === 34) {
                                  r12 = '"';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\""');
                                  }
                                }
                                reportFailures--;
                                if (r12 === null) {
                                  r12 = '';
                                } else {
                                  r12 = null;
                                  pos = r13;
                                }
                                if (r12 !== null) {
                                  r7 = [
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r9;
                                }
                              } else {
                                r7 = null;
                                pos = r9;
                              }
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                            if (r7 !== null) {
                              r7 = input.substring(pos, r8);
                            }
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (d) {
                        return rp(new CS.String(d.join('')));
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                    if (r5 === null) {
                      r6 = pos;
                      r7 = pos;
                      if (input.substr(pos, 2) === '#{') {
                        r8 = '#{';
                        pos += 2;
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#{"');
                        }
                      }
                      if (r8 !== null) {
                        r9 = parse__();
                        if (r9 !== null) {
                          r10 = parse_expression();
                          if (r10 !== null) {
                            r11 = parse__();
                            if (r11 !== null) {
                              if (input.charCodeAt(pos) === 125) {
                                r12 = '}';
                                pos++;
                              } else {
                                r12 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"}"');
                                }
                              }
                              if (r12 !== null) {
                                r5 = [
                                  r8,
                                  r9,
                                  r10,
                                  r11,
                                  r12
                                ];
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (e) {
                          return e;
                        }(r10);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '"""') {
                    r5 = '"""';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\"\\"\\""');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (es) {
                  return rp(createInterpolation(stripLeadingWhitespaceInterpolation(es)));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 34) {
                  r3 = '"';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\""');
                  }
                }
                if (r3 !== null) {
                  r6 = pos;
                  r7 = parse_stringData();
                  if (r7 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      r7 = "'";
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\'"');
                      }
                    }
                  }
                  if (r7 !== null) {
                    r5 = [];
                    while (r7 !== null) {
                      r5.push(r7);
                      r7 = parse_stringData();
                      if (r7 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r7 = "'";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                    }
                  } else {
                    r5 = null;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (d) {
                      return rp(new CS.String(d.join('')));
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r6 = pos;
                    r7 = pos;
                    if (input.substr(pos, 2) === '#{') {
                      r8 = '#{';
                      pos += 2;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#{"');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_expression();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            if (input.charCodeAt(pos) === 125) {
                              r12 = '}';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"}"');
                              }
                            }
                            if (r12 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (e) {
                        return e;
                      }(r10);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                  if (r5 !== null) {
                    r4 = [];
                    while (r5 !== null) {
                      r4.push(r5);
                      r6 = pos;
                      r7 = parse_stringData();
                      if (r7 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r7 = "'";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          r7 = parse_stringData();
                          if (r7 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              r7 = "'";
                              pos++;
                            } else {
                              r7 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (d) {
                          return rp(new CS.String(d.join('')));
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.substr(pos, 2) === '#{') {
                          r8 = '#{';
                          pos += 2;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#{"');
                          }
                        }
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r10 = parse_expression();
                            if (r10 !== null) {
                              r11 = parse__();
                              if (r11 !== null) {
                                if (input.charCodeAt(pos) === 125) {
                                  r12 = '}';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"}"');
                                  }
                                }
                                if (r12 !== null) {
                                  r5 = [
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r5 = null;
                                  pos = r7;
                                }
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          reportedPos = r6;
                          r5 = function (e) {
                            return e;
                          }(r10);
                        }
                        if (r5 === null) {
                          pos = r6;
                        }
                      }
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 34) {
                      r5 = '"';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (es) {
                    return rp(createInterpolation(es));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_regexp() {
              var cacheKey = 'regexp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '///') {
                r3 = '///';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"///"');
                }
              }
              if (r3 !== null) {
                r6 = pos;
                if (/^[ \r\n]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[ \\r\\n]');
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[ \r\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[ \\r\\n]');
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function () {
                    return [rp(new CS.String('').g())];
                  }();
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                    r7 = input.charAt(pos);
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\/#[ \\r\\n]');
                    }
                  }
                  if (r7 !== null) {
                    r5 = [];
                    while (r7 !== null) {
                      r5.push(r7);
                      if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\\\\\/#[ \\r\\n]');
                        }
                      }
                    }
                  } else {
                    r5 = null;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (s) {
                      return [rp(new CS.String(s.join('')).g())];
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r5 = parse_hereregexpData();
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    if (/^[ \r\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[ \\r\\n]');
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        if (/^[ \r\n]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[ \\r\\n]');
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function () {
                        return [rp(new CS.String('').g())];
                      }();
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                    if (r5 === null) {
                      r6 = pos;
                      if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\\\\\/#[ \\r\\n]');
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                            r7 = input.charAt(pos);
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('[^\\\\\\/#[ \\r\\n]');
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (s) {
                          return [rp(new CS.String(s.join('')).g())];
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                      if (r5 === null) {
                        r5 = parse_hereregexpData();
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '///') {
                    r5 = '///';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"///"');
                    }
                  }
                  if (r5 !== null) {
                    r6 = [];
                    if (/^[gimy]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[gimy]');
                      }
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      if (/^[gimy]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[gimy]');
                        }
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (es, flags) {
                  if (!isValidRegExpFlags(flags))
                    throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
                  if (!flags)
                    flags = [];
                  var interp = createInterpolation(foldl(function (memo, e) {
                      return memo.concat(e);
                    }, [], es));
                  if (interp instanceof CS.String)
                    return p(new CS.RegExp(interp.data, flags));
                  return rp(new CS.HeregExp(interp, flags));
                }(r4, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 47) {
                  r3 = '/';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"/"');
                  }
                }
                if (r3 !== null) {
                  r4 = [];
                  r5 = parse_regexpData();
                  if (r5 === null) {
                    r6 = pos;
                    if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^\\/\\\\[\\n]');
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[^\\/\\\\[\\n]');
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (d) {
                        return d.join('');
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_regexpData();
                    if (r5 === null) {
                      r6 = pos;
                      if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\/\\\\[\\n]');
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                            r7 = input.charAt(pos);
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('[^\\/\\\\[\\n]');
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (d) {
                          return d.join('');
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                    }
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 47) {
                      r5 = '/';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"/"');
                      }
                    }
                    if (r5 !== null) {
                      r6 = [];
                      if (/^[gimy]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[gimy]');
                        }
                      }
                      while (r7 !== null) {
                        r6.push(r7);
                        if (/^[gimy]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[gimy]');
                          }
                        }
                      }
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d, flags) {
                    if (!isValidRegExpFlags(flags))
                      throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
                    return rp(new CS.RegExp(d.join(''), flags));
                  }(r4, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_regexpData() {
              var cacheKey = 'regexpData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = [];
                if (/^[^\\\]\n]/.test(input.charAt(pos))) {
                  r5 = input.charAt(pos);
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^\\\\\\]\\n]');
                  }
                }
                if (r5 === null) {
                  r5 = parse_regexpData();
                }
                while (r5 !== null) {
                  r4.push(r5);
                  if (/^[^\\\]\n]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\]\\n]');
                    }
                  }
                  if (r5 === null) {
                    r5 = parse_regexpData();
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 93) {
                    r5 = ']';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"]"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return '[' + d.join('') + ']';
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 92) {
                  r3 = '\\';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\\\"');
                  }
                }
                if (r3 !== null) {
                  if (input.length > pos) {
                    r4 = input.charAt(pos);
                    pos++;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_hereregexpData() {
              var cacheKey = 'hereregexpData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r5 = parse_hereregexpData();
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (h) {
                    return h[0];
                  }(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  if (/^[^\\\/\]]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\/\\]]');
                    }
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (s) {
                      return p(new CS.String(s));
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r5 = parse_hereregexpData();
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (h) {
                      return h[0];
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r6 = pos;
                    if (/^[^\\\/\]]/.test(input.charAt(pos))) {
                      r5 = input.charAt(pos);
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^\\\\\\/\\]]');
                      }
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (s) {
                        return p(new CS.String(s));
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 93) {
                    r5 = ']';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"]"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return [p(new CS.String('['))].concat(d || []).concat([p(new CS.String(']'))]);
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = pos;
                if (input.charCodeAt(pos) === 92) {
                  r4 = '\\';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\\\"');
                  }
                }
                if (r4 !== null) {
                  if (input.length > pos) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r3;
                  }
                } else {
                  r0 = null;
                  pos = r3;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r2);
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d) {
                    return [rp(new CS.String(d))];
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = pos;
                  if (input.charCodeAt(pos) === 47) {
                    r4 = '/';
                    pos++;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('"/"');
                    }
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 47) {
                      r5 = '/';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"/"');
                      }
                    }
                    r5 = r5 !== null ? r5 : '';
                    if (r5 !== null) {
                      r7 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 47) {
                        r6 = '/';
                        pos++;
                      } else {
                        r6 = null;
                        if (reportFailures === 0) {
                          matchFailed('"/"');
                        }
                      }
                      reportFailures--;
                      if (r6 === null) {
                        r6 = '';
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                      if (r6 !== null) {
                        r0 = [
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r3;
                      }
                    } else {
                      r0 = null;
                      pos = r3;
                    }
                  } else {
                    r0 = null;
                    pos = r3;
                  }
                  if (r0 !== null) {
                    r0 = input.substring(pos, r2);
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (s) {
                      return [rp(new CS.String(s))];
                    }(r0);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.charCodeAt(pos) === 35) {
                      r3 = '#';
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#"');
                      }
                    }
                    if (r3 !== null) {
                      r5 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 123) {
                        r4 = '{';
                        pos++;
                      } else {
                        r4 = null;
                        if (reportFailures === 0) {
                          matchFailed('"{"');
                        }
                      }
                      reportFailures--;
                      if (r4 === null) {
                        r4 = '';
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                      if (r4 !== null) {
                        r0 = [
                          r3,
                          r4
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (c) {
                        return [rp(new CS.String(c))];
                      }(r3);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.substr(pos, 2) === '#{') {
                        r3 = '#{';
                        pos += 2;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#{"');
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_expression();
                          if (r5 !== null) {
                            r6 = parse__();
                            if (r6 !== null) {
                              if (input.charCodeAt(pos) === 125) {
                                r7 = '}';
                                pos++;
                              } else {
                                r7 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"}"');
                                }
                              }
                              if (r7 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5,
                                  r6,
                                  r7
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function (e) {
                          return [e];
                        }(r5);
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_throw() {
              var cacheKey = 'throw@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_THROW();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Throw(e));
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_return() {
              var cacheKey = 'return@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_RETURN();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Return(e || null));
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_continue() {
              var cacheKey = 'continue@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_CONTINUE();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Continue);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_break() {
              var cacheKey = 'break@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_BREAK();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Break);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_debugger() {
              var cacheKey = 'debugger@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_DEBUGGER();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Debugger);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_undefined() {
              var cacheKey = 'undefined@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_UNDEFINED();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Undefined);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_null() {
              var cacheKey = 'null@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_NULL();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Null);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberAssign() {
              var cacheKey = 'memberAssign@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_memberAccess();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (access) {
                  access.isAssignment = true;
                  return access;
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_contextAssign() {
              var cacheKey = 'contextAssign@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 64) {
                r3 = '@';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"@"');
                }
              }
              if (r3 !== null) {
                reportedPos = r4;
                r3 = function () {
                  return rp(new CS.This);
                }();
              }
              if (r3 === null) {
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, m) {
                  return rp(new CS.NativeMemberAccessOp(a, m));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_unassignable() {
              var cacheKey = 'unassignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 9) === 'arguments') {
                r2 = 'arguments';
                pos += 9;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"arguments"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === 'eval') {
                  r2 = 'eval';
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"eval"');
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CompoundAssignable() {
              var cacheKey = 'CompoundAssignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r0 = parse_memberAssign();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = pos;
                reportFailures++;
                r3 = parse_unassignable();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r4 = parse_identifier();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (i) {
                    return i;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r0 = parse_contextAssign();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_Assignable() {
              var cacheKey = 'Assignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r0 = parse_memberAssign();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = pos;
                reportFailures++;
                r3 = parse_unassignable();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r4 = parse_identifier();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (i) {
                    return i;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r0 = parse_contextAssign();
                  if (r0 === null) {
                    r0 = parse_positionalDestructuring();
                    if (r0 === null) {
                      r0 = parse_namedDestructuring();
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuring() {
              var cacheKey = 'positionalDestructuring@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse_positionalDestructuringBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 93) {
                        r7 = ']';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"]"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ArrayInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringBody() {
              var cacheKey = 'positionalDestructuringBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_positionalDestructuringMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_positionalDestructuringMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringMemberList() {
              var cacheKey = 'positionalDestructuringMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_positionalDestructuringMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_positionalDestructuringMember();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_positionalDestructuringMember();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringMember() {
              var cacheKey = 'positionalDestructuringMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_rest();
              if (r0 === null) {
                r0 = parse_Assignable();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuring() {
              var cacheKey = 'namedDestructuring@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 123) {
                r3 = '{';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"{"');
                }
              }
              if (r3 !== null) {
                r4 = parse_namedDestructuringBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        r7 = '}';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"}"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringBody() {
              var cacheKey = 'namedDestructuringBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_namedDestructuringMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_namedDestructuringMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringMemberList() {
              var cacheKey = 'namedDestructuringMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_namedDestructuringMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_TERMINATOR();
                r7 = r7 !== null ? r7 : '';
                if (r7 !== null) {
                  r8 = parse__();
                  if (r8 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r9 = ',';
                      pos++;
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r9 === null) {
                      r9 = parse_TERMINATOR();
                    }
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_namedDestructuringMember();
                          if (r12 !== null) {
                            r5 = [
                              r7,
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_TERMINATOR();
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r9 = ',';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r9 === null) {
                        r9 = parse_TERMINATOR();
                      }
                      if (r9 !== null) {
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_namedDestructuringMember();
                            if (r12 !== null) {
                              r5 = [
                                r7,
                                r8,
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r5 = null;
                              pos = r6;
                            }
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringMember() {
              var cacheKey = 'namedDestructuringMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_ObjectInitialiserKeys();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    r5 = ':';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('":"');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_Assignable();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (key, val) {
                  return rp(new CS.ObjectInitialiserMember(key, val));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r0 = parse_contextVar();
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (v) {
                    var key = rp(new CS.String(v.memberName));
                    return rp(new CS.ObjectInitialiserMember(key, v));
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r4 = pos;
                  reportFailures++;
                  r3 = parse_unassignable();
                  reportFailures--;
                  if (r3 === null) {
                    r3 = '';
                  } else {
                    r3 = null;
                    pos = r4;
                  }
                  if (r3 !== null) {
                    r4 = parse_identifier();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (i) {
                      return rp(new CS.ObjectInitialiserMember(i, i));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifier() {
              var cacheKey = 'identifier@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_reserved();
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (i) {
                  return rp(new CS.Identifier(i));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierName() {
              var cacheKey = 'identifierName@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_identifierStart();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_identifierPart();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_identifierPart();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierStart() {
              var cacheKey = 'identifierStart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_UnicodeLetter();
              if (r0 === null) {
                if (/^[$_]/.test(input.charAt(pos))) {
                  r0 = input.charAt(pos);
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('[$_]');
                  }
                }
                if (r0 === null) {
                  r0 = parse_UnicodeEscapeSequence();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierPart() {
              var cacheKey = 'identifierPart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_identifierStart();
              if (r0 === null) {
                r0 = parse_UnicodeCombiningMark();
                if (r0 === null) {
                  r0 = parse_UnicodeDigit();
                  if (r0 === null) {
                    r0 = parse_UnicodeConnectorPunctuation();
                    if (r0 === null) {
                      r0 = parse_ZWNJ();
                      if (r0 === null) {
                        r0 = parse_ZWJ();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_propertyChain() {
              var cacheKey = 'propertyChain@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_propertyChainPart();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                if (input.charCodeAt(pos) === 46) {
                  r7 = '.';
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r7 !== null) {
                  r8 = parse_propertyChainPart();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  if (input.charCodeAt(pos) === 46) {
                    r7 = '.';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"."');
                    }
                  }
                  if (r7 !== null) {
                    r8 = parse_propertyChainPart();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_propertyChainPart() {
              var cacheKey = 'propertyChainPart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_Numbers();
              if (r0 === null) {
                r0 = parse_identifierName();
                if (r0 === null) {
                  if (input.substr(pos, 5) === '@each') {
                    r0 = '@each';
                    pos += 5;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"@each"');
                    }
                  }
                  if (r0 === null) {
                    if (input.substr(pos, 4) === 'this') {
                      r0 = 'this';
                      pos += 4;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"this"');
                      }
                    }
                    if (r0 === null) {
                      if (input.substr(pos, 2) === '[]') {
                        r0 = '[]';
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"[]"');
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse___() {
              var cacheKey = '__@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r4 = parse_whitespace();
              if (r4 !== null) {
                r3 = [];
                while (r4 !== null) {
                  r3.push(r4);
                  r4 = parse_whitespace();
                }
              } else {
                r3 = null;
              }
              if (r3 !== null) {
                r5 = pos;
                r6 = parse_blockComment();
                if (r6 !== null) {
                  r8 = parse_whitespace();
                  if (r8 !== null) {
                    r7 = [];
                    while (r8 !== null) {
                      r7.push(r8);
                      r8 = parse_whitespace();
                    }
                  } else {
                    r7 = null;
                  }
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse__() {
              var cacheKey = '_@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse___();
              r0 = r0 !== null ? r0 : '';
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_comment() {
              var cacheKey = 'comment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_blockComment();
              if (r0 === null) {
                r0 = parse_singleLineComment();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineComment() {
              var cacheKey = 'singleLineComment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 35) {
                r3 = '#';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"#"');
                }
              }
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r8 = pos;
                reportFailures++;
                r7 = parse_TERM();
                reportFailures--;
                if (r7 === null) {
                  r7 = '';
                } else {
                  r7 = null;
                  pos = r8;
                }
                if (r7 !== null) {
                  if (input.length > pos) {
                    r8 = input.charAt(pos);
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r8 = pos;
                  reportFailures++;
                  r7 = parse_TERM();
                  reportFailures--;
                  if (r7 === null) {
                    r7 = '';
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                  if (r7 !== null) {
                    if (input.length > pos) {
                      r8 = input.charAt(pos);
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('any character');
                      }
                    }
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_blockComment() {
              var cacheKey = 'blockComment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '###') {
                r3 = '###';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"###"');
                }
              }
              if (r3 !== null) {
                if (/^[^#]/.test(input.charAt(pos))) {
                  r4 = input.charAt(pos);
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^#]');
                  }
                }
                if (r4 !== null) {
                  r5 = [];
                  if (/^[^#]/.test(input.charAt(pos))) {
                    r6 = input.charAt(pos);
                    pos++;
                  } else {
                    r6 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^#]');
                    }
                  }
                  if (r6 === null) {
                    r7 = pos;
                    if (input.charCodeAt(pos) === 35) {
                      r8 = '#';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#"');
                      }
                    }
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 35) {
                        r9 = '#';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r11 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 35) {
                          r10 = '#';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#"');
                          }
                        }
                        reportFailures--;
                        if (r10 === null) {
                          r10 = '';
                        } else {
                          r10 = null;
                          pos = r11;
                        }
                        if (r10 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    if (/^[^#]/.test(input.charAt(pos))) {
                      r6 = input.charAt(pos);
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^#]');
                      }
                    }
                    if (r6 === null) {
                      r7 = pos;
                      if (input.charCodeAt(pos) === 35) {
                        r8 = '#';
                        pos++;
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      if (r8 !== null) {
                        if (input.charCodeAt(pos) === 35) {
                          r9 = '#';
                          pos++;
                        } else {
                          r9 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#"');
                          }
                        }
                        r9 = r9 !== null ? r9 : '';
                        if (r9 !== null) {
                          r11 = pos;
                          reportFailures++;
                          if (input.charCodeAt(pos) === 35) {
                            r10 = '#';
                            pos++;
                          } else {
                            r10 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                          reportFailures--;
                          if (r10 === null) {
                            r10 = '';
                          } else {
                            r10 = null;
                            pos = r11;
                          }
                          if (r10 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    }
                  }
                  if (r5 !== null) {
                    if (input.substr(pos, 3) === '###') {
                      r6 = '###';
                      pos += 3;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"###"');
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_whitespace() {
              var cacheKey = 'whitespace@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              if (/^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]');
                }
              }
              if (r0 === null) {
                if (input.charCodeAt(pos) === 13) {
                  r0 = '\r';
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\r"');
                  }
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.charCodeAt(pos) === 92) {
                    r3 = '\\';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\\\"');
                    }
                  }
                  if (r3 !== null) {
                    if (input.charCodeAt(pos) === 13) {
                      r4 = '\r';
                      pos++;
                    } else {
                      r4 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\r"');
                      }
                    }
                    r4 = r4 !== null ? r4 : '';
                    if (r4 !== null) {
                      if (input.charCodeAt(pos) === 10) {
                        r5 = '\n';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\n"');
                        }
                      }
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    r0 = input.substring(pos, r1);
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_INDENT() {
              var cacheKey = 'INDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 61423) {
                  r4 = '\uEFEF';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFEF"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (ws) {
                  return ws;
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DEDENT() {
              var cacheKey = 'DEDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              r5 = pos;
              r6 = parse_TERMINATOR();
              r6 = r6 !== null ? r6 : '';
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r3 = [
                    r6,
                    r7
                  ];
                } else {
                  r3 = null;
                  pos = r5;
                }
              } else {
                r3 = null;
                pos = r5;
              }
              if (r3 !== null) {
                r3 = input.substring(pos, r4);
              }
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 61438) {
                  r4 = '\uEFFE';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFFE"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (ws) {
                  return ws;
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERM() {
              var cacheKey = 'TERM@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 13) {
                r3 = '\r';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\r"');
                }
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 10) {
                  r4 = '\n';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\n"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 61439) {
                  r0 = '\uEFFF';
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFFF"');
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return '';
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERMINATOR() {
              var cacheKey = 'TERMINATOR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r3 = pos;
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_comment();
                r5 = r5 !== null ? r5 : '';
                if (r5 !== null) {
                  r6 = parse_TERM();
                  if (r6 !== null) {
                    r7 = parse_blockComment();
                    r7 = r7 !== null ? r7 : '';
                    if (r7 !== null) {
                      r2 = [
                        r4,
                        r5,
                        r6,
                        r7
                      ];
                    } else {
                      r2 = null;
                      pos = r3;
                    }
                  } else {
                    r2 = null;
                    pos = r3;
                  }
                } else {
                  r2 = null;
                  pos = r3;
                }
              } else {
                r2 = null;
                pos = r3;
              }
              if (r2 !== null) {
                r0 = [];
                while (r2 !== null) {
                  r0.push(r2);
                  r3 = pos;
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_comment();
                    r5 = r5 !== null ? r5 : '';
                    if (r5 !== null) {
                      r6 = parse_TERM();
                      if (r6 !== null) {
                        r7 = parse_blockComment();
                        r7 = r7 !== null ? r7 : '';
                        if (r7 !== null) {
                          r2 = [
                            r4,
                            r5,
                            r6,
                            r7
                          ];
                        } else {
                          r2 = null;
                          pos = r3;
                        }
                      } else {
                        r2 = null;
                        pos = r3;
                      }
                    } else {
                      r2 = null;
                      pos = r3;
                    }
                  } else {
                    r2 = null;
                    pos = r3;
                  }
                }
              } else {
                r0 = null;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERMINDENT() {
              var cacheKey = 'TERMINDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              if (r3 !== null) {
                r4 = parse_INDENT();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_AND() {
              var cacheKey = 'AND@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'and') {
                r3 = 'and';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"and"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_BREAK() {
              var cacheKey = 'BREAK@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'break') {
                r3 = 'break';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"break"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_BY() {
              var cacheKey = 'BY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'by') {
                r3 = 'by';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"by"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CATCH() {
              var cacheKey = 'CATCH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'catch') {
                r3 = 'catch';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"catch"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CONTINUE() {
              var cacheKey = 'CONTINUE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 8) === 'continue') {
                r3 = 'continue';
                pos += 8;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"continue"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CLASS() {
              var cacheKey = 'CLASS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'class') {
                r3 = 'class';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"class"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DELETE() {
              var cacheKey = 'DELETE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'delete') {
                r3 = 'delete';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"delete"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DEBUGGER() {
              var cacheKey = 'DEBUGGER@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 8) === 'debugger') {
                r3 = 'debugger';
                pos += 8;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"debugger"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DO() {
              var cacheKey = 'DO@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'do') {
                r3 = 'do';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"do"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ELSE() {
              var cacheKey = 'ELSE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'else') {
                r3 = 'else';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"else"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_EXTENDS() {
              var cacheKey = 'EXTENDS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 7) === 'extends') {
                r3 = 'extends';
                pos += 7;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"extends"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FALSE() {
              var cacheKey = 'FALSE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'false') {
                r3 = 'false';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"false"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FINALLY() {
              var cacheKey = 'FINALLY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 7) === 'finally') {
                r3 = 'finally';
                pos += 7;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"finally"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FOR() {
              var cacheKey = 'FOR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'for') {
                r3 = 'for';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"for"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IF() {
              var cacheKey = 'IF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'if') {
                r3 = 'if';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"if"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IN() {
              var cacheKey = 'IN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'in') {
                r3 = 'in';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"in"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_INSTANCEOF() {
              var cacheKey = 'INSTANCEOF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 10) === 'instanceof') {
                r3 = 'instanceof';
                pos += 10;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"instanceof"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IS() {
              var cacheKey = 'IS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'is') {
                r3 = 'is';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"is"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ISNT() {
              var cacheKey = 'ISNT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'isnt') {
                r3 = 'isnt';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"isnt"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_LOOP() {
              var cacheKey = 'LOOP@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'loop') {
                r3 = 'loop';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"loop"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_MIXIN() {
              var cacheKey = 'MIXIN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'mixin') {
                r3 = 'mixin';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"mixin"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NEW() {
              var cacheKey = 'NEW@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'new') {
                r3 = 'new';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"new"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NO() {
              var cacheKey = 'NO@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'no') {
                r3 = 'no';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"no"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NOT() {
              var cacheKey = 'NOT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'not') {
                r3 = 'not';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"not"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NULL() {
              var cacheKey = 'NULL@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'null') {
                r3 = 'null';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"null"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OF() {
              var cacheKey = 'OF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'of') {
                r3 = 'of';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"of"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OFF() {
              var cacheKey = 'OFF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'off') {
                r3 = 'off';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"off"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ON() {
              var cacheKey = 'ON@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'on') {
                r3 = 'on';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"on"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OR() {
              var cacheKey = 'OR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'or') {
                r3 = 'or';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"or"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OWN() {
              var cacheKey = 'OWN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'own') {
                r3 = 'own';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"own"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_RETURN() {
              var cacheKey = 'RETURN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'return') {
                r3 = 'return';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"return"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SWITCH() {
              var cacheKey = 'SWITCH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'switch') {
                r3 = 'switch';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"switch"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SUPER() {
              var cacheKey = 'SUPER@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'super') {
                r3 = 'super';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"super"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THEN() {
              var cacheKey = 'THEN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'then') {
                r3 = 'then';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"then"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THIS() {
              var cacheKey = 'THIS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'this') {
                r3 = 'this';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"this"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THROW() {
              var cacheKey = 'THROW@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'throw') {
                r3 = 'throw';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"throw"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TRUE() {
              var cacheKey = 'TRUE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'true') {
                r3 = 'true';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"true"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TRY() {
              var cacheKey = 'TRY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'try') {
                r3 = 'try';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"try"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TYPEOF() {
              var cacheKey = 'TYPEOF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'typeof') {
                r3 = 'typeof';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"typeof"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNDEFINED() {
              var cacheKey = 'UNDEFINED@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 9) === 'undefined') {
                r3 = 'undefined';
                pos += 9;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"undefined"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNLESS() {
              var cacheKey = 'UNLESS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'unless') {
                r3 = 'unless';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"unless"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNTIL() {
              var cacheKey = 'UNTIL@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'until') {
                r3 = 'until';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"until"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WHEN() {
              var cacheKey = 'WHEN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'when') {
                r3 = 'when';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"when"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WHILE() {
              var cacheKey = 'WHILE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'while') {
                r3 = 'while';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"while"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WITH() {
              var cacheKey = 'WITH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'with') {
                r3 = 'with';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"with"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_YES() {
              var cacheKey = 'YES@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'yes') {
                r3 = 'yes';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"yes"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SharedKeywords() {
              var cacheKey = 'SharedKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 4) === 'true') {
                r2 = 'true';
                pos += 4;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"true"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 5) === 'false') {
                  r2 = 'false';
                  pos += 5;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"false"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 4) === 'null') {
                    r2 = 'null';
                    pos += 4;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"null"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 4) === 'this') {
                      r2 = 'this';
                      pos += 4;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"this"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 3) === 'new') {
                        r2 = 'new';
                        pos += 3;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"new"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 6) === 'delete') {
                          r2 = 'delete';
                          pos += 6;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"delete"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 6) === 'typeof') {
                            r2 = 'typeof';
                            pos += 6;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"typeof"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 10) === 'instanceof') {
                              r2 = 'instanceof';
                              pos += 10;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"instanceof"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 2) === 'in') {
                                r2 = 'in';
                                pos += 2;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"in"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 6) === 'return') {
                                  r2 = 'return';
                                  pos += 6;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"return"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 5) === 'throw') {
                                    r2 = 'throw';
                                    pos += 5;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"throw"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 5) === 'break') {
                                      r2 = 'break';
                                      pos += 5;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"break"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 8) === 'continue') {
                                        r2 = 'continue';
                                        pos += 8;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"continue"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 8) === 'debugger') {
                                          r2 = 'debugger';
                                          pos += 8;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"debugger"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 2) === 'if') {
                                            r2 = 'if';
                                            pos += 2;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"if"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 4) === 'else') {
                                              r2 = 'else';
                                              pos += 4;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"else"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 6) === 'switch') {
                                                r2 = 'switch';
                                                pos += 6;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"switch"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 3) === 'for') {
                                                  r2 = 'for';
                                                  pos += 3;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"for"');
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos, 5) === 'while') {
                                                    r2 = 'while';
                                                    pos += 5;
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('"while"');
                                                    }
                                                  }
                                                  if (r2 === null) {
                                                    if (input.substr(pos, 2) === 'do') {
                                                      r2 = 'do';
                                                      pos += 2;
                                                    } else {
                                                      r2 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed('"do"');
                                                      }
                                                    }
                                                    if (r2 === null) {
                                                      if (input.substr(pos, 3) === 'try') {
                                                        r2 = 'try';
                                                        pos += 3;
                                                      } else {
                                                        r2 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed('"try"');
                                                        }
                                                      }
                                                      if (r2 === null) {
                                                        if (input.substr(pos, 5) === 'catch') {
                                                          r2 = 'catch';
                                                          pos += 5;
                                                        } else {
                                                          r2 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed('"catch"');
                                                          }
                                                        }
                                                        if (r2 === null) {
                                                          if (input.substr(pos, 7) === 'finally') {
                                                            r2 = 'finally';
                                                            pos += 7;
                                                          } else {
                                                            r2 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed('"finally"');
                                                            }
                                                          }
                                                          if (r2 === null) {
                                                            if (input.substr(pos, 5) === 'class') {
                                                              r2 = 'class';
                                                              pos += 5;
                                                            } else {
                                                              r2 = null;
                                                              if (reportFailures === 0) {
                                                                matchFailed('"class"');
                                                              }
                                                            }
                                                            if (r2 === null) {
                                                              if (input.substr(pos, 7) === 'extends') {
                                                                r2 = 'extends';
                                                                pos += 7;
                                                              } else {
                                                                r2 = null;
                                                                if (reportFailures === 0) {
                                                                  matchFailed('"extends"');
                                                                }
                                                              }
                                                              if (r2 === null) {
                                                                if (input.substr(pos, 5) === 'super') {
                                                                  r2 = 'super';
                                                                  pos += 5;
                                                                } else {
                                                                  r2 = null;
                                                                  if (reportFailures === 0) {
                                                                    matchFailed('"super"');
                                                                  }
                                                                }
                                                                if (r2 === null) {
                                                                  if (input.substr(pos, 4) === 'with') {
                                                                    r2 = 'with';
                                                                    pos += 4;
                                                                  } else {
                                                                    r2 = null;
                                                                    if (reportFailures === 0) {
                                                                      matchFailed('"with"');
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_JSKeywords() {
              var cacheKey = 'JSKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 4) === 'case') {
                r2 = 'case';
                pos += 4;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"case"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 7) === 'default') {
                  r2 = 'default';
                  pos += 7;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"default"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 8) === 'function') {
                    r2 = 'function';
                    pos += 8;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"function"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 3) === 'var') {
                      r2 = 'var';
                      pos += 3;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"var"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 4) === 'void') {
                        r2 = 'void';
                        pos += 4;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"void"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 5) === 'const') {
                          r2 = 'const';
                          pos += 5;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"const"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 3) === 'let') {
                            r2 = 'let';
                            pos += 3;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"let"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 4) === 'enum') {
                              r2 = 'enum';
                              pos += 4;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"enum"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 6) === 'export') {
                                r2 = 'export';
                                pos += 6;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"export"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 6) === 'import') {
                                  r2 = 'import';
                                  pos += 6;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"import"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 6) === 'native') {
                                    r2 = 'native';
                                    pos += 6;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"native"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 10) === 'implements') {
                                      r2 = 'implements';
                                      pos += 10;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"implements"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 9) === 'interface') {
                                        r2 = 'interface';
                                        pos += 9;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"interface"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 7) === 'package') {
                                          r2 = 'package';
                                          pos += 7;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"package"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 7) === 'private') {
                                            r2 = 'private';
                                            pos += 7;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"private"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 9) === 'protected') {
                                              r2 = 'protected';
                                              pos += 9;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"protected"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 6) === 'public') {
                                                r2 = 'public';
                                                pos += 6;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"public"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 6) === 'static') {
                                                  r2 = 'static';
                                                  pos += 6;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"static"');
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos, 5) === 'yield') {
                                                    r2 = 'yield';
                                                    pos += 5;
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('"yield"');
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CSKeywords() {
              var cacheKey = 'CSKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 9) === 'undefined') {
                r2 = 'undefined';
                pos += 9;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"undefined"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === 'then') {
                  r2 = 'then';
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"then"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 6) === 'unless') {
                    r2 = 'unless';
                    pos += 6;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"unless"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 5) === 'until') {
                      r2 = 'until';
                      pos += 5;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"until"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 4) === 'loop') {
                        r2 = 'loop';
                        pos += 4;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"loop"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 3) === 'off') {
                          r2 = 'off';
                          pos += 3;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"off"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 2) === 'by') {
                            r2 = 'by';
                            pos += 2;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"by"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 4) === 'when') {
                              r2 = 'when';
                              pos += 4;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"when"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 3) === 'and') {
                                r2 = 'and';
                                pos += 3;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"and"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 2) === 'or') {
                                  r2 = 'or';
                                  pos += 2;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"or"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 4) === 'isnt') {
                                    r2 = 'isnt';
                                    pos += 4;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"isnt"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 2) === 'is') {
                                      r2 = 'is';
                                      pos += 2;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"is"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 3) === 'not') {
                                        r2 = 'not';
                                        pos += 3;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"not"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 3) === 'yes') {
                                          r2 = 'yes';
                                          pos += 3;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"yes"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 2) === 'no') {
                                            r2 = 'no';
                                            pos += 2;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"no"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 2) === 'on') {
                                              r2 = 'on';
                                              pos += 2;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"on"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 2) === 'of') {
                                                r2 = 'of';
                                                pos += 2;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"of"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 5) === 'mixin') {
                                                  r2 = 'mixin';
                                                  pos += 5;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"mixin"');
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_reserved() {
              var cacheKey = 'reserved@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_macro();
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r0 = parse_SharedKeywords();
                if (r0 === null) {
                  r0 = parse_CSKeywords();
                  if (r0 === null) {
                    r0 = parse_JSKeywords();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeEscapeSequence() {
              var cacheKey = 'UnicodeEscapeSequence@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === '\\u') {
                r3 = '\\u';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\\\u"');
                }
              }
              if (r3 !== null) {
                r4 = parse_hexDigit();
                if (r4 !== null) {
                  r5 = parse_hexDigit();
                  if (r5 !== null) {
                    r6 = parse_hexDigit();
                    if (r6 !== null) {
                      r7 = parse_hexDigit();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (h0, h1, h2, h3) {
                  return String.fromCharCode(parseInt(h0 + h1 + h2 + h3, 16));
                }(r4, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeLetter() {
              var cacheKey = 'UnicodeLetter@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uFF21-\uFF3Aa-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D62-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7C\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2D00-\u2D25\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA9CF\uAA70\uAADD\uFF70\uFF9E\uFF9F\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u2135-\u2138\u2D30-\u2D65\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FCB\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA2D\uFA30-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55340) {
                  r2 = '\uD82C';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uD82C"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDC00\uDC01]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDC00\\uDC01]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55304) {
                    r2 = '\uD808';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD808"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC00-\uDF6E]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDC00-\\uDF6E]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55401) {
                      r2 = '\uD869';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD869"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDED6\uDF00]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDED6\\uDF00]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.charCodeAt(pos) === 55305) {
                        r2 = '\uD809';
                        pos++;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\uD809"');
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDC00-\uDC62]/.test(input.charAt(pos))) {
                          r3 = input.charAt(pos);
                          pos++;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('[\\uDC00-\\uDC62]');
                          }
                        }
                        if (r3 !== null) {
                          r0 = [
                            r2,
                            r3
                          ];
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.charCodeAt(pos) === 55349) {
                          r2 = '\uD835';
                          pos++;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\uD835"');
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/.test(input.charAt(pos))) {
                            r3 = input.charAt(pos);
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]');
                            }
                          }
                          if (r3 !== null) {
                            r0 = [
                              r2,
                              r3
                            ];
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.charCodeAt(pos) === 55300) {
                            r2 = '\uD804';
                            pos++;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\uD804"');
                            }
                          }
                          if (r2 !== null) {
                            if (/^[\uDC03-\uDC37\uDC83-\uDCAF]/.test(input.charAt(pos))) {
                              r3 = input.charAt(pos);
                              pos++;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('[\\uDC03-\\uDC37\\uDC83-\\uDCAF]');
                              }
                            }
                            if (r3 !== null) {
                              r0 = [
                                r2,
                                r3
                              ];
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.charCodeAt(pos) === 55296) {
                              r2 = '\uD800';
                              pos++;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\uD800"');
                              }
                            }
                            if (r2 !== null) {
                              if (/^[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF40\uDF42-\uDF49\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]/.test(input.charAt(pos))) {
                                r3 = input.charAt(pos);
                                pos++;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed('[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]');
                                }
                              }
                              if (r3 !== null) {
                                r0 = [
                                  r2,
                                  r3
                                ];
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              if (input.charCodeAt(pos) === 55308) {
                                r2 = '\uD80C';
                                pos++;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\uD80C"');
                                }
                              }
                              if (r2 !== null) {
                                if (/^[\uDC00-\uDFFF]/.test(input.charAt(pos))) {
                                  r3 = input.charAt(pos);
                                  pos++;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('[\\uDC00-\\uDFFF]');
                                  }
                                }
                                if (r3 !== null) {
                                  r0 = [
                                    r2,
                                    r3
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                if (input.charCodeAt(pos) === 55297) {
                                  r2 = '\uD801';
                                  pos++;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\uD801"');
                                  }
                                }
                                if (r2 !== null) {
                                  if (/^[\uDC00-\uDC9D]/.test(input.charAt(pos))) {
                                    r3 = input.charAt(pos);
                                    pos++;
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('[\\uDC00-\\uDC9D]');
                                    }
                                  }
                                  if (r3 !== null) {
                                    r0 = [
                                      r2,
                                      r3
                                    ];
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  if (input.charCodeAt(pos) === 55406) {
                                    r2 = '\uD86E';
                                    pos++;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"\\uD86E"');
                                    }
                                  }
                                  if (r2 !== null) {
                                    if (/^[\uDC1D]/.test(input.charAt(pos))) {
                                      r3 = input.charAt(pos);
                                      pos++;
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('[\\uDC1D]');
                                      }
                                    }
                                    if (r3 !== null) {
                                      r0 = [
                                        r2,
                                        r3
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                  if (r0 === null) {
                                    r1 = pos;
                                    if (input.charCodeAt(pos) === 55299) {
                                      r2 = '\uD803';
                                      pos++;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"\\uD803"');
                                      }
                                    }
                                    if (r2 !== null) {
                                      if (/^[\uDC00-\uDC48]/.test(input.charAt(pos))) {
                                        r3 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('[\\uDC00-\\uDC48]');
                                        }
                                      }
                                      if (r3 !== null) {
                                        r0 = [
                                          r2,
                                          r3
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                    if (r0 === null) {
                                      r1 = pos;
                                      if (input.charCodeAt(pos) === 55360) {
                                        r2 = '\uD840';
                                        pos++;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"\\uD840"');
                                        }
                                      }
                                      if (r2 !== null) {
                                        if (/^[\uDC00]/.test(input.charAt(pos))) {
                                          r3 = input.charAt(pos);
                                          pos++;
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('[\\uDC00]');
                                          }
                                        }
                                        if (r3 !== null) {
                                          r0 = [
                                            r2,
                                            r3
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                      if (r0 === null) {
                                        r1 = pos;
                                        if (input.charCodeAt(pos) === 55422) {
                                          r2 = '\uD87E';
                                          pos++;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"\\uD87E"');
                                          }
                                        }
                                        if (r2 !== null) {
                                          if (/^[\uDC00-\uDE1D]/.test(input.charAt(pos))) {
                                            r3 = input.charAt(pos);
                                            pos++;
                                          } else {
                                            r3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('[\\uDC00-\\uDE1D]');
                                            }
                                          }
                                          if (r3 !== null) {
                                            r0 = [
                                              r2,
                                              r3
                                            ];
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                        if (r0 === null) {
                                          r1 = pos;
                                          if (input.charCodeAt(pos) === 55405) {
                                            r2 = '\uD86D';
                                            pos++;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"\\uD86D"');
                                            }
                                          }
                                          if (r2 !== null) {
                                            if (/^[\uDF34\uDF40]/.test(input.charAt(pos))) {
                                              r3 = input.charAt(pos);
                                              pos++;
                                            } else {
                                              r3 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('[\\uDF34\\uDF40]');
                                              }
                                            }
                                            if (r3 !== null) {
                                              r0 = [
                                                r2,
                                                r3
                                              ];
                                            } else {
                                              r0 = null;
                                              pos = r1;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                          if (r0 === null) {
                                            r1 = pos;
                                            if (input.charCodeAt(pos) === 55322) {
                                              r2 = '\uD81A';
                                              pos++;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"\\uD81A"');
                                              }
                                            }
                                            if (r2 !== null) {
                                              if (/^[\uDC00-\uDE38]/.test(input.charAt(pos))) {
                                                r3 = input.charAt(pos);
                                                pos++;
                                              } else {
                                                r3 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('[\\uDC00-\\uDE38]');
                                                }
                                              }
                                              if (r3 !== null) {
                                                r0 = [
                                                  r2,
                                                  r3
                                                ];
                                              } else {
                                                r0 = null;
                                                pos = r1;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r1;
                                            }
                                            if (r0 === null) {
                                              r1 = pos;
                                              if (input.charCodeAt(pos) === 55298) {
                                                r2 = '\uD802';
                                                pos++;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"\\uD802"');
                                                }
                                              }
                                              if (r2 !== null) {
                                                if (/^[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72]/.test(input.charAt(pos))) {
                                                  r3 = input.charAt(pos);
                                                  pos++;
                                                } else {
                                                  r3 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]');
                                                  }
                                                }
                                                if (r3 !== null) {
                                                  r0 = [
                                                    r2,
                                                    r3
                                                  ];
                                                } else {
                                                  r0 = null;
                                                  pos = r1;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r1;
                                              }
                                              if (r0 === null) {
                                                r1 = pos;
                                                if (input.charCodeAt(pos) === 55309) {
                                                  r2 = '\uD80D';
                                                  pos++;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"\\uD80D"');
                                                  }
                                                }
                                                if (r2 !== null) {
                                                  if (/^[\uDC00-\uDC2E]/.test(input.charAt(pos))) {
                                                    r3 = input.charAt(pos);
                                                    pos++;
                                                  } else {
                                                    r3 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('[\\uDC00-\\uDC2E]');
                                                    }
                                                  }
                                                  if (r3 !== null) {
                                                    r0 = [
                                                      r2,
                                                      r3
                                                    ];
                                                  } else {
                                                    r0 = null;
                                                    pos = r1;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r1;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeCombiningMark() {
              var cacheKey = 'UnicodeCombiningMark@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u19B0-\u19C0\u19C8\u19C9\u1A19-\u1A1B\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 56128) {
                  r2 = '\uDB40';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uDB40"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDD00-\uDDEF]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDD00-\\uDDEF]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55348) {
                    r2 = '\uD834';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD834"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDD65\uDD66\uDD6D-\uDD72]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55300) {
                      r2 = '\uD804';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD804"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDC01\uDC38-\uDC46\uDC80\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.charCodeAt(pos) === 55296) {
                        r2 = '\uD800';
                        pos++;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\uD800"');
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDDFD]/.test(input.charAt(pos))) {
                          r3 = input.charAt(pos);
                          pos++;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('[\\uDDFD]');
                          }
                        }
                        if (r3 !== null) {
                          r0 = [
                            r2,
                            r3
                          ];
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.charCodeAt(pos) === 55298) {
                          r2 = '\uD802';
                          pos++;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\uD802"');
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F]/.test(input.charAt(pos))) {
                            r3 = input.charAt(pos);
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]');
                            }
                          }
                          if (r3 !== null) {
                            r0 = [
                              r2,
                              r3
                            ];
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeDigit() {
              var cacheKey = 'UnicodeDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55349) {
                  r2 = '\uD835';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uD835"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDFCE-\uDFFF]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDFCE-\\uDFFF]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55300) {
                    r2 = '\uD804';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD804"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC66-\uDC6F]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDC66-\\uDC6F]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55297) {
                      r2 = '\uD801';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD801"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDCA0-\uDCA9]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDCA0-\\uDCA9]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeConnectorPunctuation() {
              var cacheKey = 'UnicodeConnectorPunctuation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ZWNJ() {
              var cacheKey = 'ZWNJ@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 8204) {
                r0 = '\u200C';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\u200C"');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ZWJ() {
              var cacheKey = 'ZWJ@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 8205) {
                r0 = '\u200D';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\u200D"');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function cleanupExpected(expected) {
              expected.sort();
              var lastExpected = null;
              var cleanExpected = [];
              for (var i = 0; i < expected.length; i++) {
                if (expected[i] !== lastExpected) {
                  cleanExpected.push(expected[i]);
                  lastExpected = expected[i];
                }
              }
              return cleanExpected;
            }
            var CS = require('/lib/nodes.js', module), constructorLookup = {
                '||': CS.LogicalOrOp,
                or: CS.LogicalOrOp,
                '&&': CS.LogicalAndOp,
                and: CS.LogicalAndOp,
                '|': CS.BitOrOp,
                '^': CS.BitXorOp,
                '&': CS.BitAndOp,
                '?': CS.ExistsOp,
                '==': CS.EQOp,
                is: CS.EQOp,
                '!=': CS.NEQOp,
                isnt: CS.NEQOp,
                '<=': CS.LTEOp,
                '>=': CS.GTEOp,
                '<': CS.LTOp,
                '>': CS.GTOp,
                'extends': CS.ExtendsOp,
                'instanceof': CS.InstanceofOp,
                'in': CS.InOp,
                'of': CS.OfOp,
                '<<': CS.LeftShiftOp,
                '>>': CS.SignedRightShiftOp,
                '>>>': CS.UnsignedRightShiftOp,
                '+': CS.PlusOp,
                '-': CS.SubtractOp,
                '*': CS.MultiplyOp,
                '/': CS.DivideOp,
                '%': CS.RemOp,
                '**': CS.ExpOp
              }, negatableOps = [
                'instanceof',
                'in',
                'of'
              ], chainableComparisonOps = [
                '<=',
                '>=',
                '<',
                '>',
                '==',
                'is',
                '!=',
                'isnt'
              ], rightAssocOps = [
                ';',
                '=',
                '?',
                '**'
              ], precedenceHierarchy = [
                [
                  'or',
                  '||'
                ],
                [
                  'and',
                  '&&'
                ],
                ['|'],
                ['^'],
                ['&'],
                ['?'],
                [
                  'is',
                  '==',
                  'isnt',
                  '!='
                ],
                [
                  'instanceof',
                  'in',
                  'of',
                  '<=',
                  '>=',
                  '<',
                  '>'
                ],
                [
                  '<<',
                  '>>',
                  '>>>'
                ],
                [
                  '+',
                  '-'
                ],
                [
                  '*',
                  '/',
                  '%'
                ],
                ['**']
              ], precedenceTable = function () {
                var table = {}, ops, op;
                for (var level = 0, l = precedenceHierarchy.length; level < l; ++level) {
                  ops = precedenceHierarchy[level];
                  for (var o = 0, k = ops.length; o < k; ++o) {
                    op = ops[o];
                    table[op] = level;
                  }
                }
                return table;
              }(), RIGHT_ASSOCIATIVE = {}, LEFT_ASSOCIATIVE = {}, associativities = function () {
                var result = {};
                for (var op in precedenceTable) {
                  if (!{}.hasOwnProperty.call(precedenceTable, op))
                    continue;
                  result[op] = LEFT_ASSOCIATIVE;
                }
                for (var i = 0, l = rightAssocOps.length; i < l; ++i) {
                  result[rightAssocOps[i]] = RIGHT_ASSOCIATIVE;
                }
                return result;
              }();
            for (var i = 0, l = negatableOps.length; i < l; ++i) {
              (function (op) {
                var fn = function (a, b) {
                  return new CS.LogicalNotOp(new constructorLookup[op](a, b));
                };
                fn.prototype = constructorLookup[op].prototype;
                var negatedOp = 'not ' + op;
                constructorLookup[negatedOp] = fn;
                precedenceTable[negatedOp] = precedenceTable[op];
                associativities[negatedOp] = associativities[op];
              }(negatableOps[i]));
            }
            var prefixConstructorLookup = {
                '++': CS.PreIncrementOp,
                '--': CS.PreDecrementOp,
                '+': CS.UnaryPlusOp,
                '-': CS.UnaryNegateOp,
                '!': CS.LogicalNotOp,
                'not': CS.LogicalNotOp,
                '~': CS.BitNotOp,
                'do': CS.DoOp,
                'typeof': CS.TypeofOp,
                'delete': CS.DeleteOp
              }, postfixConstructorLookup = {
                '?': CS.UnaryExistsOp,
                '[..]': CS.ShallowCopyArray,
                '++': CS.PostIncrementOp,
                '--': CS.PostDecrementOp
              }, foldl = function (fn, memo, list) {
                for (var i = 0, l = list.length; i < l; ++i)
                  memo = fn(memo, list[i]);
                return memo;
              }, foldr = function (fn, memo, list) {
                for (var i = list.length; i--;)
                  memo = fn(memo, list[i]);
                return memo;
              }, foldBinaryExpr = function (parts, ignoreChains) {
                var stack, chainStack, nextPrec, nextOp, className, ctor, prec, rightOperand, leftOperand, operator, i, expr;
                if (parts.length < 3)
                  return parts[0];
                stack = [].slice.call(parts, 0, 3);
                parts = [].slice.call(parts, 3);
                while (parts.length > 0) {
                  nextOp = parts[0];
                  if (!ignoreChains && stack.length > 2) {
                    operator = stack[stack.length - 2];
                    if (chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0) {
                      chainStack = stack.slice(-3);
                      stack = stack.slice(0, stack.length - 3);
                      do {
                        operator = nextOp;
                        chainStack.push(parts.shift(), parts.shift());
                        nextOp = parts[0];
                        if (nextOp) {
                          nextPrec = precedenceTable[nextOp];
                          prec = precedenceTable[operator];
                        }
                      } while (nextOp != null && (nextPrec > prec || chainableComparisonOps.indexOf(nextOp) >= 0));
                      stack.push(new CS.ChainedComparisonOp(foldBinaryExpr(chainStack, true)));
                      continue;
                    }
                  }
                  while (stack.length > 2 && (operator = stack[stack.length - 2], prec = precedenceTable[operator], nextPrec = precedenceTable[nextOp], nextPrec < prec || chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0 || nextPrec == prec && associativities[operator] === LEFT_ASSOCIATIVE)) {
                    rightOperand = stack.pop();
                    stack.pop();
                    leftOperand = stack.pop();
                    stack.push(new constructorLookup[operator](leftOperand, rightOperand));
                  }
                  stack.push(parts.shift());
                  stack.push(parts.shift());
                }
                expr = stack.pop();
                while (stack.length > 0)
                  expr = new constructorLookup[(stack.pop())](stack.pop(), expr);
                return expr;
              }, createInterpolation = function (es) {
                var init = new CS.String('').g();
                return foldl(function (memo, s) {
                  if (s instanceof CS.String) {
                    var left = memo;
                    while (left)
                      if (left instanceof CS.String) {
                        if (left === init) {
                          c(left, s);
                          delete left.generated;
                        }
                        left.data = left.data + s.data;
                        return memo;
                      } else if (left instanceof CS.ConcatOp) {
                        left = left.right;
                      } else {
                        break;
                      }
                  }
                  return new CS.ConcatOp(memo, s);
                }, init, es);
              }, createMemberExpression = function (e, accesses) {
                return foldl(function (left, access) {
                  var F = function () {
                  };
                  F.prototype = access.op.prototype;
                  var o = new F;
                  access.op.apply(o, [left].concat(access.operands));
                  return c(o.r(left.raw + access.raw), e);
                }, e, accesses);
              }, isValidRegExpFlags = function (flags) {
                if (!flags)
                  return true;
                if (flags.length > 4)
                  return false;
                flags.sort();
                var flag = null;
                for (var i = 0, l = flags.length; i < l; ++i)
                  if (flag == flags[i])
                    return false;
                  else
                    flag = flags[i];
                return true;
              }, stripLeadingWhitespace = function (str) {
                str = str.replace(/\s+$/, '');
                var attempt, match, matchStr = str, indent = null;
                while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
                  attempt = match[1];
                  matchStr = matchStr.slice(match.index + match[0].length);
                  if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                    indent = attempt;
                }
                if (indent)
                  str = str.replace(new RegExp('\\n' + indent, 'g'), '\n');
                str = str.replace(/^\n/, '');
                return str;
              }, stripLeadingWhitespaceInterpolation = function (pieces) {
                var indent = null, piece, match, i, l, attempt, matchStr;
                for (i = 0, l = pieces.length; i < l; ++i) {
                  piece = pieces[i];
                  if (piece instanceof CS.String) {
                    if (i == l - 1)
                      piece.data = piece.data.replace(/\s+$/, '');
                    matchStr = piece.data;
                    while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
                      attempt = match[1];
                      matchStr = matchStr.slice(match.index + match[0].length);
                      if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                        indent = attempt;
                    }
                  }
                }
                if (indent) {
                  for (i = 0, l = pieces.length; i < l; ++i) {
                    piece = pieces[i];
                    if (piece instanceof CS.String) {
                      piece.data = piece.data.replace(new RegExp('\\n' + indent, 'g'), '\n');
                      if (i === l - 1)
                        piece.data = piece.data.replace(/(\n\s*)+$/, '');
                      if (i === 0)
                        piece.data = piece.data.replace(/^\n/, '');
                    }
                  }
                }
                return pieces;
              }, id = function (x) {
                return x;
              }, r = options.raw ? function (node) {
                node.raw = text().replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
                return node;
              } : id, p = options.raw ? function (node) {
                node.line = line();
                node.column = column();
                node.offset = offset();
                return node;
              } : id, rp = options.raw ? function (node) {
                return r(p(node));
              } : id, c = options.raw ? function (to, from) {
                to.line = from.line;
                to.column = from.column;
                to.offset = from.offset;
                return to;
              } : id;
            function computeReportedPosDetails() {
              function advanceCachedReportedPos() {
                var ch;
                for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
                  ch = input.charAt(cachedReportedPos);
                  if (ch === '\n') {
                    if (!cachedReportedPosDetails.seenCR) {
                      cachedReportedPosDetails.line++;
                    }
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = false;
                  } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
                    cachedReportedPosDetails.line++;
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = true;
                  } else if (!/[\uEFEF\uEFFE\uEFFF]/.test(ch)) {
                    cachedReportedPosDetails.column++;
                    cachedReportedPosDetails.seenCR = false;
                  }
                }
              }
              if (cachedReportedPos !== reportedPos) {
                if (cachedReportedPos > reportedPos) {
                  cachedReportedPos = 0;
                  cachedReportedPosDetails = {
                    line: 1,
                    column: 1,
                    seenCR: false
                  };
                }
                advanceCachedReportedPos();
              }
              return cachedReportedPosDetails;
            }
            var result = parseFunctions[startRule]();
            if (result === null || pos !== input.length) {
              reportedPos = Math.max(pos, rightmostFailuresPos);
              var found = reportedPos < input.length ? input.charAt(reportedPos) : null;
              var reportedPosDetails = computeReportedPosDetails();
              throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, reportedPos, reportedPosDetails.line, reportedPosDetails.column);
            }
            return result;
          }
        };
      result.SyntaxError = function (expected, found, offset, line, column) {
        function buildMessage(expected, found) {
          var expectedHumanized, foundHumanized;
          switch (expected.length) {
          case 0:
            expectedHumanized = 'end of input';
            break;
          case 1:
            expectedHumanized = expected[0];
            break;
          default:
            expectedHumanized = expected.slice(0, expected.length - 1).join(', ') + ' or ' + expected[expected.length - 1];
          }
          foundHumanized = found ? quote(found) : 'end of input';
          return 'Expected ' + expectedHumanized + ' but ' + foundHumanized + ' found.';
        }
        this.name = 'SyntaxError';
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
      };
      subclass(result.SyntaxError, Error);
      return result;
    }();
  });
  require.define('/lib/nodes.js', function (module, exports, __dirname, __filename) {
    var _, Annotations, ArrayInitialiser, AssignOp, Block, Bool, Class, CompoundAssignOp, ComputedProperty, concat, concatMap, Conditional, createNodes, difference, enumerableMethods, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, MemberAccessOp, Mixin, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, ObjectInitialiserMember, PostDecrementOp, PostIncrementOp, Primitives, Range, RegExp, RegExps, Slice, SoakedMemberAccessOp, StaticMemberAccessOps, Super, Switch, SwitchCase, This, union, While;
    cache$ = require('/lib/functional-helpers.js', module);
    map = cache$.map;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    nub = cache$.nub;
    union = cache$.union;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    _ = require('/node_modules/lodash/index.js', module);
    createNodes = function (subclasses, superclasses) {
      var className, specs;
      if (null == superclasses)
        superclasses = [];
      for (className in subclasses) {
        if (!isOwn$(subclasses, className))
          continue;
        specs = subclasses[className];
        (function (className) {
          var externalCtor$, isCategory, klass, params, superclass;
          superclass = null != superclasses[0] ? superclasses[0] : function () {
          };
          isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
          params = 'undefined' !== typeof specs && null != specs ? function () {
            switch (specs.length) {
            case 0:
              return [];
            case 1:
            case 2:
              return specs[0];
            }
          }.call(this) : null;
          if (null != params)
            params;
          else
            params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
          klass = function (super$) {
            extends$(class$, super$);
            externalCtor$ = isCategory ? function () {
            } : function () {
              var i, param;
              for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                param = params[i$];
                i = i$;
                this[param] = arguments[i];
              }
              if (null != this.initialise)
                this.initialise.apply(this, arguments);
              return this;
            };
            function class$() {
              return externalCtor$.apply(this, arguments);
            }
            class$.prototype.className = className;
            class$.superclasses = superclasses;
            return class$;
          }(superclass);
          if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
            klass.prototype.childNodes = specs[0];
          if (isCategory)
            createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
          return exports[className] = klass;
        }(className));
      }
    };
    createNodes({
      Nodes: [
        [],
        {
          BinOps: [
            [
              'left',
              'right'
            ],
            {
              AssignOps: [
                [
                  'assignee',
                  'expression'
                ],
                {
                  AssignOp: null,
                  ClassProtoAssignOp: null,
                  CompoundAssignOp: [[
                      'op',
                      'assignee',
                      'expression'
                    ]]
                }
              ],
              BitOps: [
                null,
                {
                  BitAndOp: null,
                  BitOrOp: null,
                  BitXorOp: null,
                  LeftShiftOp: null,
                  SignedRightShiftOp: null,
                  UnsignedRightShiftOp: null
                }
              ],
              ComparisonOps: [
                null,
                {
                  EQOp: null,
                  GTEOp: null,
                  GTOp: null,
                  LTEOp: null,
                  LTOp: null,
                  NEQOp: null
                }
              ],
              ConcatOp: null,
              ExistsOp: null,
              ExtendsOp: null,
              InOp: null,
              InstanceofOp: null,
              LogicalOps: [
                null,
                {
                  LogicalAndOp: null,
                  LogicalOrOp: null
                }
              ],
              MathsOps: [
                null,
                {
                  ExpOp: null,
                  DivideOp: null,
                  MultiplyOp: null,
                  RemOp: null,
                  SubtractOp: null
                }
              ],
              OfOp: null,
              PlusOp: null,
              Range: [[
                  'isInclusive',
                  'left',
                  'right'
                ]],
              SeqOp: null
            }
          ],
          Statements: [
            [],
            {
              Break: null,
              Continue: null,
              Debugger: null,
              Return: [['expression']],
              Throw: [['expression']]
            }
          ],
          UnaryOps: [
            ['expression'],
            {
              BitNotOp: null,
              DeleteOp: null,
              DoOp: null,
              LogicalNotOp: null,
              NewOp: [[
                  'ctor',
                  'arguments'
                ]],
              PreDecrementOp: null,
              PreIncrementOp: null,
              PostDecrementOp: null,
              PostIncrementOp: null,
              TypeofOp: null,
              UnaryExistsOp: null,
              UnaryNegateOp: null,
              UnaryPlusOp: null
            }
          ],
          MemberAccessOps: [
            null,
            {
              StaticMemberAccessOps: [
                [
                  'expression',
                  'memberName'
                ],
                {
                  MemberAccessOp: null,
                  NativeMemberAccessOp: null,
                  ProtoMemberAccessOp: null,
                  SoakedMemberAccessOp: null,
                  SoakedProtoMemberAccessOp: null
                }
              ],
              DynamicMemberAccessOps: [
                [
                  'expression',
                  'indexingExpr'
                ],
                {
                  DynamicMemberAccessOp: null,
                  DynamicProtoMemberAccessOp: null,
                  SoakedDynamicMemberAccessOp: null,
                  SoakedDynamicProtoMemberAccessOp: null
                }
              ]
            }
          ],
          ChainedComparisonOp: [['expression']],
          FunctionApplications: [
            [
              'function',
              'arguments'
            ],
            {
              FunctionApplication: null,
              SoakedFunctionApplication: null
            }
          ],
          Super: null,
          Program: [['body']],
          Block: [['statements']],
          Conditional: [[
              'condition',
              'consequent',
              'alternate'
            ]],
          ForIn: [[
              'valAssignee',
              'keyAssignee',
              'target',
              'step',
              'filter',
              'body'
            ]],
          ForOf: [[
              'isOwn',
              'keyAssignee',
              'valAssignee',
              'target',
              'filter',
              'body'
            ]],
          Switch: [[
              'expression',
              'cases',
              'alternate'
            ]],
          SwitchCase: [[
              'conditions',
              'consequent'
            ]],
          Try: [[
              'body',
              'catchAssignee',
              'catchBody',
              'finallyBody'
            ]],
          While: [[
              'condition',
              'body'
            ]],
          ArrayInitialiser: [['members']],
          ObjectInitialiser: [['members']],
          ObjectInitialiserMember: [[
              'key',
              'expression',
              'annotations'
            ]],
          Mixin: [[
              'nameAssignee',
              'body',
              'mixins'
            ]],
          Class: [[
              'nameAssignee',
              'parent',
              'ctor',
              'body',
              'mixins',
              'boundMembers'
            ]],
          Constructor: [['expression']],
          Functions: [
            [
              'parameters',
              'body'
            ],
            {
              Function: null,
              BoundFunction: null,
              ComputedProperty: null
            }
          ],
          DefaultParam: [[
              'param',
              'default'
            ]],
          Annotations: [
            ['parameters'],
            {
              Volatile: null,
              Computed: null,
              Observes: null
            }
          ],
          Identifiers: [
            ['data'],
            {
              Identifier: null,
              GenSym: null
            }
          ],
          Null: null,
          Primitives: [
            ['data'],
            {
              Bool: null,
              JavaScript: null,
              Numbers: [
                null,
                {
                  Int: null,
                  Float: null
                }
              ],
              String: null
            }
          ],
          RegExps: [
            null,
            {
              RegExp: [[
                  'data',
                  'flags'
                ]],
              HeregExp: [[
                  'expression',
                  'flags'
                ]]
            }
          ],
          This: null,
          Undefined: null,
          Slice: [[
              'expression',
              'isInclusive',
              'left',
              'right'
            ]],
          Rest: [['expression']],
          Spread: [['expression']]
        }
      ]
    });
    cache$1 = exports;
    Nodes = cache$1.Nodes;
    Primitives = cache$1.Primitives;
    CompoundAssignOp = cache$1.CompoundAssignOp;
    StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
    Range = cache$1.Range;
    ArrayInitialiser = cache$1.ArrayInitialiser;
    ObjectInitialiser = cache$1.ObjectInitialiser;
    NegatedConditional = cache$1.NegatedConditional;
    Conditional = cache$1.Conditional;
    Identifier = cache$1.Identifier;
    ForOf = cache$1.ForOf;
    Functions = cache$1.Functions;
    While = cache$1.While;
    Mixin = cache$1.Mixin;
    Class = cache$1.Class;
    Block = cache$1.Block;
    NewOp = cache$1.NewOp;
    Bool = cache$1.Bool;
    FunctionApplications = cache$1.FunctionApplications;
    RegExps = cache$1.RegExps;
    RegExp = cache$1.RegExp;
    HeregExp = cache$1.HeregExp;
    Super = cache$1.Super;
    Slice = cache$1.Slice;
    Switch = cache$1.Switch;
    Identifiers = cache$1.Identifiers;
    SwitchCase = cache$1.SwitchCase;
    GenSym = cache$1.GenSym;
    ComputedProperty = cache$1.ComputedProperty;
    ObjectInitialiserMember = cache$1.ObjectInitialiserMember;
    Annotations = cache$1.Annotations;
    PostIncrementOp = cache$1.PostIncrementOp;
    PostDecrementOp = cache$1.PostDecrementOp;
    MemberAccessOp = cache$1.MemberAccessOp;
    This = cache$1.This;
    AssignOp = cache$1.AssignOp;
    SoakedMemberAccessOp = cache$1.SoakedMemberAccessOp;
    Nodes.fromBasicObject = function (obj) {
      return exports[obj.type].fromBasicObject(obj);
    };
    Nodes.prototype.listMembers = [];
    Nodes.prototype.toBasicObject = function () {
      var child, obj, p;
      obj = { type: this.className };
      if (null != this.line)
        obj.line = this.line;
      if (null != this.column)
        obj.column = this.column;
      if (null != this.raw) {
        obj.raw = this.raw;
        if (null != this.offset)
          obj.range = [
            this.offset,
            this.offset + this.raw.length
          ];
      }
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          obj[child] = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.toBasicObject());
            }
            return accum$;
          }.call(this, []);
        } else {
          obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
        }
      }
      return obj;
    };
    Nodes.prototype.fold = function (memo, fn) {
      var child, p;
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          memo = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.fold(memo, fn));
            }
            return accum$;
          }.call(this, []);
        } else {
          memo = this[child].fold(memo, fn);
        }
      }
      return fn(memo, this);
    };
    Nodes.prototype.clone = function () {
      var ctor, k, n, v;
      ctor = function () {
      };
      ctor.prototype = this.constructor.prototype;
      n = new ctor;
      for (k in this) {
        if (!isOwn$(this, k))
          continue;
        v = this[k];
        n[k] = v;
      }
      return n;
    };
    Nodes.prototype['instanceof'] = function () {
      var ctor, ctors, superclasses;
      ctors = arguments.length > 0 ? [].slice.call(arguments, 0) : [];
      superclasses = map(this.constructor.superclasses, function (c) {
        return c.prototype.className;
      });
      for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
        ctor = ctors[i$];
        if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
          continue;
        return true;
      }
      return false;
    };
    Nodes.prototype.r = function (param$) {
      this.raw = param$;
      return this;
    };
    Nodes.prototype.p = function (param$, param$1, param$2) {
      this.line = param$;
      this.column = param$1;
      this.offset = param$2;
      return this;
    };
    Nodes.prototype.generated = false;
    Nodes.prototype.g = function () {
      this.generated = true;
      return this;
    };
    handlePrimitives = function (ctor) {
      var primitives;
      primitives = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
          primitive = primitives[i$];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(Class, 'boundMembers');
    handlePrimitives(CompoundAssignOp, 'op');
    handlePrimitives(ForOf, 'isOwn');
    handlePrimitives(HeregExp, 'flags');
    handlePrimitives(Identifiers, 'data');
    handlePrimitives(Primitives, 'data');
    handlePrimitives(Range, 'isInclusive');
    handlePrimitives(RegExp, 'data', 'flags');
    handlePrimitives(Slice, 'isInclusive');
    handlePrimitives(StaticMemberAccessOps, 'memberName');
    handlePrimitives(ComputedProperty, 'chains');
    handlePrimitives(ObjectInitialiserMember, 'annotations');
    handlePrimitives(Annotations, 'parameters');
    handleLists = function (ctor) {
      var listProps;
      listProps = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayInitialiser, 'members');
    handleLists(Block, 'statements');
    handleLists(Functions, 'parameters');
    handleLists(FunctionApplications, 'arguments');
    handleLists(NewOp, 'arguments');
    handleLists(ObjectInitialiser, 'members');
    handleLists(Super, 'arguments');
    handleLists(Switch, 'cases');
    handleLists(SwitchCase, 'conditions');
    handleLists(Class, 'mixins');
    handleLists(Mixin, 'mixins');
    Block.wrap = function (s) {
      return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
    };
    Class.prototype.initialise = function () {
      if (null != this.boundMembers)
        this.boundMembers;
      else
        this.boundMembers = [];
      this.name = new GenSym('class');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Class.prototype.childNodes.push('name');
    Mixin.prototype.initialise = function () {
      this.name = new GenSym('mixin');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Mixin.prototype.childNodes.push('name');
    ObjectInitialiser.prototype.keys = function () {
      return map(this.members, function (m) {
        return m.key;
      });
    };
    ObjectInitialiser.prototype.vals = function () {
      return map(this.members, function (m) {
        return m.expression;
      });
    };
    RegExps.prototype.initialise = function (_, flags) {
      var flag;
      this.flags = {};
      for (var cache$2 = [
            'g',
            'i',
            'm',
            'y'
          ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
        flag = cache$2[i$];
        this.flags[flag] = in$(flag, flags);
      }
    };
    PostIncrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    PostDecrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    Nodes.prototype.dependentKeys = function (scope) {
      var chains, child, childName, member;
      if (null == scope)
        scope = {};
      chains = [];
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            chains = chains.concat(member.dependentKeys(scope));
          }
        } else {
          child = this[childName];
          chains = chains.concat(child.dependentKeys(scope));
        }
      }
      return chains;
    };
    This.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return [[]];
    };
    MemberAccessOp.prototype.dependentKeys = function (scope) {
      var memberName;
      if (null == scope)
        scope = {};
      memberName = this.memberName;
      return this.expression.dependentKeys(scope).map(function (c) {
        if (!(memberName === 'constructor'))
          c.push(memberName);
        return c;
      });
    };
    SoakedMemberAccessOp.prototype.dependentKeys = MemberAccessOp.prototype.dependentKeys;
    enumerableMethods = [
      'nextObject',
      'firstObject',
      'lastObject',
      'contains',
      'forEach',
      'getEach',
      'setEach',
      'map',
      'mapProperty',
      'filter',
      'reject',
      'filterProperty',
      'rejectProperty',
      'find',
      'findProperty',
      'every',
      'everyProperty',
      'some',
      'someProperty',
      'reduce',
      'invoke',
      'toArray',
      'compact',
      'without',
      'uniq'
    ];
    FunctionApplications.prototype.dependentKeys = function (scope) {
      var argument, res;
      if (null == scope)
        scope = {};
      res = this['function'].dependentKeys(scope);
      if (this['function']['instanceof'](MemberAccessOp) || this['function']['instanceof'](SoakedMemberAccessOp)) {
        res = res.map(function (c) {
          c.pop();
          return c;
        });
        if (_.contains(enumerableMethods, this['function'].memberName))
          res = res.map(function (c) {
            c.push('@each');
            return c;
          });
      }
      for (var i$ = 0, length$ = this['arguments'].length; i$ < length$; ++i$) {
        argument = this['arguments'][i$];
        argument.dependentKeys(scope).map(function (c) {
          return res.push(c);
        });
      }
      return res;
    };
    Block.prototype.dependentKeys = function (scope) {
      var key, newScope, res;
      if (null == scope)
        scope = {};
      res = [];
      newScope = _.clone(scope);
      for (var i$ = 0, length$ = newScope.length; i$ < length$; ++i$) {
        key = newScope[i$];
        newScope[key] = _.clone(newScope[key]);
      }
      this.statements.forEach(function (s) {
        return res = res.concat(s.dependentKeys(scope));
      });
      for (var i$1 = 0, length$1 = scope.length; i$1 < length$1; ++i$1) {
        key = scope[i$1];
        scope[key] = scope[key].concat(newScope[key]);
      }
      return res;
    };
    AssignOp.prototype.dependentKeys = function (scope) {
      var res;
      if (null == scope)
        scope = {};
      res = this.expression.dependentKeys(scope);
      if (this.assignee['instanceof'](Identifier))
        scope[this.assignee.data] = (scope[this.assignee.data] || []).concat(res);
      return res;
    };
    Identifier.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return _.clone(scope[this.data]) || [];
    };
    exports.NegatedConditional = function (super$) {
      extends$(NegatedConditional, super$);
      function NegatedConditional() {
        Conditional.apply(this, arguments);
      }
      return NegatedConditional;
    }(Conditional);
    exports.NegatedWhile = function (super$1) {
      extends$(NegatedWhile, super$1);
      function NegatedWhile() {
        While.apply(this, arguments);
      }
      return NegatedWhile;
    }(While);
    exports.Loop = function (super$2) {
      extends$(Loop, super$2);
      function Loop(body) {
        While.call(this, new Bool(true).g(), body);
      }
      return Loop;
    }(While);
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
  });
  require.define('/lib/functional-helpers.js', function (module, exports, __dirname, __filename) {
    var concat, foldl, map, nub, span;
    this.any = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (fn(e))
          return true;
      }
      return false;
    };
    this.all = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (!fn(e))
          return false;
      }
      return true;
    };
    this.foldl = foldl = function (memo, list, fn) {
      var i;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        memo = fn(memo, i);
      }
      return memo;
    };
    this.foldl1 = function (list, fn) {
      return foldl(list[0], list.slice(1), fn);
    };
    this.map = map = function (list, fn) {
      var e;
      return function (accum$) {
        for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
          e = list[i$];
          accum$.push(fn(e));
        }
        return accum$;
      }.call(this, []);
    };
    this.concat = concat = function (list) {
      var cache$;
      return (cache$ = []).concat.apply(cache$, [].slice.call(list));
    };
    this.concatMap = function (list, fn) {
      return concat(map(list, fn));
    };
    this.intersect = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.difference = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.nub = nub = function (list) {
      var i, result;
      result = [];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        if (!!in$(i, result))
          continue;
        result.push(i);
      }
      return result;
    };
    this.union = function (listA, listB) {
      var b;
      return listA.concat(function (accum$) {
        for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          b = cache$[i$];
          if (!!in$(b, listA))
            continue;
          accum$.push(b);
        }
        return accum$;
      }.call(this, []));
    };
    this.flip = function (fn) {
      return function (b, a) {
        return fn.call(this, a, b);
      };
    };
    this.owns = function (hop) {
      return function (a, b) {
        return hop.call(a, b);
      };
    }({}.hasOwnProperty);
    this.span = span = function (list, f) {
      var cache$, ys, zs;
      if (list.length === 0) {
        return [
          [],
          []
        ];
      } else if (f(list[0])) {
        cache$ = span(list.slice(1), f);
        ys = cache$[0];
        zs = cache$[1];
        return [
          [list[0]].concat([].slice.call(ys)),
          zs
        ];
      } else {
        return [
          [],
          list
        ];
      }
    };
    this.divMod = function (a, b) {
      var c, div, mod;
      c = a % b;
      mod = c < 0 ? c + b : c;
      div = Math.floor(a / b);
      return [
        div,
        mod
      ];
    };
    this.partition = function (list, fn) {
      var item, result;
      result = [
        [],
        []
      ];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        item = list[i$];
        result[+!fn(item)].push(item);
      }
      return result;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
  });
  require.define('/src/preprocessor.coffee', function (module, exports, __dirname, __filename) {
    var DEDENT, INDENT, pointToErrorLocation, Preprocessor, StringScanner, TERM, ws;
    pointToErrorLocation = require('/src/helpers.coffee', module).pointToErrorLocation;
    StringScanner = require('/node_modules/StringScanner/lib/StringScanner.js', module);
    this.Preprocessor = Preprocessor = function () {
      ws = '\\t\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
      INDENT = '\uEFEF';
      DEDENT = '\uEFFE';
      TERM = '\uEFFF';
      function Preprocessor(param$) {
        if (null == param$)
          param$ = {};
        this.options = param$;
        this.preprocessed = '';
        this.base = null;
        this.indents = [];
        this.context = [];
      }
      Preprocessor.process = function (input, options) {
        if (null == options)
          options = {};
        return new Preprocessor(options).process(input);
      };
      Preprocessor.prototype.err = function (c) {
        var columns, context, lines, token;
        token = function () {
          switch (c) {
          case INDENT:
            return 'INDENT';
          case DEDENT:
            return 'DEDENT';
          case TERM:
            return 'TERM';
          default:
            return '"' + c.replace(/"/g, '\\"') + '"';
          }
        }.call(this);
        lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
        columns = null != lines[lines.length - 1] ? lines[lines.length - 1].length : 0;
        context = pointToErrorLocation(this.ss.str, lines.length, columns);
        throw new Error('Unexpected ' + token + '\n' + context);
      };
      Preprocessor.prototype.peek = function () {
        if (this.context.length) {
          return this.context[this.context.length - 1];
        } else {
          return null;
        }
      };
      Preprocessor.prototype.observe = function (c) {
        var top;
        top = this.peek();
        switch (c) {
        case '"""':
        case "'''":
        case '"':
        case "'":
        case '###':
        case '`':
        case '///':
        case '/':
          if (top === c) {
            this.context.pop();
          } else {
            this.context.push(c);
          }
          break;
        case INDENT:
        case '#':
        case '#{':
        case '[':
        case '(':
        case '{':
        case '\\':
        case 'regexp-[':
        case 'regexp-(':
        case 'regexp-{':
        case 'heregexp-#':
        case 'heregexp-[':
        case 'heregexp-(':
        case 'heregexp-{':
          this.context.push(c);
          break;
        case DEDENT:
          if (!(top === INDENT))
            this.err(c);
          this.indents.pop();
          this.context.pop();
          break;
        case '\n':
          if (!(top === '#' || top === 'heregexp-#'))
            this.err(c);
          this.context.pop();
          break;
        case ']':
          if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
            this.err(c);
          this.context.pop();
          break;
        case ')':
          if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
            this.err(c);
          this.context.pop();
          break;
        case '}':
          if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
            this.err(c);
          this.context.pop();
          break;
        case 'end-\\':
          if (!(top === '\\'))
            this.err(c);
          this.context.pop();
          break;
        default:
          throw new Error('undefined token observed: ' + c);
        }
        return this.context;
      };
      Preprocessor.prototype.p = function (s) {
        if (null != s)
          this.preprocessed = '' + this.preprocessed + s;
        return s;
      };
      Preprocessor.prototype.scan = function (r) {
        return this.p(this.ss.scan(r));
      };
      Preprocessor.prototype.consumeIndentation = function () {
        var context, indent, indentIndex, lineLen, lines, message;
        if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
          this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
          if (null != this.base) {
            if (!(this.ss.eos() || null != this.scan(this.base)))
              throw new Error('inconsistent base indentation');
          } else {
            this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
          }
          indentIndex = 0;
          while (indentIndex < this.indents.length) {
            indent = this.indents[indentIndex];
            if (this.ss.check(new RegExp('' + indent + ''))) {
              this.scan(new RegExp('' + indent + ''));
            } else if (this.ss.eos() || this.ss.check(new RegExp('[^' + ws + ']'))) {
              --indentIndex;
              this.p('' + DEDENT + TERM);
              this.observe(DEDENT);
            } else {
              lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
              message = 'Syntax error on line ' + lines.length + ': indentation is ambiguous';
              lineLen = this.indents.reduce(function (l, r) {
                return l + r.length;
              }, 0);
              context = pointToErrorLocation(this.ss.str, lines.length, lineLen);
              throw new Error('' + message + '\n' + context);
            }
            ++indentIndex;
          }
          if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
            this.indents.push(this.scan(new RegExp('[' + ws + ']+')));
            this.p(INDENT);
            return this.observe(INDENT);
          }
        }
      };
      Preprocessor.prototype.introduceContext = function () {
        var impliedRegexp, lastChar, pos, spaceBefore, tok;
        if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
          return this.observe(tok);
        } else if (tok = this.scan(/\//)) {
          pos = this.ss.position();
          if (pos > 1) {
            lastChar = this.ss.string()[pos - 2];
            spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
            impliedRegexp = /[;,=><*%^&|[(+!~-]/.test(lastChar);
          }
          if (pos === 1 || impliedRegexp || spaceBefore && !this.ss.check(new RegExp('[' + ws + '=]')) && this.ss.check(/[^\r\n]*\//))
            return this.observe('/');
        }
      };
      Preprocessor.prototype.process = function (input) {
        var tok;
        if (this.options.literate)
          input = input.replace(/^( {0,3}\S)/gm, '    #$1');
        this.ss = new StringScanner(input);
        while (!this.ss.eos()) {
          switch (this.peek()) {
          case null:
          case INDENT:
            this.consumeIndentation();
            this.scan(/[^\n'"\\\/#`[(){}\]]+/);
            if (this.ss.check(/[})\]]/)) {
              while (this.peek() === INDENT) {
                this.p('' + DEDENT + TERM);
                this.observe(DEDENT);
              }
              this.observe(this.scan(/[})\]]/));
            } else {
              this.introduceContext();
            }
            break;
          case '#{':
          case '{':
            this.scan(/[^\n'"\\\/#`[({}]+/);
            if (tok = this.scan(/\}/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '[':
            this.scan(/[^\n'"\\\/#`[({\]]+/);
            if (tok = this.scan(/\]/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '(':
            this.scan(/[^\n'"\\\/#`[({)]+/);
            if (tok = this.scan(/\)/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '\\':
            if (this.scan(/[\s\S]/))
              this.observe('end-\\');
            break;
          case '"""':
            this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"""/)) {
              this.observe(tok);
            } else if (tok = this.scan(/#{|"""/)) {
              this.observe(tok);
            }
            break;
          case '"':
            this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"/))
              this.observe(tok);
            break;
          case "'''":
            this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'''/))
              this.observe(tok);
            break;
          case "'":
            this.scan(/(?:[^'\\]+|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'/))
              this.observe(tok);
            break;
          case '###':
            this.scan(/(?:[^#]+|##?(?!#))+/);
            if (tok = this.scan(/###/))
              this.observe(tok);
            break;
          case '#':
            this.scan(/[^\n]+/);
            if (tok = this.scan(/\n/))
              this.observe(tok);
            break;
          case '`':
            this.scan(/[^`]+/);
            if (tok = this.scan(/`/))
              this.observe(tok);
            break;
          case '///':
            this.scan(/(?:[^[\/#\\]+|\/\/?(?!\/)|\\.)+/);
            if (tok = this.scan(/#{|\/\/\/|\\/)) {
              this.observe(tok);
            } else if (this.ss.scan(/#/)) {
              this.observe('heregexp-#');
            } else if (tok = this.scan(/[\[]/)) {
              this.observe('heregexp-' + tok);
            }
            break;
          case 'heregexp-[':
            this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/[\]\\]|#{|\/\/\//))
              this.observe(tok);
            break;
          case 'heregexp-#':
            this.ss.scan(/(?:[^\n\/]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/\n|\/\/\//))
              this.observe(tok);
            break;
          case '/':
            this.scan(/[^[\/\\]+/);
            if (tok = this.scan(/[\/\\]/)) {
              this.observe(tok);
            } else if (tok = this.scan(/\[/)) {
              this.observe('regexp-' + tok);
            }
            break;
          case 'regexp-[':
            this.scan(/[^\]\\]+/);
            if (tok = this.scan(/[\]\\]/))
              this.observe(tok);
          }
        }
        this.scan(new RegExp('[' + ws + '\\n]*$'));
        while (this.context.length) {
          switch (this.peek()) {
          case INDENT:
            this.p('' + DEDENT + TERM);
            this.observe(DEDENT);
            break;
          case '#':
            this.p('\n');
            this.observe('\n');
            break;
          default:
            throw new Error('Unclosed "' + this.peek().replace(/"/g, '\\"') + '" at EOF');
          }
        }
        return this.preprocessed;
      };
      return Preprocessor;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/node_modules/StringScanner/lib/StringScanner.js', function (module, exports, __dirname, __filename) {
    (function () {
      var StringScanner;
      StringScanner = function () {
        function StringScanner(str) {
          this.str = str != null ? str : '';
          this.str = '' + this.str;
          this.pos = 0;
          this.lastMatch = {
            reset: function () {
              this.str = null;
              this.captures = [];
              return this;
            }
          }.reset();
          this;
        }
        StringScanner.prototype.bol = function () {
          return this.pos <= 0 || this.str[this.pos - 1] === '\n';
        };
        StringScanner.prototype.captures = function () {
          return this.lastMatch.captures;
        };
        StringScanner.prototype.check = function (pattern) {
          var matches;
          if (this.str.substr(this.pos).search(pattern) !== 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str;
        };
        StringScanner.prototype.checkUntil = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);
          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
        };
        StringScanner.prototype.clone = function () {
          var clone, prop, value, _ref;
          clone = new this.constructor(this.str);
          clone.pos = this.pos;
          clone.lastMatch = {};
          _ref = this.lastMatch;
          for (prop in _ref) {
            value = _ref[prop];
            clone.lastMatch[prop] = value;
          }
          return clone;
        };
        StringScanner.prototype.concat = function (str) {
          this.str += str;
          return this;
        };
        StringScanner.prototype.eos = function () {
          return this.pos === this.str.length;
        };
        StringScanner.prototype.exists = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);
          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return patternPos;
        };
        StringScanner.prototype.getch = function () {
          return this.scan(/./);
        };
        StringScanner.prototype.match = function () {
          return this.lastMatch.str;
        };
        StringScanner.prototype.matches = function (pattern) {
          this.check(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.matched = function () {
          return this.lastMatch.str != null;
        };
        StringScanner.prototype.matchSize = function () {
          if (this.matched()) {
            return this.match().length;
          } else {
            return null;
          }
        };
        StringScanner.prototype.peek = function (len) {
          return this.str.substr(this.pos, len);
        };
        StringScanner.prototype.pointer = function () {
          return this.pos;
        };
        StringScanner.prototype.setPointer = function (pos) {
          pos = +pos;
          if (pos < 0) {
            pos = 0;
          }
          if (pos > this.str.length) {
            pos = this.str.length;
          }
          return this.pos = pos;
        };
        StringScanner.prototype.reset = function () {
          this.lastMatch.reset();
          this.pos = 0;
          return this;
        };
        StringScanner.prototype.rest = function () {
          return this.str.substr(this.pos);
        };
        StringScanner.prototype.scan = function (pattern) {
          var chk;
          chk = this.check(pattern);
          if (chk != null) {
            this.pos += chk.length;
          }
          return chk;
        };
        StringScanner.prototype.scanUntil = function (pattern) {
          var chk;
          chk = this.checkUntil(pattern);
          if (chk != null) {
            this.pos += chk.length;
          }
          return chk;
        };
        StringScanner.prototype.skip = function (pattern) {
          this.scan(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.skipUntil = function (pattern) {
          this.scanUntil(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.string = function () {
          return this.str;
        };
        StringScanner.prototype.terminate = function () {
          this.pos = this.str.length;
          this.lastMatch.reset();
          return this;
        };
        StringScanner.prototype.toString = function () {
          return '#<StringScanner ' + (this.eos() ? 'fin' : '' + this.pos + '/' + this.str.length + ' @ ' + (this.str.length > 8 ? '' + this.str.substr(0, 5) + '...' : this.str)) + '>';
        };
        return StringScanner;
      }();
      StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
      StringScanner.prototype.clear = StringScanner.prototype.terminate;
      StringScanner.prototype.dup = StringScanner.prototype.clone;
      StringScanner.prototype.endOfString = StringScanner.prototype.eos;
      StringScanner.prototype.exist = StringScanner.prototype.exists;
      StringScanner.prototype.getChar = StringScanner.prototype.getch;
      StringScanner.prototype.position = StringScanner.prototype.pointer;
      StringScanner.StringScanner = StringScanner;
      module.exports = StringScanner;
    }.call(this));
  });
  global.EmberScript = require('/src/browser.coffee');
}.call(this, this));
//# sourceMappingURL=dist/ember-script.js.map
