// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  var process = function () {
      var cwd = '/';
      return {
        title: 'browser',
        version: 'v0.10.21',
        browser: true,
        env: {},
        argv: [],
        nextTick: global.setImmediate || function (fn) {
          setTimeout(fn, 0);
        },
        cwd: function () {
          return cwd;
        },
        chdir: function (dir) {
          cwd = dir;
        }
      };
    }();
  require.define('/src/browser.coffee', function (module, exports, __dirname, __filename) {
    var EmberScript, runScripts;
    module.exports = EmberScript = require('/src/module.coffee', module);
    global.EmberScript = EmberScript;
    EmberScript['eval'] = function (code, options) {
      if (null == options)
        options = {};
      if (null != options.bare)
        options.bare;
      else
        options.bare = true;
      if (null != options.optimise)
        options.optimise;
      else
        options.optimise = true;
      return eval(EmberScript.em2js(code, options));
    };
    EmberScript.run = function (code, options) {
      if (null == options)
        options = {};
      options.bare = true;
      if (null != options.optimise)
        options.optimise;
      else
        options.optimise = true;
      return Function(EmberScript.em2js(code, options))();
    };
    EmberScript.load = function (url, callback) {
      var xhr;
      xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP') : new XMLHttpRequest;
      xhr.open('GET', url, true);
      if ('overrideMimeType' in xhr)
        xhr.overrideMimeType('text/plain');
      xhr.onreadystatechange = function () {
        if (!(xhr.readyState === xhr.DONE))
          return;
        if (xhr.status === 0 || xhr.status === 200) {
          EmberScript.run(xhr.responseText);
        } else {
          throw new Error('Could not load ' + url);
        }
        if (callback)
          return callback();
      };
      return xhr.send(null);
    };
    runScripts = function () {
      var coffees, execute, index, s, scripts;
      scripts = document.getElementsByTagName('script');
      coffees = function (accum$) {
        for (var i$ = 0, length$ = scripts.length; i$ < length$; ++i$) {
          s = scripts[i$];
          if (!(s.type === 'text/emberscript'))
            continue;
          accum$.push(s);
        }
        return accum$;
      }.call(this, []);
      index = 0;
      (execute = function () {
        var script;
        if (!(script = coffees[index++]))
          return;
        if (script.src) {
          return EmberScript.load(script.src, execute);
        } else {
          EmberScript.run(script.innerHTML);
          return execute();
        }
      })();
      return null;
    };
    if ('undefined' !== typeof addEventListener && null != addEventListener) {
      addEventListener('DOMContentLoaded', runScripts, false);
    } else if ('undefined' !== typeof attachEvent && null != attachEvent) {
      attachEvent('onload', runScripts);
    }
  });
  require.define('/src/module.coffee', function (module, exports, __dirname, __filename) {
    var CoffeeScript, Compiler, cscodegen, escodegen, escodegenFormat, ext, formatParserError, Nodes, Optimiser, Parser, pkg, Preprocessor;
    formatParserError = require('/src/helpers.coffee', module).formatParserError;
    Nodes = require('/src/nodes.coffee', module);
    Preprocessor = require('/src/preprocessor.coffee', module).Preprocessor;
    Parser = require('/src/parser.coffee', module);
    Optimiser = require('/src/optimiser.coffee', module).Optimiser;
    Compiler = require('/src/compiler.coffee', module).Compiler;
    require('/src/ember-runtime.js', module);
    cscodegen = function () {
      try {
        return require('/node_modules/cscodegen/lib/cscodegen.js', module);
      } catch (e$) {
        return;
      }
    }.call(this);
    escodegen = function () {
      try {
        return require('/node_modules/escodegen/escodegen.js', module);
      } catch (e$1) {
        return;
      }
    }.call(this);
    pkg = require('/package.json', module);
    escodegenFormat = {
      indent: {
        style: '  ',
        base: 0
      },
      renumber: true,
      hexadecimal: true,
      quotes: 'auto',
      parentheses: false
    };
    CoffeeScript = {
      CoffeeScript: CoffeeScript,
      Compiler: Compiler,
      Optimiser: Optimiser,
      Parser: Parser,
      Preprocessor: Preprocessor,
      Nodes: Nodes,
      VERSION: pkg.version,
      parse: function (coffee, options) {
        var e, parsed, preprocessed;
        if (null == options)
          options = {};
        try {
          preprocessed = Preprocessor.process(coffee, { literate: options.literate });
          parsed = Parser.parse(preprocessed, {
            raw: options.raw,
            inputSource: options.inputSource
          });
          if (options.optimise) {
            return Optimiser.optimise(parsed);
          } else {
            return parsed;
          }
        } catch (e$2) {
          e = e$2;
          if (!(e instanceof Parser.SyntaxError))
            throw e;
          throw new Error(formatParserError(preprocessed, e));
        }
      },
      compile: function (csAst, options) {
        return Compiler.compile(csAst, options).toBasicObject();
      },
      cs: function (csAst, options) {
      },
      jsWithSourceMap: function (jsAst, name, options) {
        var targetName;
        if (null == name)
          name = 'unknown';
        if (null == options)
          options = {};
        if (!(null != escodegen))
          throw new Error('escodegen not found: run `npm install escodegen`');
        if (!{}.hasOwnProperty.call(jsAst, 'type'))
          jsAst = jsAst.toBasicObject();
        targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
        return escodegen.generate(jsAst, {
          comment: !options.compact,
          sourceMapWithCode: true,
          sourceMap: name,
          file: targetName || 'unknown',
          format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat,
          verbatim: 'verbatim'
        });
      },
      js: function (jsAst, options) {
        return this.jsWithSourceMap(jsAst, null, options).code;
      },
      sourceMap: function (jsAst, name, options) {
        return this.jsWithSourceMap(jsAst, name, options).map;
      },
      em2js: function (input, options) {
        var csAST, jsAST;
        if (null == options)
          options = {};
        if (null != options.optimise)
          options.optimise;
        else
          options.optimise = true;
        csAST = this.parse(input, options);
        jsAST = this.compile(csAST, { bare: options.bare });
        return this.js(jsAST, { compact: options.compact || options.minify });
      }
    };
    module.exports = CoffeeScript;
    if (null != (null != require.extensions ? require.extensions['.node'] : void 0)) {
      CoffeeScript.register = function () {
        return require('/src/register.coffee', module);
      };
      for (var cache$ = [
            '.em',
            '.litem'
          ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
        ext = cache$[i$];
        if (null != require.extensions[ext])
          require.extensions[ext];
        else
          require.extensions[ext] = function () {
            throw new Error('Use EmberScript.register() or require the ember-script/register module to require ' + ext + ' files.');
          };
      }
    }
  });
  require.define('/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'name': 'ember-script',
      'description': 'Ember-infused CoffeeScript',
      'keywords': [
        'javascript',
        'language',
        'coffeescript',
        'compiler',
        'ember.js'
      ],
      'author': 'Gordon L. Hempton, Michael Ficarra',
      'version': '0.0.14',
      'main': './lib/module',
      'bin': { 'ember-script': './bin/ember-script' },
      'homepage': 'https://github.com/ghempton/ember-script',
      'bugs': 'https://github.com/ghempton/ember-script/issues',
      'repository': {
        'type': 'git',
        'url': 'git://github.com/ghempton/ember-script.git'
      },
      'scripts': {
        'build': 'make -j build',
        'test': 'make -j test'
      },
      'devDependencies': {
        'mocha': '~1.12.0',
        'pegjs': 'git://github.com/dmajda/pegjs.git#bea6b1fde74c8aebf802f9bcc3380c65b241e1b7',
        'coffee-script-redux': 'git://github.com/michaelficarra/CoffeeScriptRedux.git',
        'commonjs-everywhere': '~0.9.0',
        'cluster': '~0.7.7',
        'semver': '~2.1.0'
      },
      'dependencies': {
        'StringScanner': '~0.0.3',
        'nopt': '~2.1.2'
      },
      'optionalDependencies': {
        'esmangle': '~1.0.0',
        'source-map': '0.1.x',
        'escodegen': '~1.2.0',
        'cscodegen': 'git://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383'
      },
      'engines': { 'node': '0.8.x || 0.10.x' },
      'licenses': [{
          'type': '3-clause BSD',
          'url': 'https://raw.github.com/ghempton/ember-script/master/LICENSE'
        }]
    };
  });
  require.define('/node_modules/escodegen/escodegen.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, isArray, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse = require('/node_modules/escodegen/node_modules/estraverse/estraverse.js', module);
      esutils = require('/node_modules/escodegen/node_modules/esutils/lib/utils.js', module);
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
      };
      BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
      };
      function getDefaultOptions() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: '    ',
              base: 0,
              adjustMultilineComment: false
            },
            newline: '\n',
            space: ' ',
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: 'single',
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false,
            parenthesizedComprehensionBlock: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          verbatim: null
        };
      }
      function stringRepeat(str, num) {
        var result = '';
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function hasLineTerminator(str) {
        return /[\r\n]/g.test(str);
      }
      function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }
      function updateDeeply(target, override) {
        var key, val;
        function isHashObject(target) {
          return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val);
              } else {
                target[key] = updateDeeply({}, val);
              }
            } else {
              target[key] = val;
            }
          }
        }
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
          throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
          throw new Error('Numeric literal whose value is negative');
        }
        if (value === 1 / 0) {
          return json ? 'null' : renumber ? '1e400' : '1e+400';
        }
        result = '' + value;
        if (!renumber || result.length < 3) {
          return result;
        }
        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 48 && point === 1) {
          point = 0;
          result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
          exponent = +temp.slice(pos + 1);
          temp = temp.slice(0, pos);
        }
        if (point >= 0) {
          exponent -= temp.length - point - 1;
          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 48) {
          --pos;
        }
        if (pos !== 0) {
          exponent -= pos;
          temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
          temp += 'e' + exponent;
        }
        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
          result = temp;
        }
        return result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        if ((ch & ~1) === 8232) {
          return (previousIsBackslash ? 'u' : '\\u') + (ch === 8232 ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {
          return (previousIsBackslash ? '' : '\\') + (ch === 10 ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
          match = result.match(/\/([^/]*)$/);
          if (!match) {
            return result;
          }
          flags = match[1];
          result = '';
          characterInBrack = false;
          previousIsBackslash = false;
          for (i = 0, iz = reg.source.length; i < iz; ++i) {
            ch = reg.source.charCodeAt(i);
            if (!previousIsBackslash) {
              if (characterInBrack) {
                if (ch === 93) {
                  characterInBrack = false;
                }
              } else {
                if (ch === 47) {
                  result += '\\';
                } else if (ch === 91) {
                  characterInBrack = true;
                }
              }
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = ch === 92;
            } else {
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = false;
            }
          }
          return '/' + result + '/' + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';
        switch (code) {
        case 8:
          result += 'b';
          break;
        case 12:
          result += 'f';
          break;
        case 9:
          result += 't';
          break;
        default:
          hex = code.toString(16).toUpperCase();
          if (json || code > 255) {
            result += 'u' + '0000'.slice(hex.length) + hex;
          } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
            result += '0';
          } else if (code === 11) {
            result += 'x0B';
          } else {
            result += 'x' + '00'.slice(hex.length) + hex;
          }
          break;
        }
        return result;
      }
      function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 92:
          result += '\\';
          break;
        case 10:
          result += 'n';
          break;
        case 13:
          result += 'r';
          break;
        case 8232:
          result += 'u2028';
          break;
        case 8233:
          result += 'u2029';
          break;
        default:
          throw new Error('Incorrectly classified character');
        }
        return result;
      }
      function escapeDirective(str) {
        var i, iz, code, quote;
        quote = quotes === 'double' ? '"' : "'";
        for (i = 0, iz = str.length; i < iz; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            quote = '"';
            break;
          } else if (code === 34) {
            quote = "'";
            break;
          } else if (code === 92) {
            ++i;
          }
        }
        return quote + str + quote;
      }
      function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            ++singleQuotes;
          } else if (code === 34) {
            ++doubleQuotes;
          } else if (code === 47 && json) {
            result += '\\';
          } else if (esutils.code.isLineTerminator(code) || code === 92) {
            result += escapeDisallowedCharacter(code);
            continue;
          } else if (json && code < 32 || !(json || escapeless || code >= 32 && code <= 126)) {
            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
            continue;
          }
          result += String.fromCharCode(code);
        }
        single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
        quote = single ? "'" : '"';
        if (!(single ? singleQuotes : doubleQuotes)) {
          return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39 && single || code === 34 && !single) {
            result += '\\';
          }
          result += String.fromCharCode(code);
        }
        return result + quote;
      }
      function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
          elem = arr[i];
          result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
          if (isArray(generated)) {
            return flattenToString(generated);
          } else {
            return generated;
          }
        }
        if (node == null) {
          if (generated instanceof SourceNode) {
            return generated;
          } else {
            node = {};
          }
        }
        if (node.loc == null) {
          return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
      }
      function noEmptySpace() {
        return space ? space : ' ';
      }
      function join(left, right) {
        var leftSource = toSourceNodeWhenNeeded(left).toString(), rightSource = toSourceNodeWhenNeeded(right).toString(), leftCharCode = leftSource.charCodeAt(leftSource.length - 1), rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
          return [
            left,
            noEmptySpace(),
            right
          ];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
          return [
            left,
            right
          ];
        }
        return [
          left,
          space,
          right
        ];
      }
      function addIndent(stmt) {
        return [
          base,
          stmt
        ];
      }
      function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
      }
      function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
            break;
          }
        }
        return str.length - 1 - i;
      }
      function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;
        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array.length; i < len; ++i) {
          line = array[i];
          j = 0;
          while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
            ++j;
          }
          if (spaces > j) {
            spaces = j;
          }
        }
        if (typeof specialBase !== 'undefined') {
          previousBase = base;
          if (array[1][spaces] === '*') {
            specialBase += ' ';
          }
          base = specialBase;
        } else {
          if (spaces & 1) {
            --spaces;
          }
          previousBase = base;
        }
        for (i = 1, len = array.length; i < len; ++i) {
          sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
          array[i] = sourceMap ? sn.join('') : sn;
        }
        base = previousBase;
        return array.join('\n');
      }
      function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
          if (endsWithLineTerminator(comment.value)) {
            return '//' + comment.value;
          } else {
            return '//' + comment.value + '\n';
          }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
          return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
      }
      function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          save = result;
          comment = stmt.leadingComments[0];
          result = [];
          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
            result.push('\n');
          }
          result.push(generateComment(comment));
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push('\n');
          }
          for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
            comment = stmt.leadingComments[i];
            fragment = [generateComment(comment)];
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              fragment.push('\n');
            }
            result.push(addIndent(fragment));
          }
          result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([
            base,
            result,
            indent
          ]).toString()));
          for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
            comment = stmt.trailingComments[i];
            if (tailingToStatement) {
              if (i === 0) {
                result = [
                  result,
                  indent
                ];
              } else {
                result = [
                  result,
                  specialBase
                ];
              }
              result.push(generateComment(comment, specialBase));
            } else {
              result = [
                result,
                addIndent(generateComment(comment))
              ];
            }
            if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result = [
                result,
                '\n'
              ];
            }
          }
        }
        return result;
      }
      function parenthesize(text, current, should) {
        if (current < should) {
          return [
            '(',
            text,
            ')'
          ];
        }
        return text;
      }
      function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;
        noLeadingComment = !extra.comment || !stmt.leadingComments;
        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
          return [
            space,
            generateStatement(stmt, { functionBody: functionBody })
          ];
        }
        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
          return ';';
        }
        withIndent(function () {
          result = [
            newline,
            addIndent(generateStatement(stmt, {
              semicolonOptional: semicolonOptional,
              functionBody: functionBody
            }))
          ];
        });
        return result;
      }
      function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
          return [
            result,
            space
          ];
        }
        if (ends) {
          return [
            result,
            base
          ];
        }
        return [
          result,
          newline,
          base
        ];
      }
      function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
          result[i] = newline + base + result[i];
        }
        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNodeWhenNeeded(result, expr);
      }
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generatePattern(node, options) {
        var result;
        if (node.type === Syntax.Identifier) {
          result = generateIdentifier(node);
        } else {
          result = generateExpression(node, {
            precedence: options.precedence,
            allowIn: options.allowIn,
            allowCall: true
          });
        }
        return result;
      }
      function generateFunctionBody(node) {
        var result, i, len, expr, arrow;
        arrow = node.type === Syntax.ArrowFunctionExpression;
        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
          result = [generateIdentifier(node.params[0])];
        } else {
          result = ['('];
          for (i = 0, len = node.params.length; i < len; ++i) {
            result.push(generatePattern(node.params[i], {
              precedence: Precedence.Assignment,
              allowIn: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result.push(')');
        }
        if (arrow) {
          result.push(space);
          result.push('=>');
        }
        if (node.expression) {
          result.push(space);
          expr = generateExpression(node.body, {
            precedence: Precedence.Assignment,
            allowIn: true,
            allowCall: true
          });
          if (expr.toString().charAt(0) === '{') {
            expr = [
              '(',
              expr,
              ')'
            ];
          }
          result.push(expr);
        } else {
          result.push(maybeBlock(node.body, false, true));
        }
        return result;
      }
      function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
        var result = ['for' + space + '('];
        withIndent(function () {
          if (stmt.left.type === Syntax.VariableDeclaration) {
            withIndent(function () {
              result.push(stmt.left.kind + noEmptySpace());
              result.push(generateStatement(stmt.left.declarations[0], { allowIn: false }));
            });
          } else {
            result.push(generateExpression(stmt.left, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true
            }));
          }
          result = join(result, operator);
          result = [
            join(result, generateExpression(stmt.right, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })),
            ')'
          ];
        });
        result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
        return result;
      }
      function generateExpression(expr, option) {
        var result, precedence, type, currentPrecedence, i, len, raw, fragment, multiline, leftCharCode, leftSource, rightCharCode, allowIn, allowCall, allowUnparenthesizedNew, property, isGenerator;
        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;
        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
          return generateVerbatim(expr, option);
        }
        switch (type) {
        case Syntax.SequenceExpression:
          result = [];
          allowIn |= Precedence.Sequence < precedence;
          for (i = 0, len = expr.expressions.length; i < len; ++i) {
            result.push(generateExpression(expr.expressions[i], {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result = parenthesize(result, Precedence.Sequence, precedence);
          break;
        case Syntax.AssignmentExpression:
          allowIn |= Precedence.Assignment < precedence;
          result = parenthesize([
            generateExpression(expr.left, {
              precedence: Precedence.Call,
              allowIn: allowIn,
              allowCall: true
            }),
            space + expr.operator + space,
            generateExpression(expr.right, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            })
          ], Precedence.Assignment, precedence);
          break;
        case Syntax.ArrowFunctionExpression:
          allowIn |= Precedence.ArrowFunction < precedence;
          result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
          break;
        case Syntax.ConditionalExpression:
          allowIn |= Precedence.Conditional < precedence;
          result = parenthesize([
            generateExpression(expr.test, {
              precedence: Precedence.LogicalOR,
              allowIn: allowIn,
              allowCall: true
            }),
            space + '?' + space,
            generateExpression(expr.consequent, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            }),
            space + ':' + space,
            generateExpression(expr.alternate, {
              precedence: Precedence.Assignment,
              allowIn: allowIn,
              allowCall: true
            })
          ], Precedence.Conditional, precedence);
          break;
        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
          currentPrecedence = BinaryPrecedence[expr.operator];
          allowIn |= currentPrecedence < precedence;
          fragment = generateExpression(expr.left, {
            precedence: currentPrecedence,
            allowIn: allowIn,
            allowCall: true
          });
          leftSource = fragment.toString();
          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
            result = [
              fragment,
              noEmptySpace(),
              expr.operator
            ];
          } else {
            result = join(fragment, expr.operator);
          }
          fragment = generateExpression(expr.right, {
            precedence: currentPrecedence + 1,
            allowIn: allowIn,
            allowCall: true
          });
          if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result = join(result, fragment);
          }
          if (expr.operator === 'in' && !allowIn) {
            result = [
              '(',
              result,
              ')'
            ];
          } else {
            result = parenthesize(result, currentPrecedence, precedence);
          }
          break;
        case Syntax.CallExpression:
          result = [generateExpression(expr.callee, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true,
              allowUnparenthesizedNew: false
            })];
          result.push('(');
          for (i = 0, len = expr['arguments'].length; i < len; ++i) {
            result.push(generateExpression(expr['arguments'][i], {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            }));
            if (i + 1 < len) {
              result.push(',' + space);
            }
          }
          result.push(')');
          if (!allowCall) {
            result = [
              '(',
              result,
              ')'
            ];
          } else {
            result = parenthesize(result, Precedence.Call, precedence);
          }
          break;
        case Syntax.NewExpression:
          len = expr['arguments'].length;
          allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;
          result = join('new', generateExpression(expr.callee, {
            precedence: Precedence.New,
            allowIn: true,
            allowCall: false,
            allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
          }));
          if (!allowUnparenthesizedNew || parentheses || len > 0) {
            result.push('(');
            for (i = 0; i < len; ++i) {
              result.push(generateExpression(expr['arguments'][i], {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
              }));
              if (i + 1 < len) {
                result.push(',' + space);
              }
            }
            result.push(')');
          }
          result = parenthesize(result, Precedence.New, precedence);
          break;
        case Syntax.MemberExpression:
          result = [generateExpression(expr.object, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: allowCall,
              allowUnparenthesizedNew: false
            })];
          if (expr.computed) {
            result.push('[');
            result.push(generateExpression(expr.property, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: allowCall
            }));
            result.push(']');
          } else {
            if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                result.push('.');
              }
            }
            result.push('.');
            result.push(generateIdentifier(expr.property));
          }
          result = parenthesize(result, Precedence.Member, precedence);
          break;
        case Syntax.UnaryExpression:
          fragment = generateExpression(expr.argument, {
            precedence: Precedence.Unary,
            allowIn: true,
            allowCall: true
          });
          if (space === '') {
            result = join(expr.operator, fragment);
          } else {
            result = [expr.operator];
            if (expr.operator.length > 2) {
              result = join(result, fragment);
            } else {
              leftSource = toSourceNodeWhenNeeded(result).toString();
              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
              rightCharCode = fragment.toString().charCodeAt(0);
              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode)) {
                result.push(noEmptySpace());
                result.push(fragment);
              } else {
                result.push(fragment);
              }
            }
          }
          result = parenthesize(result, Precedence.Unary, precedence);
          break;
        case Syntax.YieldExpression:
          if (expr.delegate) {
            result = 'yield*';
          } else {
            result = 'yield';
          }
          if (expr.argument) {
            result = join(result, generateExpression(expr.argument, {
              precedence: Precedence.Yield,
              allowIn: true,
              allowCall: true
            }));
          }
          result = parenthesize(result, Precedence.Yield, precedence);
          break;
        case Syntax.UpdateExpression:
          if (expr.prefix) {
            result = parenthesize([
              expr.operator,
              generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
              })
            ], Precedence.Unary, precedence);
          } else {
            result = parenthesize([
              generateExpression(expr.argument, {
                precedence: Precedence.Postfix,
                allowIn: true,
                allowCall: true
              }),
              expr.operator
            ], Precedence.Postfix, precedence);
          }
          break;
        case Syntax.FunctionExpression:
          isGenerator = expr.generator && !extra.moz.starlessGenerator;
          result = isGenerator ? 'function*' : 'function';
          if (expr.id) {
            result = [
              result,
              isGenerator ? space : noEmptySpace(),
              generateIdentifier(expr.id),
              generateFunctionBody(expr)
            ];
          } else {
            result = [
              result + space,
              generateFunctionBody(expr)
            ];
          }
          break;
        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
          if (!expr.elements.length) {
            result = '[]';
            break;
          }
          multiline = expr.elements.length > 1;
          result = [
            '[',
            multiline ? newline : ''
          ];
          withIndent(function (indent) {
            for (i = 0, len = expr.elements.length; i < len; ++i) {
              if (!expr.elements[i]) {
                if (multiline) {
                  result.push(indent);
                }
                if (i + 1 === len) {
                  result.push(',');
                }
              } else {
                result.push(multiline ? indent : '');
                result.push(generateExpression(expr.elements[i], {
                  precedence: Precedence.Assignment,
                  allowIn: true,
                  allowCall: true
                }));
              }
              if (i + 1 < len) {
                result.push(',' + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : '');
          result.push(']');
          break;
        case Syntax.Property:
          if (expr.kind === 'get' || expr.kind === 'set') {
            result = [
              expr.kind,
              noEmptySpace(),
              generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              generateFunctionBody(expr.value)
            ];
          } else {
            if (expr.shorthand) {
              result = generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              });
            } else if (expr.method) {
              result = [];
              if (expr.value.generator) {
                result.push('*');
              }
              result.push(generateExpression(expr.key, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(generateFunctionBody(expr.value));
            } else {
              result = [
                generateExpression(expr.key, {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                }),
                ':' + space,
                generateExpression(expr.value, {
                  precedence: Precedence.Assignment,
                  allowIn: true,
                  allowCall: true
                })
              ];
            }
          }
          break;
        case Syntax.ObjectExpression:
          if (!expr.properties.length) {
            result = '{}';
            break;
          }
          multiline = expr.properties.length > 1;
          withIndent(function () {
            fragment = generateExpression(expr.properties[0], {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true,
              type: Syntax.Property
            });
          });
          if (!multiline) {
            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result = [
                '{',
                space,
                fragment,
                space,
                '}'
              ];
              break;
            }
          }
          withIndent(function (indent) {
            result = [
              '{',
              newline,
              indent,
              fragment
            ];
            if (multiline) {
              result.push(',' + newline);
              for (i = 1, len = expr.properties.length; i < len; ++i) {
                result.push(indent);
                result.push(generateExpression(expr.properties[i], {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true,
                  type: Syntax.Property
                }));
                if (i + 1 < len) {
                  result.push(',' + newline);
                }
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base);
          result.push('}');
          break;
        case Syntax.ObjectPattern:
          if (!expr.properties.length) {
            result = '{}';
            break;
          }
          multiline = false;
          if (expr.properties.length === 1) {
            property = expr.properties[0];
            if (property.value.type !== Syntax.Identifier) {
              multiline = true;
            }
          } else {
            for (i = 0, len = expr.properties.length; i < len; ++i) {
              property = expr.properties[i];
              if (!property.shorthand) {
                multiline = true;
                break;
              }
            }
          }
          result = [
            '{',
            multiline ? newline : ''
          ];
          withIndent(function (indent) {
            for (i = 0, len = expr.properties.length; i < len; ++i) {
              result.push(multiline ? indent : '');
              result.push(generateExpression(expr.properties[i], {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              if (i + 1 < len) {
                result.push(',' + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base : '');
          result.push('}');
          break;
        case Syntax.ThisExpression:
          result = 'this';
          break;
        case Syntax.Identifier:
          result = generateIdentifier(expr);
          break;
        case Syntax.Literal:
          if (expr.hasOwnProperty('raw') && parse) {
            try {
              raw = parse(expr.raw).body[0].expression;
              if (raw.type === Syntax.Literal) {
                if (raw.value === expr.value) {
                  result = expr.raw;
                  break;
                }
              }
            } catch (e) {
            }
          }
          if (expr.value === null) {
            result = 'null';
            break;
          }
          if (typeof expr.value === 'string') {
            result = escapeString(expr.value);
            break;
          }
          if (typeof expr.value === 'number') {
            result = generateNumber(expr.value);
            break;
          }
          if (typeof expr.value === 'boolean') {
            result = expr.value ? 'true' : 'false';
            break;
          }
          result = generateRegExp(expr.value);
          break;
        case Syntax.GeneratorExpression:
        case Syntax.ComprehensionExpression:
          result = type === Syntax.GeneratorExpression ? ['('] : ['['];
          if (extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = generateExpression(expr.body, {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            });
            result.push(fragment);
          }
          if (expr.blocks) {
            withIndent(function () {
              for (i = 0, len = expr.blocks.length; i < len; ++i) {
                fragment = generateExpression(expr.blocks[i], {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                });
                if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                  result = join(result, fragment);
                } else {
                  result.push(fragment);
                }
              }
            });
          }
          if (expr.filter) {
            result = join(result, 'if' + space);
            fragment = generateExpression(expr.filter, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            });
            if (extra.moz.parenthesizedComprehensionBlock) {
              result = join(result, [
                '(',
                fragment,
                ')'
              ]);
            } else {
              result = join(result, fragment);
            }
          }
          if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = generateExpression(expr.body, {
              precedence: Precedence.Assignment,
              allowIn: true,
              allowCall: true
            });
            result = join(result, fragment);
          }
          result.push(type === Syntax.GeneratorExpression ? ')' : ']');
          break;
        case Syntax.ComprehensionBlock:
          if (expr.left.type === Syntax.VariableDeclaration) {
            fragment = [
              expr.left.kind,
              noEmptySpace(),
              generateStatement(expr.left.declarations[0], { allowIn: false })
            ];
          } else {
            fragment = generateExpression(expr.left, {
              precedence: Precedence.Call,
              allowIn: true,
              allowCall: true
            });
          }
          fragment = join(fragment, expr.of ? 'of' : 'in');
          fragment = join(fragment, generateExpression(expr.right, {
            precedence: Precedence.Sequence,
            allowIn: true,
            allowCall: true
          }));
          if (extra.moz.parenthesizedComprehensionBlock) {
            result = [
              'for' + space + '(',
              fragment,
              ')'
            ];
          } else {
            result = join('for' + space, fragment);
          }
          break;
        default:
          throw new Error('Unknown expression type: ' + expr.type);
        }
        return toSourceNodeWhenNeeded(result, expr);
      }
      function generateStatement(stmt, option) {
        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon, isGenerator;
        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
          allowIn = option.allowIn === undefined || option.allowIn;
          if (!semicolons && option.semicolonOptional === true) {
            semicolon = '';
          }
          functionBody = option.functionBody;
          directiveContext = option.directiveContext;
        }
        switch (stmt.type) {
        case Syntax.BlockStatement:
          result = [
            '{',
            newline
          ];
          withIndent(function () {
            for (i = 0, len = stmt.body.length; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.body[i], {
                semicolonOptional: i === len - 1,
                directiveContext: functionBody
              }));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          result.push(addIndent('}'));
          break;
        case Syntax.BreakStatement:
          if (stmt.label) {
            result = 'break ' + stmt.label.name + semicolon;
          } else {
            result = 'break' + semicolon;
          }
          break;
        case Syntax.ContinueStatement:
          if (stmt.label) {
            result = 'continue ' + stmt.label.name + semicolon;
          } else {
            result = 'continue' + semicolon;
          }
          break;
        case Syntax.DirectiveStatement:
          if (stmt.raw) {
            result = stmt.raw + semicolon;
          } else {
            result = escapeDirective(stmt.directive) + semicolon;
          }
          break;
        case Syntax.DoWhileStatement:
          result = join('do', maybeBlock(stmt.body));
          result = maybeBlockSuffix(stmt.body, result);
          result = join(result, [
            'while' + space + '(',
            generateExpression(stmt.test, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            }),
            ')' + semicolon
          ]);
          break;
        case Syntax.CatchClause:
          withIndent(function () {
            var guard;
            result = [
              'catch' + space + '(',
              generateExpression(stmt.param, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
            if (stmt.guard) {
              guard = generateExpression(stmt.guard, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              });
              result.splice(2, 0, ' if ', guard);
            }
          });
          result.push(maybeBlock(stmt.body));
          break;
        case Syntax.DebuggerStatement:
          result = 'debugger' + semicolon;
          break;
        case Syntax.EmptyStatement:
          result = ';';
          break;
        case Syntax.ExportDeclaration:
          result = 'export ';
          if (stmt.declaration) {
            result = [
              result,
              generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' })
            ];
            break;
          }
          break;
        case Syntax.ExpressionStatement:
          result = [generateExpression(stmt.expression, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })];
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.charAt(0) === '{' || fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0 || directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
            result = [
              '(',
              result,
              ')' + semicolon
            ];
          } else {
            result.push(semicolon);
          }
          break;
        case Syntax.VariableDeclarator:
          if (stmt.init) {
            result = [
              generateExpression(stmt.id, {
                precedence: Precedence.Assignment,
                allowIn: allowIn,
                allowCall: true
              }),
              space,
              '=',
              space,
              generateExpression(stmt.init, {
                precedence: Precedence.Assignment,
                allowIn: allowIn,
                allowCall: true
              })
            ];
          } else {
            result = generatePattern(stmt.id, {
              precedence: Precedence.Assignment,
              allowIn: allowIn
            });
          }
          break;
        case Syntax.VariableDeclaration:
          result = [stmt.kind];
          if (stmt.declarations.length === 1 && stmt.declarations[0].init && stmt.declarations[0].init.type === Syntax.FunctionExpression) {
            result.push(noEmptySpace());
            result.push(generateStatement(stmt.declarations[0], { allowIn: allowIn }));
          } else {
            withIndent(function () {
              node = stmt.declarations[0];
              if (extra.comment && node.leadingComments) {
                result.push('\n');
                result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
              } else {
                result.push(noEmptySpace());
                result.push(generateStatement(node, { allowIn: allowIn }));
              }
              for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                node = stmt.declarations[i];
                if (extra.comment && node.leadingComments) {
                  result.push(',' + newline);
                  result.push(addIndent(generateStatement(node, { allowIn: allowIn })));
                } else {
                  result.push(',' + space);
                  result.push(generateStatement(node, { allowIn: allowIn }));
                }
              }
            });
          }
          result.push(semicolon);
          break;
        case Syntax.ThrowStatement:
          result = [
            join('throw', generateExpression(stmt.argument, {
              precedence: Precedence.Sequence,
              allowIn: true,
              allowCall: true
            })),
            semicolon
          ];
          break;
        case Syntax.TryStatement:
          result = [
            'try',
            maybeBlock(stmt.block)
          ];
          result = maybeBlockSuffix(stmt.block, result);
          if (stmt.handlers) {
            for (i = 0, len = stmt.handlers.length; i < len; ++i) {
              result = join(result, generateStatement(stmt.handlers[i]));
              if (stmt.finalizer || i + 1 !== len) {
                result = maybeBlockSuffix(stmt.handlers[i].body, result);
              }
            }
          } else {
            stmt.guardedHandlers = stmt.guardedHandlers || [];
            for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
              result = join(result, generateStatement(stmt.guardedHandlers[i]));
              if (stmt.finalizer || i + 1 !== len) {
                result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
              }
            }
            if (stmt.handler) {
              if (isArray(stmt.handler)) {
                for (i = 0, len = stmt.handler.length; i < len; ++i) {
                  result = join(result, generateStatement(stmt.handler[i]));
                  if (stmt.finalizer || i + 1 !== len) {
                    result = maybeBlockSuffix(stmt.handler[i].body, result);
                  }
                }
              } else {
                result = join(result, generateStatement(stmt.handler));
                if (stmt.finalizer) {
                  result = maybeBlockSuffix(stmt.handler.body, result);
                }
              }
            }
          }
          if (stmt.finalizer) {
            result = join(result, [
              'finally',
              maybeBlock(stmt.finalizer)
            ]);
          }
          break;
        case Syntax.SwitchStatement:
          withIndent(function () {
            result = [
              'switch' + space + '(',
              generateExpression(stmt.discriminant, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')' + space + '{' + newline
            ];
          });
          if (stmt.cases) {
            for (i = 0, len = stmt.cases.length; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.cases[i], { semicolonOptional: i === len - 1 }));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          }
          result.push(addIndent('}'));
          break;
        case Syntax.SwitchCase:
          withIndent(function () {
            if (stmt.test) {
              result = [
                join('case', generateExpression(stmt.test, {
                  precedence: Precedence.Sequence,
                  allowIn: true,
                  allowCall: true
                })),
                ':'
              ];
            } else {
              result = ['default:'];
            }
            i = 0;
            len = stmt.consequent.length;
            if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
              fragment = maybeBlock(stmt.consequent[0]);
              result.push(fragment);
              i = 1;
            }
            if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            for (; i < len; ++i) {
              fragment = addIndent(generateStatement(stmt.consequent[i], { semicolonOptional: i === len - 1 && semicolon === '' }));
              result.push(fragment);
              if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          break;
        case Syntax.IfStatement:
          withIndent(function () {
            result = [
              'if' + space + '(',
              generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          if (stmt.alternate) {
            result.push(maybeBlock(stmt.consequent));
            result = maybeBlockSuffix(stmt.consequent, result);
            if (stmt.alternate.type === Syntax.IfStatement) {
              result = join(result, [
                'else ',
                generateStatement(stmt.alternate, { semicolonOptional: semicolon === '' })
              ]);
            } else {
              result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
            }
          } else {
            result.push(maybeBlock(stmt.consequent, semicolon === ''));
          }
          break;
        case Syntax.ForStatement:
          withIndent(function () {
            result = ['for' + space + '('];
            if (stmt.init) {
              if (stmt.init.type === Syntax.VariableDeclaration) {
                result.push(generateStatement(stmt.init, { allowIn: false }));
              } else {
                result.push(generateExpression(stmt.init, {
                  precedence: Precedence.Sequence,
                  allowIn: false,
                  allowCall: true
                }));
                result.push(';');
              }
            } else {
              result.push(';');
            }
            if (stmt.test) {
              result.push(space);
              result.push(generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(';');
            } else {
              result.push(';');
            }
            if (stmt.update) {
              result.push(space);
              result.push(generateExpression(stmt.update, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }));
              result.push(')');
            } else {
              result.push(')');
            }
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        case Syntax.ForInStatement:
          result = generateIterationForStatement('in', stmt, semicolon === '');
          break;
        case Syntax.ForOfStatement:
          result = generateIterationForStatement('of', stmt, semicolon === '');
          break;
        case Syntax.LabeledStatement:
          result = [
            stmt.label.name + ':',
            maybeBlock(stmt.body, semicolon === '')
          ];
          break;
        case Syntax.Program:
          len = stmt.body.length;
          result = [safeConcatenation && len > 0 ? '\n' : ''];
          for (i = 0; i < len; ++i) {
            fragment = addIndent(generateStatement(stmt.body[i], {
              semicolonOptional: !safeConcatenation && i === len - 1,
              directiveContext: true
            }));
            result.push(fragment);
            if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
          break;
        case Syntax.FunctionDeclaration:
          isGenerator = stmt.generator && !extra.moz.starlessGenerator;
          result = [
            isGenerator ? 'function*' : 'function',
            isGenerator ? space : noEmptySpace(),
            generateIdentifier(stmt.id),
            generateFunctionBody(stmt)
          ];
          break;
        case Syntax.ReturnStatement:
          if (stmt.argument) {
            result = [
              join('return', generateExpression(stmt.argument, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              })),
              semicolon
            ];
          } else {
            result = ['return' + semicolon];
          }
          break;
        case Syntax.WhileStatement:
          withIndent(function () {
            result = [
              'while' + space + '(',
              generateExpression(stmt.test, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        case Syntax.WithStatement:
          withIndent(function () {
            result = [
              'with' + space + '(',
              generateExpression(stmt.object, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
              }),
              ')'
            ];
          });
          result.push(maybeBlock(stmt.body, semicolon === ''));
          break;
        default:
          throw new Error('Unknown statement type: ' + stmt.type);
        }
        if (extra.comment) {
          result = addCommentsToStatement(stmt, result);
        }
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
          result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }
        return toSourceNodeWhenNeeded(result, stmt);
      }
      function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;
        if (options != null) {
          if (typeof options.indent === 'string') {
            defaultOptions.format.indent.style = options.indent;
          }
          if (typeof options.base === 'number') {
            defaultOptions.format.indent.base = options.base;
          }
          options = updateDeeply(defaultOptions, options);
          indent = options.format.indent.style;
          if (typeof options.base === 'string') {
            base = options.base;
          } else {
            base = stringRepeat(indent, options.format.indent.base);
          }
        } else {
          options = defaultOptions;
          indent = options.format.indent.style;
          base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
          newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;
        if (sourceMap) {
          if (!exports.browser) {
            SourceNode = require('/node_modules/source-map/lib/source-map.js', module).SourceNode;
          } else {
            SourceNode = global.sourceMap.SourceNode;
          }
        }
        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
          result = generateStatement(node);
          break;
        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:
          result = generateExpression(node, {
            precedence: Precedence.Sequence,
            allowIn: true,
            allowCall: true
          });
          break;
        default:
          throw new Error('Unknown node type: ' + node.type);
        }
        if (!sourceMap) {
          return result.toString();
        }
        pair = result.toStringWithSourceMap({
          file: options.file,
          sourceRoot: options.sourceMapRoot
        });
        if (options.sourceContent) {
          pair.map.setSourceContent(options.sourceMap, options.sourceContent);
        }
        if (options.sourceMapWithCode) {
          return pair;
        }
        return pair.map.toString();
      }
      FORMAT_MINIFY = {
        indent: {
          style: '',
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      };
      FORMAT_DEFAULTS = getDefaultOptions().format;
      exports.version = require('/node_modules/escodegen/package.json', module).version;
      exports.generate = generate;
      exports.attachComments = estraverse.attachComments;
      exports.browser = false;
      exports.FORMAT_MINIFY = FORMAT_MINIFY;
      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    }());
  });
  require.define('/node_modules/escodegen/package.json', function (module, exports, __dirname, __filename) {
    module.exports = {
      'name': 'escodegen',
      'description': 'ECMAScript code generator',
      'homepage': 'http://github.com/Constellation/escodegen',
      'main': 'escodegen.js',
      'bin': {
        'esgenerate': './bin/esgenerate.js',
        'escodegen': './bin/escodegen.js'
      },
      'version': '1.2.0',
      'engines': { 'node': '>=0.4.0' },
      'maintainers': [{
          'name': 'Yusuke Suzuki',
          'email': 'utatane.tea@gmail.com',
          'url': 'http://github.com/Constellation'
        }],
      'repository': {
        'type': 'git',
        'url': 'http://github.com/Constellation/escodegen.git'
      },
      'dependencies': {
        'esprima': '~1.0.4',
        'estraverse': '~1.5.0',
        'esutils': '~1.0.0',
        'source-map': '~0.1.30'
      },
      'optionalDependencies': { 'source-map': '~0.1.30' },
      'devDependencies': {
        'esprima-moz': '*',
        'q': '*',
        'bower': '*',
        'semver': '*',
        'chai': '~1.7.2',
        'gulp': '~3.5.0',
        'gulp-mocha': '~0.4.1',
        'gulp-eslint': '~0.1.2',
        'jshint-stylish': '~0.1.5',
        'gulp-jshint': '~1.4.0',
        'commonjs-everywhere': '~0.9.6'
      },
      'licenses': [{
          'type': 'BSD',
          'url': 'http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD'
        }],
      'scripts': {
        'test': 'gulp travis',
        'unit-test': 'gulp test',
        'lint': 'gulp lint',
        'release': 'node tools/release.js',
        'build-min': 'cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js',
        'build': 'cjsify -a path: tools/entry-point.js > escodegen.browser.js'
      },
      'readme': "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### Building browser bundle / minified browser bundle\n\nAt first, executing `npm install` to install the all dev dependencies.\nAfter that,\n\n    npm run-script build\n\nwill generate `escodegen.browser.js`, it is used on the browser environment.\n\nAnd,\n\n    npm run-script build-min\n\nwill generate minified `escodegen.browser.min.js`.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
      'readmeFilename': 'README.md',
      'bugs': { 'url': 'https://github.com/Constellation/escodegen/issues' },
      '_id': 'escodegen@1.2.0',
      '_from': 'escodegen@~1.2.0'
    };
  });
  require.define('/node_modules/source-map/lib/source-map.js', function (module, exports, __dirname, __filename) {
    exports.SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;
    exports.SourceMapConsumer = require('/node_modules/source-map/lib/source-map/source-map-consumer.js', module).SourceMapConsumer;
    exports.SourceNode = require('/node_modules/source-map/lib/source-map/source-node.js', module).SourceNode;
  });
  require.define('/node_modules/source-map/lib/source-map/source-node.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var SourceMapGenerator = require('/node_modules/source-map/lib/source-map/source-map-generator.js', module).SourceMapGenerator;
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine === undefined ? null : aLine;
        this.column = aColumn === undefined ? null : aColumn;
        this.source = aSource === undefined ? null : aSource;
        this.name = aName === undefined ? null : aName;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
        var node = new SourceNode;
        var remainingLines = aGeneratedCode.split('\n');
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              var code = '';
              addMappingWithCode(lastMapping, remainingLines.shift() + '\n');
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[0];
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + '\n');
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLines.length > 0) {
          if (lastMapping) {
            var lastLine = remainingLines.shift();
            if (remainingLines.length > 0)
              lastLine += '\n';
            addMappingWithCode(lastMapping, lastLine);
          }
          node.add(remainingLines.join('\n'));
        }
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content) {
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === undefined) {
            node.add(code);
          } else {
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, mapping.source, code, mapping.name));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk instanceof SourceNode || typeof aChunk === 'string') {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError('Expected a SourceNode, string, or an array of SourceNodes and strings. Got ' + aChunk);
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk instanceof SourceNode) {
            chunk.walk(aFn);
          } else {
            if (chunk !== '') {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild instanceof SourceNode) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i] instanceof SourceNode) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = '';
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
            code: '',
            line: 1,
            column: 0
          };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          chunk.split('').forEach(function (ch, idx, array) {
            if (ch === '\n') {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === array.length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          });
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return {
          code: generated.code,
          map: map
        };
      };
      exports.SourceNode = SourceNode;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/util.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = '';
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ':';
        }
        url += '//';
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + '@';
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ':' + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = path.charAt(0) === '/';
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === '.') {
            parts.splice(i, 1);
          } else if (part === '..') {
            up++;
          } else if (up > 0) {
            if (part === '') {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join('/');
        if (path === '') {
          path = isAbsolute ? '/' : '.';
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || '/';
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
      function relative(aRoot, aPath) {
        aRoot = aRoot.replace(/\/$/, '');
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == '/' && url && url.path == '/') {
          return aPath.slice(1);
        }
        return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;
      }
      exports.relative = relative;
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || '';
        var s2 = aStr2 || '';
        return (s1 > s2) - (s1 < s2);
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
        cmp = strcmp(mappingA.name, mappingB.name);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
        return mappingA.generatedColumn - mappingB.generatedColumn;
      }
      ;
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      ;
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    });
  });
  require.define('/node_modules/source-map/node_modules/amdefine/amdefine.js', function (module, exports, __dirname, __filename) {
    'use strict';
    function amdefine(module, requireFn) {
      'use strict';
      var defineCache = {}, loaderCache = {}, alreadyCalled = false, path = require('path', module), makeRequire, stringRequire;
      function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i += 1) {
          part = ary[i];
          if (part === '.') {
            ary.splice(i, 1);
            i -= 1;
          } else if (part === '..') {
            if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
              break;
            } else if (i > 0) {
              ary.splice(i - 1, 2);
              i -= 2;
            }
          }
        }
      }
      function normalize(name, baseName) {
        var baseParts;
        if (name && name.charAt(0) === '.') {
          if (baseName) {
            baseParts = baseName.split('/');
            baseParts = baseParts.slice(0, baseParts.length - 1);
            baseParts = baseParts.concat(name.split('/'));
            trimDots(baseParts);
            name = baseParts.join('/');
          }
        }
        return name;
      }
      function makeNormalize(relName) {
        return function (name) {
          return normalize(name, relName);
        };
      }
      function makeLoad(id) {
        function load(value) {
          loaderCache[id] = value;
        }
        load.fromText = function (id, text) {
          throw new Error('amdefine does not implement load.fromText');
        };
        return load;
      }
      makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
          if (typeof deps === 'string') {
            return stringRequire(systemRequire, exports, module, deps, relId);
          } else {
            deps = deps.map(function (depName) {
              return stringRequire(systemRequire, exports, module, depName, relId);
            });
            process.nextTick(function () {
              callback.apply(null, deps);
            });
          }
        }
        amdRequire.toUrl = function (filePath) {
          if (filePath.indexOf('.') === 0) {
            return normalize(filePath, path.dirname(module.filename));
          } else {
            return filePath;
          }
        };
        return amdRequire;
      };
      requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
      };
      function runFactory(id, deps, factory) {
        var r, e, m, result;
        if (id) {
          e = loaderCache[id] = {};
          m = {
            id: id,
            uri: __filename,
            exports: e
          };
          r = makeRequire(requireFn, e, m, id);
        } else {
          if (alreadyCalled) {
            throw new Error('amdefine with no module ID cannot be called more than once per file.');
          }
          alreadyCalled = true;
          e = module.exports;
          m = module;
          r = makeRequire(requireFn, e, m, module.id);
        }
        if (deps) {
          deps = deps.map(function (depName) {
            return r(depName);
          });
        }
        if (typeof factory === 'function') {
          result = factory.apply(m.exports, deps);
        } else {
          result = factory;
        }
        if (result !== undefined) {
          m.exports = result;
          if (id) {
            loaderCache[id] = m.exports;
          }
        }
      }
      stringRequire = function (systemRequire, exports, module, id, relId) {
        var index = id.indexOf('!'), originalId = id, prefix, plugin;
        if (index === -1) {
          id = normalize(id, relId);
          if (id === 'require') {
            return makeRequire(systemRequire, exports, module, relId);
          } else if (id === 'exports') {
            return exports;
          } else if (id === 'module') {
            return module;
          } else if (loaderCache.hasOwnProperty(id)) {
            return loaderCache[id];
          } else if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
          } else {
            if (systemRequire) {
              return systemRequire(originalId);
            } else {
              throw new Error('No module with ID: ' + id);
            }
          }
        } else {
          prefix = id.substring(0, index);
          id = id.substring(index + 1, id.length);
          plugin = stringRequire(systemRequire, exports, module, prefix, relId);
          if (plugin.normalize) {
            id = plugin.normalize(id, makeNormalize(relId));
          } else {
            id = normalize(id, relId);
          }
          if (loaderCache[id]) {
            return loaderCache[id];
          } else {
            plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
            return loaderCache[id];
          }
        }
      };
      function define(id, deps, factory) {
        if (Array.isArray(id)) {
          factory = deps;
          deps = id;
          id = undefined;
        } else if (typeof id !== 'string') {
          factory = id;
          id = deps = undefined;
        }
        if (deps && !Array.isArray(deps)) {
          factory = deps;
          deps = undefined;
        }
        if (!deps) {
          deps = [
            'require',
            'exports',
            'module'
          ];
        }
        if (id) {
          defineCache[id] = [
            id,
            deps,
            factory
          ];
        } else {
          runFactory(id, deps, factory);
        }
      }
      define.require = function (id) {
        if (loaderCache[id]) {
          return loaderCache[id];
        }
        if (defineCache[id]) {
          runFactory.apply(null, defineCache[id]);
          return loaderCache[id];
        }
      };
      define.amd = {};
      return define;
    }
    module.exports = amdefine;
  });
  require.define('path', function (module, exports, __dirname, __filename) {
    var isWindows = process.platform === 'win32';
    var util = require('util', module);
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    if (isWindows) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
      var splitPath = function (filename) {
        var result = splitDeviceRe.exec(filename), device = (result[1] || '') + (result[2] || ''), tail = result[3] || '';
        var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
        return [
          device,
          dir,
          basename,
          ext
        ];
      };
      var normalizeUNCRoot = function (device) {
        return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
      };
      exports.resolve = function () {
        var resolvedDevice = '', resolvedTail = '', resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1; i--) {
          var path;
          if (i >= 0) {
            path = arguments[i];
          } else if (!resolvedDevice) {
            path = process.cwd();
          } else {
            path = process.env['=' + resolvedDevice];
            if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
              path = resolvedDevice + '\\';
            }
          }
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = !!result[2] || isUnc, tail = result[3];
          if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
          if (!resolvedDevice) {
            resolvedDevice = device;
          }
          if (!resolvedAbsolute) {
            resolvedTail = tail + '\\' + resolvedTail;
            resolvedAbsolute = isAbsolute;
          }
          if (resolvedDevice && resolvedAbsolute) {
            break;
          }
        }
        if (isUnc) {
          resolvedDevice = normalizeUNCRoot(resolvedDevice);
        }
        function f(p) {
          return !!p;
        }
        resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f), !resolvedAbsolute).join('\\');
        return resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail || '.';
      };
      exports.normalize = function (path) {
        var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = device && device.charAt(1) !== ':', isAbsolute = !!result[2] || isUnc, tail = result[3], trailingSlash = /[\\\/]$/.test(tail);
        tail = normalizeArray(tail.split(/[\\\/]+/).filter(function (p) {
          return !!p;
        }), !isAbsolute).join('\\');
        if (!tail && !isAbsolute) {
          tail = '.';
        }
        if (tail && trailingSlash) {
          tail += '\\';
        }
        if (isUnc) {
          device = normalizeUNCRoot(device);
        }
        return device + (isAbsolute ? '\\' : '') + tail;
      };
      exports.join = function () {
        function f(p) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }
        var paths = Array.prototype.filter.call(arguments, f);
        var joined = paths.join('\\');
        if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
          joined = joined.replace(/^[\\\/]{2,}/, '\\');
        }
        return exports.normalize(joined);
      };
      exports.relative = function (from, to) {
        from = exports.resolve(from);
        to = exports.resolve(to);
        var lowerFrom = from.toLowerCase();
        var lowerTo = to.toLowerCase();
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '')
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '')
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var toParts = trim(to.split('\\'));
        var lowerFromParts = trim(lowerFrom.split('\\'));
        var lowerToParts = trim(lowerTo.split('\\'));
        var length = Math.min(lowerFromParts.length, lowerToParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (lowerFromParts[i] !== lowerToParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        if (samePartsLength == 0) {
          return to;
        }
        var outputParts = [];
        for (var i = samePartsLength; i < lowerFromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('\\');
      };
      exports.sep = '\\';
      exports.delimiter = ';';
    } else {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      var splitPath = function (filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      exports.resolve = function () {
        var resolvedPath = '', resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : process.cwd();
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
      };
      exports.normalize = function (path) {
        var isAbsolute = path.charAt(0) === '/', trailingSlash = path.substr(-1) === '/';
        path = normalizeArray(path.split('/').filter(function (p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      };
      exports.join = function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return exports.normalize(paths.filter(function (p, index) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }).join('/'));
      };
      exports.relative = function (from, to) {
        from = exports.resolve(from).substr(1);
        to = exports.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '')
              break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '')
              break;
          }
          if (start > end)
            return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      };
      exports.sep = '/';
      exports.delimiter = ':';
    }
    exports.dirname = function (path) {
      var result = splitPath(path), root = result[0], dir = result[1];
      if (!root && !dir) {
        return '.';
      }
      if (dir) {
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    };
    exports.basename = function (path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    exports.extname = function (path) {
      return splitPath(path)[3];
    };
    exports.exists = util.deprecate(function (path, callback) {
      require('fs', module).exists(path, callback);
    }, 'path.exists is now called `fs.exists`.');
    exports.existsSync = util.deprecate(function (path) {
      return require('fs', module).existsSync(path);
    }, 'path.existsSync is now called `fs.existsSync`.');
    if (isWindows) {
      exports._makeLong = function (path) {
        if (typeof path !== 'string')
          return path;
        if (!path) {
          return '';
        }
        var resolvedPath = exports.resolve(path);
        if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
          return '\\\\?\\' + resolvedPath;
        } else if (/^\\\\[^?.]/.test(resolvedPath)) {
          return '\\\\?\\UNC\\' + resolvedPath.substring(2);
        }
        return path;
      };
    } else {
      exports._makeLong = function (path) {
        return path;
      };
    }
  });
  require.define('util', function (module, exports, __dirname, __filename) {
    var formatRegExp = /%[sdj%]/g;
    exports.format = function (f) {
      if (typeof f !== 'string') {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%')
            return '%';
          if (i >= len)
            return x;
          switch (x) {
          case '%s':
            return String(args[i++]);
          case '%d':
            return Number(args[i++]);
          case '%j':
            return JSON.stringify(args[i++]);
          default:
            return x;
          }
        });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (x === null || typeof x !== 'object') {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function (fn, msg) {
      if (process.noDeprecation === true) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    exports.print = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(String(arguments[i]));
      }
    };
    exports.puts = function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        process.stdout.write(arguments[i] + '\n');
      }
    };
    exports.debug = function (x) {
      process.stderr.write('DEBUG: ' + x + '\n');
    };
    var error = exports.error = function (x) {
        for (var i = 0, len = arguments.length; i < len; ++i) {
          process.stderr.write(arguments[i] + '\n');
        }
      };
    function inspect(obj, opts) {
      var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (typeof opts === 'boolean') {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (typeof ctx.showHidden === 'undefined')
        ctx.showHidden = false;
      if (typeof ctx.depth === 'undefined')
        ctx.depth = 2;
      if (typeof ctx.colors === 'undefined')
        ctx.colors = false;
      if (typeof ctx.customInspect === 'undefined')
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      'bold': [
        1,
        22
      ],
      'italic': [
        3,
        23
      ],
      'underline': [
        4,
        24
      ],
      'inverse': [
        7,
        27
      ],
      'white': [
        37,
        39
      ],
      'grey': [
        90,
        39
      ],
      'black': [
        30,
        39
      ],
      'blue': [
        34,
        39
      ],
      'cyan': [
        36,
        39
      ],
      'green': [
        32,
        39
      ],
      'magenta': [
        35,
        39
      ],
      'red': [
        31,
        39
      ],
      'yellow': [
        33,
        39
      ]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && typeof value.inspect === 'function' && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        return String(value.inspect(recurseTimes));
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (keys.length === 0) {
        if (typeof value === 'function') {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '', array = false, braces = [
          '{',
          '}'
        ];
      if (isArray(value)) {
        array = true;
        braces = [
          '[',
          ']'
        ];
      }
      if (typeof value === 'function') {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');
      case 'string':
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      case 'number':
        return ctx.stylize('' + value, 'number');
      case 'boolean':
        return ctx.stylize('' + value, 'boolean');
      }
      if (value === null) {
        return ctx.stylize('null', 'null');
      }
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (recurseTimes === null) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0)
            numLinesEst++;
          return prev + cur.length + 1;
        }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
      return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
    }
    exports.isArray = isArray;
    function isRegExp(re) {
      return typeof re === 'object' && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    function isDate(d) {
      return typeof d === 'object' && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    function isError(e) {
      return typeof e === 'object' && objectToString(e) === '[object Error]';
    }
    exports.isError = isError;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    exports.p = exports.deprecate(function () {
      for (var i = 0, len = arguments.length; i < len; ++i) {
        error(exports.inspect(arguments[i]));
      }
    }, 'util.p: Use console.error() instead.');
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    var months = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ];
    function timestamp() {
      var d = new Date;
      var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(':');
      return [
        d.getDate(),
        months[d.getMonth()],
        time
      ].join(' ');
    }
    exports.log = function (msg) {
      exports.puts(timestamp() + ' - ' + msg.toString());
    };
    exports.exec = exports.deprecate(function () {
      return require('child_process', module).exec.apply(this, arguments);
    }, 'util.exec is now called `child_process.exec`.');
    function pump(readStream, writeStream, callback) {
      var callbackCalled = false;
      function call(a, b, c) {
        if (callback && !callbackCalled) {
          callback(a, b, c);
          callbackCalled = true;
        }
      }
      readStream.addListener('data', function (chunk) {
        if (writeStream.write(chunk) === false)
          readStream.pause();
      });
      writeStream.addListener('drain', function () {
        readStream.resume();
      });
      readStream.addListener('end', function () {
        writeStream.end();
      });
      readStream.addListener('close', function () {
        call();
      });
      readStream.addListener('error', function (err) {
        writeStream.end();
        call(err);
      });
      writeStream.addListener('error', function (err) {
        readStream.destroy();
        call(err);
      });
    }
    exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use readableStream.pipe() instead.');
    exports.inherits = function (ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
    exports._extend = function (origin, add) {
      if (!add || typeof add !== 'object')
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  });
  require.define('/node_modules/source-map/lib/source-map/source-map-generator.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, 'file', null);
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._sources = new ArraySet;
        this._names = new ArraySet;
        this._mappings = [];
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
        aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
          if (mapping.source) {
            newMapping.source = mapping.source;
            if (sourceRoot) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, 'generated');
        var original = util.getArg(aArgs, 'original', null);
        var source = util.getArg(aArgs, 'source', null);
        var name = util.getArg(aArgs, 'name', null);
        this._validateMapping(generated, original, source, name);
        if (source && !this._sources.has(source)) {
          this._sources.add(source);
        }
        if (name && !this._names.has(name)) {
          this._names.add(name);
        }
        this._mappings.push({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent !== null) {
          if (!this._sourcesContents) {
            this._sourcesContents = {};
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        if (!aSourceFile) {
          if (!aSourceMapConsumer.file) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
          }
          aSourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot) {
          aSourceFile = util.relative(sourceRoot, aSourceFile);
        }
        var newSources = new ArraySet;
        var newNames = new ArraySet;
        this._mappings.forEach(function (mapping) {
          if (mapping.source === aSourceFile && mapping.originalLine) {
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
            if (original.source !== null) {
              mapping.source = original.source;
              if (aSourceMapPath) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name !== null && mapping.name !== null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content) {
            if (sourceRoot) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var mapping;
        this._mappings.sort(util.compareByGeneratedPositions);
        for (var i = 0, len = this._mappings.length; i < len; i++) {
          mapping = this._mappings[i];
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              result += ';';
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
                continue;
              }
              result += ',';
            }
          }
          result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source) {
            result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
            previousSource = this._sources.indexOf(mapping.source);
            result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name) {
              result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
              previousName = this._names.indexOf(mapping.name);
            }
          }
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
            version: this._version,
            file: this._file,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
        if (this._sourceRoot) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this);
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/array-set.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet;
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/base64-vlq.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var base64 = require('/node_modules/source-map/lib/source-map/base64.js', module);
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = '';
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr) {
        var i = 0;
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (i >= strLen) {
            throw new Error('Expected more digits in base 64 VLQ value.');
          }
          digit = base64.decode(aStr.charAt(i++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        return {
          value: fromVLQSigned(result),
          rest: aStr.slice(i)
        };
      };
    });
  });
  require.define('/node_modules/source-map/lib/source-map/base64.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var charToIntMap = {};
      var intToCharMap = {};
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function (ch, index) {
        charToIntMap[ch] = index;
        intToCharMap[index] = ch;
      });
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError('Must be between 0 and 63: ' + aNumber);
      };
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError('Not a valid base 64 digit: ' + aChar);
      };
    });
  });
  require.define('/node_modules/source-map/lib/source-map/source-map-consumer.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      var util = require('/node_modules/source-map/lib/source-map/util.js', module);
      var binarySearch = require('/node_modules/source-map/lib/source-map/binary-search.js', module);
      var ArraySet = require('/node_modules/source-map/lib/source-map/array-set.js', module).ArraySet;
      var base64VLQ = require('/node_modules/source-map/lib/source-map/base64-vlq.js', module);
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
      SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
        var smc = Object.create(SourceMapConsumer.prototype);
        smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
        smc.file = aSourceMap._file;
        smc.__generatedMappings = aSourceMap._mappings.slice().sort(util.compareByGeneratedPositions);
        smc.__originalMappings = aSourceMap._mappings.slice().sort(util.compareByOriginalPositions);
        return smc;
      };
      SourceMapConsumer.prototype._version = 3;
      Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var mappingSeparator = /^[,;]/;
        var str = aStr;
        var mapping;
        var temp;
        while (str.length > 0) {
          if (str.charAt(0) === ';') {
            generatedLine++;
            str = str.slice(1);
            previousGeneratedColumn = 0;
          } else if (str.charAt(0) === ',') {
            str = str.slice(1);
          } else {
            mapping = {};
            mapping.generatedLine = generatedLine;
            temp = base64VLQ.decode(str);
            mapping.generatedColumn = previousGeneratedColumn + temp.value;
            previousGeneratedColumn = mapping.generatedColumn;
            str = temp.rest;
            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              temp = base64VLQ.decode(str);
              mapping.source = this._sources.at(previousSource + temp.value);
              previousSource += temp.value;
              str = temp.rest;
              if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
                throw new Error('Found a source, but no line and column');
              }
              temp = base64VLQ.decode(str);
              mapping.originalLine = previousOriginalLine + temp.value;
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              str = temp.rest;
              if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
                throw new Error('Found a source and line, but no column');
              }
              temp = base64VLQ.decode(str);
              mapping.originalColumn = previousOriginalColumn + temp.value;
              previousOriginalColumn = mapping.originalColumn;
              str = temp.rest;
              if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
                temp = base64VLQ.decode(str);
                mapping.name = this._names.at(previousName + temp.value);
                previousName += temp.value;
                str = temp.rest;
              }
            }
            this.__generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
              this.__originalMappings.push(mapping);
            }
          }
        }
        this.__generatedMappings.sort(util.compareByGeneratedPositions);
        this.__originalMappings.sort(util.compareByOriginalPositions);
      };
      SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator);
      };
      SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
        var mapping = this._findMapping(needle, this._generatedMappings, 'generatedLine', 'generatedColumn', util.compareByGeneratedPositions);
        if (mapping && mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source && this.sourceRoot) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {
        if (!this.sourcesContent) {
          return null;
        }
        if (this.sourceRoot) {
          aSource = util.relative(this.sourceRoot, aSource);
        }
        if (this._sources.has(aSource)) {
          return this.sourcesContent[this._sources.indexOf(aSource)];
        }
        var url;
        if (this.sourceRoot && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = aSource.replace(/^file:\/\//, '');
          if (url.scheme == 'file' && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == '/') && this._sources.has('/' + aSource)) {
            return this.sourcesContent[this._sources.indexOf('/' + aSource)];
          }
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      };
      SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
        if (this.sourceRoot) {
          needle.source = util.relative(this.sourceRoot, needle.source);
        }
        var mapping = this._findMapping(needle, this._originalMappings, 'originalLine', 'originalColumn', util.compareByOriginalPositions);
        if (mapping) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null)
          };
        }
        return {
          line: null,
          column: null
        };
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error('Unknown order of iteration.');
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source;
          if (source && sourceRoot) {
            source = util.join(sourceRoot, source);
          }
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name
          };
        }).forEach(aCallback, context);
      };
      exports.SourceMapConsumer = SourceMapConsumer;
    });
  });
  require.define('/node_modules/source-map/lib/source-map/binary-search.js', function (module, exports, __dirname, __filename) {
    if (typeof define !== 'function') {
      var define = require('/node_modules/source-map/node_modules/amdefine/amdefine.js', module)(module, require);
    }
    define(function (require, exports, module) {
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return aHaystack[mid];
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
          }
          return aHaystack[mid];
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
          }
          return aLow < 0 ? null : aHaystack[aLow];
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare) {
        return aHaystack.length > 0 ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare) : null;
      };
    });
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/utils.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      exports.code = require('/node_modules/escodegen/node_modules/esutils/lib/code.js', module);
      exports.keyword = require('/node_modules/escodegen/node_modules/esutils/lib/keyword.js', module);
    }());
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/keyword.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var code = require('/node_modules/escodegen/node_modules/esutils/lib/code.js', module);
      function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
          return true;
        default:
          return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
        case 2:
          return id === 'if' || id === 'in' || id === 'do';
        case 3:
          return id === 'var' || id === 'for' || id === 'new' || id === 'try';
        case 4:
          return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
        case 5:
          return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
        case 6:
          return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
        case 7:
          return id === 'default' || id === 'finally' || id === 'extends';
        case 8:
          return id === 'function' || id === 'continue' || id === 'debugger';
        case 10:
          return id === 'instanceof';
        default:
          return false;
        }
      }
      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }
      function isIdentifierName(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPart(ch) || ch === 92) {
            return false;
          }
        }
        return true;
      }
      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
      };
    }());
  });
  require.define('/node_modules/escodegen/node_modules/esutils/lib/code.js', function (module, exports, __dirname, __filename) {
    (function () {
      'use strict';
      var Regex;
      Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isHexDigit(ch) {
        return isDecimalDigit(ch) || 97 <= ch && ch <= 102 || 65 <= ch && ch <= 70;
      }
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      function isWhiteSpace(ch) {
        return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && [
          5760,
          6158,
          8192,
          8193,
          8194,
          8195,
          8196,
          8197,
          8198,
          8199,
          8200,
          8201,
          8202,
          8239,
          8287,
          12288,
          65279
        ].indexOf(ch) >= 0;
      }
      function isLineTerminator(ch) {
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
      }
      function isIdentifierStart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));
      }
      function isIdentifierPart(ch) {
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 92 || ch >= 128 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
      };
    }());
  });
  require.define('/node_modules/escodegen/node_modules/estraverse/estraverse.js', function (module, exports, __dirname, __filename) {
    (function (root, factory) {
      'use strict';
      if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
      } else if (typeof exports !== 'undefined') {
        factory(exports);
      } else {
        factory(root.estraverse = {});
      }
    }(this, function (exports) {
      'use strict';
      var Syntax, isArray, VisitorOption, VisitorKeys, BREAK, SKIP;
      Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
      };
      function ignoreJSHintError() {
      }
      isArray = Array.isArray;
      if (!isArray) {
        isArray = function isArray(array) {
          return Object.prototype.toString.call(array) === '[object Array]';
        };
      }
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      ignoreJSHintError(shallowCopy);
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      function lowerBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            i = current + 1;
            len -= diff + 1;
          } else {
            len = diff;
          }
        }
        return i;
      }
      ignoreJSHintError(lowerBound);
      VisitorKeys = {
        AssignmentExpression: [
          'left',
          'right'
        ],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: [
          'params',
          'defaults',
          'rest',
          'body'
        ],
        BlockStatement: ['body'],
        BinaryExpression: [
          'left',
          'right'
        ],
        BreakStatement: ['label'],
        CallExpression: [
          'callee',
          'arguments'
        ],
        CatchClause: [
          'param',
          'body'
        ],
        ClassBody: ['body'],
        ClassDeclaration: [
          'id',
          'body',
          'superClass'
        ],
        ClassExpression: [
          'id',
          'body',
          'superClass'
        ],
        ConditionalExpression: [
          'test',
          'consequent',
          'alternate'
        ],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: [
          'body',
          'test'
        ],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: [
          'init',
          'test',
          'update',
          'body'
        ],
        ForInStatement: [
          'left',
          'right',
          'body'
        ],
        FunctionDeclaration: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        FunctionExpression: [
          'id',
          'params',
          'defaults',
          'rest',
          'body'
        ],
        Identifier: [],
        IfStatement: [
          'test',
          'consequent',
          'alternate'
        ],
        Literal: [],
        LabeledStatement: [
          'label',
          'body'
        ],
        LogicalExpression: [
          'left',
          'right'
        ],
        MemberExpression: [
          'object',
          'property'
        ],
        MethodDefinition: [
          'key',
          'value'
        ],
        NewExpression: [
          'callee',
          'arguments'
        ],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: [
          'key',
          'value'
        ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: [
          'discriminant',
          'cases'
        ],
        SwitchCase: [
          'test',
          'consequent'
        ],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: [
          'block',
          'handlers',
          'handler',
          'guardedHandlers',
          'finalizer'
        ],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: [
          'id',
          'init'
        ],
        WhileStatement: [
          'test',
          'body'
        ],
        WithStatement: [
          'object',
          'body'
        ],
        YieldExpression: ['argument']
      };
      BREAK = {};
      SKIP = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result, path) {
          if (isArray(path)) {
            for (j = 0, jz = path.length; j < jz; ++j) {
              result.push(path[j]);
            }
          } else {
            result.push(path);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = undefined;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function () {
        this.notify(SKIP);
      };
      Controller.prototype['break'] = function () {
        this.notify(BREAK);
      };
      Controller.prototype.__initialize = function (root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
      };
      Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (!isArray(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
                continue;
              }
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], 'Property', null);
                } else {
                  element = new Element(candidate[current2], [
                    key,
                    current2
                  ], null, null);
                }
                worklist.push(element);
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = { root: root };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== undefined && target !== BREAK && target !== SKIP) {
              element.ref.replace(target);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== undefined && target !== BREAK && target !== SKIP) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = element.wrap || node.type;
          candidates = VisitorKeys[nodeType];
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (!isArray(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
              continue;
            }
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], 'Property', new Reference(candidate, current2));
              } else {
                element = new Element(candidate[current2], [
                  key,
                  current2
                ], null, new Reference(candidate, current2));
              }
              worklist.push(element);
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller;
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller;
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [
          comment.range[0],
          comment.range[1]
        ];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error('attachComments needs range information');
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [
                0,
                tree.range[0]
              ];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (comment.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function (node) {
            var comment;
            while (cursor < comments.length) {
              comment = comments[cursor];
              if (node.range[1] < comment.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports.version = '1.3.3-dev';
      exports.Syntax = Syntax;
      exports.traverse = traverse;
      exports.replace = replace;
      exports.attachComments = attachComments;
      exports.VisitorKeys = VisitorKeys;
      exports.VisitorOption = VisitorOption;
      exports.Controller = Controller;
    }));
  });
  require.define('/node_modules/cscodegen/lib/cscodegen.js', function (module, exports, __dirname, __filename) {
    (function () {
      var __hasProp = {}.hasOwnProperty, __slice = [].slice, __indexOf = [].indexOf || function (item) {
          for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        };
      (function (exports) {
        var TAB, clone, eq, formatInterpolation, formatStringData, generate, indent, levels, needsParensWhenOnLeft, operators, parens, precedence;
        TAB = '  ';
        indent = function (code) {
          var line;
          return function () {
            var _i, _len, _ref, _results;
            _ref = code.split('\n');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              line = _ref[_i];
              _results.push('' + TAB + line);
            }
            return _results;
          }().join('\n');
        };
        parens = function (code) {
          return '(' + code + ')';
        };
        formatStringData = function (data) {
          return data.replace(/[^\x20-\x7e]|['\\]/, function (c) {
            var escape, pad;
            switch (c) {
            case '\0':
              return '\\0';
            case '\b':
              return '\\b';
            case '\t':
              return '\\t';
            case '\n':
              return '\\n';
            case '\f':
              return '\\f';
            case '\r':
              return '\\r';
            case "'":
              return "\\'";
            case '\\':
              return '\\\\';
            default:
              escape = c.charCodeAt(0).toString(16);
              pad = '0000'.slice(escape.length);
              return '\\u' + pad + escape;
            }
          });
        };
        formatInterpolation = function (ast, options) {
          var left, right;
          switch (ast.className) {
          case 'ConcatOp':
            left = formatInterpolation(ast.left, options);
            right = formatInterpolation(ast.right, options);
            return '' + left + right;
          case 'String':
            return formatStringData(ast.data);
          default:
            return '#{' + generate(ast, options) + '}';
          }
        };
        needsParensWhenOnLeft = function (ast) {
          switch (ast.className) {
          case 'Function':
          case 'BoundFunction':
          case 'NewOp':
            return true;
          case 'Conditional':
          case 'Switch':
          case 'While':
          case 'Block':
            return true;
          case 'PreIncrementOp':
          case 'PreDecrementOp':
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'DeleteOp':
            return needsParensWhenOnLeft(ast.expression);
          case 'FunctionApplication':
            return ast['arguments'].length > 0;
          default:
            return false;
          }
        };
        eq = function (nodeA, nodeB) {
          var i, prop, v, val, _i, _len;
          for (prop in nodeA) {
            if (!__hasProp.call(nodeA, prop))
              continue;
            val = nodeA[prop];
            if (prop === 'raw' || prop === 'line' || prop === 'column') {
              continue;
            }
            switch (Object.prototype.toString.call(val)) {
            case '[object Object]':
              if (!eq(nodeB[prop], val)) {
                return false;
              }
              break;
            case '[object Array]':
              for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
                v = val[i];
                if (!eq(nodeB[prop][i], v)) {
                  return false;
                }
              }
              break;
            default:
              if (nodeB[prop] !== val) {
                return false;
              }
            }
          }
          return true;
        };
        clone = function (obj, overrides) {
          var newObj, prop, val;
          if (overrides == null) {
            overrides = {};
          }
          newObj = {};
          for (prop in obj) {
            if (!__hasProp.call(obj, prop))
              continue;
            val = obj[prop];
            newObj[prop] = val;
          }
          for (prop in overrides) {
            if (!__hasProp.call(overrides, prop))
              continue;
            val = overrides[prop];
            newObj[prop] = val;
          }
          return newObj;
        };
        levels = [
          ['SeqOp'],
          [
            'Conditional',
            'ForIn',
            'ForOf',
            'While'
          ],
          [
            'FunctionApplication',
            'SoakedFunctionApplication'
          ],
          [
            'AssignOp',
            'CompoundAssignOp',
            'ExistsAssignOp'
          ],
          ['LogicalOrOp'],
          ['LogicalAndOp'],
          ['BitOrOp'],
          ['BitXorOp'],
          ['BitAndOp'],
          ['ExistsOp'],
          [
            'EQOp',
            'NEQOp'
          ],
          [
            'LTOp',
            'LTEOp',
            'GTOp',
            'GTEOp',
            'InOp',
            'OfOp',
            'InstanceofOp'
          ],
          [
            'LeftShiftOp',
            'SignedRightShiftOp',
            'UnsignedRightShiftOp'
          ],
          [
            'PlusOp',
            'SubtractOp'
          ],
          [
            'MultiplyOp',
            'DivideOp',
            'RemOp'
          ],
          [
            'UnaryPlusOp',
            'UnaryNegateOp',
            'LogicalNotOp',
            'BitNotOp',
            'DoOp',
            'TypeofOp',
            'PreIncrementOp',
            'PreDecrementOp',
            'DeleteOp'
          ],
          [
            'UnaryExistsOp',
            'ShallowCopyArray',
            'PostIncrementOp',
            'PostDecrementOp',
            'Spread'
          ],
          ['NewOp'],
          [
            'MemberAccessOp',
            'SoakedMemberAccessOp',
            'DynamicMemberAccessOp',
            'SoakedDynamicMemberAccessOp',
            'ProtoMemberAccessOp',
            'DynamicProtoMemberAccessOp',
            'SoakedProtoMemberAccessOp',
            'SoakedDynamicProtoMemberAccessOp'
          ]
        ];
        precedence = {};
        (function () {
          var level, op, ops, _i, _len, _results;
          _results = [];
          for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
            ops = levels[level];
            _results.push(function () {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
                op = ops[_j];
                _results1.push(precedence[op] = level);
              }
              return _results1;
            }());
          }
          return _results;
        }());
        operators = {
          SeqOp: ';',
          LogicalOrOp: 'or',
          LogicalAndOp: 'and',
          BitOrOp: '|',
          BitXorOp: '^',
          BitAndOp: '&',
          EQOp: 'is',
          NEQOp: 'isnt',
          LTOp: '<',
          LTEOp: '<=',
          GTOp: '>',
          GTEOp: '>=',
          InOp: 'in',
          OfOp: 'of',
          InstanceofOp: 'instanceof',
          LeftShiftOp: '<<',
          SignedRightShiftOp: '>>',
          UnsignedRightShiftOp: '>>>',
          PlusOp: '+',
          SubtractOp: '-',
          MultiplyOp: '*',
          DivideOp: '/',
          RemOp: '%',
          UnaryPlusOp: '+',
          UnaryNegateOp: '-',
          LogicalNotOp: 'not ',
          BitNotOp: '~',
          DoOp: 'do ',
          NewOp: 'new ',
          TypeofOp: 'typeof ',
          PreIncrementOp: '++',
          PreDecrementOp: '--',
          UnaryExistsOp: '?',
          ShallowCopyArray: '[..]',
          PostIncrementOp: '++',
          PostDecrementOp: '--',
          Spread: '...',
          FunctionApplication: '',
          SoakedFunctionApplication: '?',
          MemberAccessOp: '.',
          SoakedMemberAccessOp: '?.',
          ProtoMemberAccessOp: '::',
          SoakedProtoMemberAccessOp: '?::',
          DynamicMemberAccessOp: '',
          SoakedDynamicMemberAccessOp: '?',
          DynamicProtoMemberAccessOp: '::',
          SoakedDynamicProtoMemberAccessOp: '?::'
        };
        return exports.generate = generate = function (ast, options) {
          var a, absNum, arg, args, expression_, hasAlternate, i, isMultiline, key_, m, memberAccessOps, members_, needsParens, p, parameters, parent, parentClassName, prec, s, sep, src, usedAsExpression, _alternate, _argList, _args, _assignee, _block, _body, _consequent, _ctor, _expr, _fn, _indexingExpr, _left, _op, _paramList, _ref, _ref1, _right;
          if (options == null) {
            options = {};
          }
          needsParens = false;
          if ((_ref = options.precedence) == null) {
            options.precedence = 0;
          }
          if ((_ref1 = options.ancestors) == null) {
            options.ancestors = [];
          }
          parent = options.ancestors[0];
          parentClassName = parent != null ? parent.className : void 0;
          usedAsExpression = parent != null && parentClassName !== 'Block';
          src = function () {
            var _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6;
            switch (ast.className) {
            case 'Program':
              options.ancestors = [ast].concat(__slice.call(options.ancestors));
              if (ast.body != null) {
                return generate(ast.body, options);
              } else {
                return '';
              }
              break;
            case 'Block':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: 0
              });
              if (ast.statements.length === 0) {
                return generate(new Undefined().g(), options);
              } else {
                sep = parentClassName === 'Program' ? '\n\n' : '\n';
                return function () {
                  var _i, _len, _ref2, _results;
                  _ref2 = ast.statements;
                  _results = [];
                  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    s = _ref2[_i];
                    _results.push(generate(s, options));
                  }
                  return _results;
                }().join(sep);
              }
              break;
            case 'Conditional':
              options.ancestors.unshift(ast);
              options.precedence = 0;
              hasAlternate = ast.consequent != null && ast.alternate != null;
              _consequent = generate((_ref2 = ast.consequent) != null ? _ref2 : new Undefined().g(), options);
              _alternate = hasAlternate ? generate(ast.alternate, options) : '';
              isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
              _consequent = isMultiline ? '\n' + indent(_consequent) : ' then ' + _consequent;
              if (hasAlternate) {
                _alternate = isMultiline ? '\nelse\n' + indent(_alternate) : ' else ' + _alternate;
              }
              return 'if ' + generate(ast.condition, options) + _consequent + _alternate;
            case 'Identifier':
              return ast.data;
            case 'Null':
              return 'null';
            case 'This':
              return 'this';
            case 'Undefined':
              return 'undefined';
            case 'Int':
              absNum = ast.data < 0 ? -ast.data : ast.data;
              if (absNum >= 1e12 || absNum >= 16 && 0 === (absNum & absNum - 1)) {
                return '0x' + ast.data.toString(16);
              } else {
                return ast.data.toString(10);
              }
              break;
            case 'Float':
              return ast.data.toString(10);
            case 'String':
              return "'" + formatStringData(ast.data) + "'";
            case 'ArrayInitialiser':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              members_ = function () {
                var _i, _len, _ref3, _results;
                _ref3 = ast.members;
                _results = [];
                for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                  m = _ref3[_i];
                  _results.push(generate(m, options));
                }
                return _results;
              }();
              switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return '[' + members_.join(', ') + ']';
              default:
                return '[\n' + indent(members_.join('\n')) + '\n]';
              }
              break;
            case 'ObjectInitialiser':
              options.ancestors = [ast].concat(__slice.call(options.ancestors));
              members_ = function () {
                var _j, _len1, _ref3, _results;
                _ref3 = ast.members;
                _results = [];
                for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                  m = _ref3[_j];
                  _results.push(generate(m, options));
                }
                return _results;
              }();
              switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return '{' + members_.join(', ') + '}';
              default:
                return '{\n' + indent(members_.join('\n')) + '\n}';
              }
              break;
            case 'ObjectInitialiserMember':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              key_ = generate(ast.key, options);
              expression_ = generate(ast.expression, options);
              memberAccessOps = [
                'MemberAccessOp',
                'ProtoMemberAccessOp',
                'SoakedMemberAccessOp',
                'SoakedProtoMemberAccessOp'
              ];
              if (eq(ast.key, ast.expression)) {
                return '' + key_;
              } else if ((_ref3 = ast.expression.className, __indexOf.call(memberAccessOps, _ref3) >= 0) && ast.key.data === ast.expression.memberName) {
                return '' + expression_;
              } else {
                return '' + key_ + ': ' + expression_;
              }
              break;
            case 'Function':
            case 'BoundFunction':
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence.AssignmentExpression
              });
              parameters = function () {
                var _j, _len1, _ref4, _results;
                _ref4 = ast.parameters;
                _results = [];
                for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                  p = _ref4[_j];
                  _results.push(generate(p, options));
                }
                return _results;
              }();
              options.precedence = 0;
              _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
              _paramList = ast.parameters.length > 0 ? '(' + parameters.join(', ') + ') ' : '';
              _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? ' ' + _body : '\n' + indent(_body);
              switch (ast.className) {
              case 'Function':
                return '' + _paramList + '->' + _block;
              case 'BoundFunction':
                return '' + _paramList + '=>' + _block;
              }
              break;
            case 'AssignOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _assignee = generate(ast.assignee, options);
              _expr = generate(ast.expression, options);
              return '' + _assignee + ' = ' + _expr;
            case 'CompoundAssignOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _op = operators[ast.op.prototype.className];
              _assignee = generate(ast.assignee, options);
              _expr = generate(ast.expression, options);
              return '' + _assignee + ' ' + _op + '= ' + _expr;
            case 'SeqOp':
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _left = generate(ast.left, options);
              _right = generate(ast.right, options);
              return '' + _left + '; ' + _right;
            case 'LogicalOrOp':
            case 'LogicalAndOp':
            case 'BitOrOp':
            case 'BitXorOp':
            case 'BitAndOp':
            case 'LeftShiftOp':
            case 'SignedRightShiftOp':
            case 'UnsignedRightShiftOp':
            case 'EQOp':
            case 'NEQOp':
            case 'LTOp':
            case 'LTEOp':
            case 'GTOp':
            case 'GTEOp':
            case 'InOp':
            case 'OfOp':
            case 'InstanceofOp':
            case 'PlusOp':
            case 'SubtractOp':
            case 'MultiplyOp':
            case 'DivideOp':
            case 'RemOp':
            case 'ExistsOp':
              _op = operators[ast.className];
              if (((_ref4 = ast.className) === 'InOp' || _ref4 === 'OfOp' || _ref4 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
                _op = 'not ' + _op;
              }
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _left = generate(ast.left, options);
              if (needsParensWhenOnLeft(ast.left)) {
                _left = parens(_left);
              }
              _right = generate(ast.right, options);
              return '' + _left + ' ' + _op + ' ' + _right;
            case 'UnaryPlusOp':
            case 'UnaryNegateOp':
            case 'LogicalNotOp':
            case 'BitNotOp':
            case 'DoOp':
            case 'TypeofOp':
            case 'PreIncrementOp':
            case 'PreDecrementOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              if (ast.className === 'LogicalNotOp') {
                if ((_ref5 = ast.expression.className) === 'InOp' || _ref5 === 'OfOp' || _ref5 === 'InstanceofOp') {
                  _op = '';
                  prec = precedence[ast.expression.className];
                }
                if ('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) {
                  _op = '!';
                }
              }
              needsParens = prec < options.precedence;
              if (parentClassName === ast.className && ((_ref6 = ast.className) === 'UnaryPlusOp' || _ref6 === 'UnaryNegateOp')) {
                needsParens = true;
              }
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              return '' + _op + generate(ast.expression, options);
            case 'UnaryExistsOp':
            case 'PostIncrementOp':
            case 'PostDecrementOp':
            case 'Spread':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
              return '' + _expr + _op;
            case 'NewOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              _ctor = generate(ast.ctor, options);
              if (ast['arguments'].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
                _ctor = parens(_ctor);
              }
              options.precedence = precedence['AssignOp'];
              args = function () {
                var _j, _len1, _ref7, _results;
                _ref7 = ast['arguments'];
                _results = [];
                for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                  a = _ref7[i];
                  arg = generate(a, options);
                  if (needsParensWhenOnLeft(a) && i + 1 !== ast['arguments'].length) {
                    arg = parens(arg);
                  }
                  _results.push(arg);
                }
                return _results;
              }();
              _args = ast['arguments'].length === 0 ? '' : ' ' + args.join(', ');
              return '' + _op + _ctor + _args;
            case 'FunctionApplication':
            case 'SoakedFunctionApplication':
              if (ast.className === 'FunctionApplication' && ast['arguments'].length === 0 && !usedAsExpression) {
                return generate(new DoOp(ast['function']), options);
              } else {
                options = clone(options, {
                  ancestors: [ast].concat(__slice.call(options.ancestors)),
                  precedence: precedence[ast.className]
                });
                _op = operators[ast.className];
                _fn = generate(ast['function'], options);
                if (needsParensWhenOnLeft(ast['function'])) {
                  _fn = parens(_fn);
                }
                args = function () {
                  var _j, _len1, _ref7, _results;
                  _ref7 = ast['arguments'];
                  _results = [];
                  for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                    a = _ref7[i];
                    arg = generate(a, options);
                    if (needsParensWhenOnLeft(a) && i + 1 !== ast['arguments'].length) {
                      arg = parens(arg);
                    }
                    _results.push(arg);
                  }
                  return _results;
                }();
                _argList = ast['arguments'].length === 0 ? '()' : ' ' + args.join(', ');
                return '' + _fn + _op + _argList;
              }
              break;
            case 'MemberAccessOp':
            case 'SoakedMemberAccessOp':
            case 'ProtoMemberAccessOp':
            case 'SoakedProtoMemberAccessOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              if (ast.expression.className === 'This') {
                _expr = '@';
                if (ast.className === 'MemberAccessOp') {
                  _op = '';
                }
              } else {
                _expr = generate(ast.expression, options);
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
              return '' + _expr + _op + ast.memberName;
            case 'DynamicMemberAccessOp':
            case 'SoakedDynamicMemberAccessOp':
            case 'DynamicProtoMemberAccessOp':
            case 'SoakedDynamicProtoMemberAccessOp':
              _op = operators[ast.className];
              prec = precedence[ast.className];
              needsParens = prec < options.precedence;
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: prec
              });
              if (ast.expression.className === 'This') {
                _expr = '@';
              } else {
                _expr = generate(ast.expression, options);
                if (needsParensWhenOnLeft(ast.expression)) {
                  _expr = parens(_expr);
                }
              }
              options.precedence = 0;
              _indexingExpr = generate(ast.indexingExpr, options);
              return '' + _expr + _op + '[' + _indexingExpr + ']';
            case 'ConcatOp':
              _left = formatInterpolation(ast.left, options);
              _right = formatInterpolation(ast.right, options);
              return '"' + _left + _right + '"';
            default:
              throw new Error('Non-exhaustive patterns in case: ' + ast.className);
            }
          }();
          if (needsParens) {
            return parens(src);
          } else {
            return src;
          }
        };
      }(typeof exports !== 'undefined' && exports !== null ? exports : this.cscodegen = {}));
    }.call(this));
  });
  require.define('/src/ember-runtime.js', function (module, exports, __dirname, __filename) {
    (function () {
      if ('undefined' === typeof Ember) {
        Ember = {};
        if ('undefined' !== typeof window) {
          window.Em = window.Ember = Em = Ember;
        }
      }
      Ember.ENV = 'undefined' === typeof ENV ? {} : ENV;
      if (!('MANDATORY_SETTER' in Ember.ENV)) {
        Ember.ENV.MANDATORY_SETTER = true;
      }
      Ember.assert = function (desc, test) {
        if (!test)
          throw new Error('assertion failed: ' + desc);
      };
      Ember.warn = function (message, test) {
        if (!test) {
          Ember.Logger.warn('WARNING: ' + message);
          if ('trace' in Ember.Logger)
            Ember.Logger.trace();
        }
      };
      Ember.debug = function (message) {
        Ember.Logger.debug('DEBUG: ' + message);
      };
      Ember.deprecate = function (message, test) {
        if (Ember && Ember.TESTING_DEPRECATION) {
          return;
        }
        if (arguments.length === 1) {
          test = false;
        }
        if (test) {
          return;
        }
        if (Ember && Ember.ENV.RAISE_ON_DEPRECATION) {
          throw new Error(message);
        }
        var error;
        try {
          __fail__.fail();
        } catch (e) {
          error = e;
        }
        if (Ember.LOG_STACKTRACE_ON_DEPRECATION && error.stack) {
          var stack, stackStr = '';
          if (error['arguments']) {
            stack = error.stack.replace(/^\s+at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm, '{anonymous}($1)$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}($1)').split('\n');
            stack.shift();
          } else {
            stack = error.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
          }
          stackStr = '\n    ' + stack.slice(2).join('\n    ');
          message = message + stackStr;
        }
        Ember.Logger.warn('DEPRECATION: ' + message);
      };
      Ember.deprecateFunc = function (message, func) {
        return function () {
          Ember.deprecate(message);
          return func.apply(this, arguments);
        };
      };
    }());
    (function () {
      var define, requireModule;
      (function () {
        var registry = {}, seen = {};
        define = function (name, deps, callback) {
          registry[name] = {
            deps: deps,
            callback: callback
          };
        };
        requireModule = function (name) {
          if (seen[name]) {
            return seen[name];
          }
          seen[name] = {};
          var mod = registry[name], deps = mod.deps, callback = mod.callback, reified = [], exports;
          for (var i = 0, l = deps.length; i < l; i++) {
            if (deps[i] === 'exports') {
              reified.push(exports = {});
            } else {
              reified.push(requireModule(deps[i]));
            }
          }
          var value = callback.apply(this, reified);
          return seen[name] = exports || value;
        };
      }());
      (function () {
        if ('undefined' === typeof Ember) {
          Ember = {};
        }
        var imports = Ember.imports = Ember.imports || this;
        var exports = Ember.exports = Ember.exports || this;
        var lookup = Ember.lookup = Ember.lookup || this;
        exports.Em = exports.Ember = Em = Ember;
        Ember.isNamespace = true;
        Ember.toString = function () {
          return 'Ember';
        };
        Ember.VERSION = '1.0.0-rc.2';
        Ember.ENV = Ember.ENV || ('undefined' === typeof ENV ? {} : ENV);
        Ember.config = Ember.config || {};
        Ember.EXTEND_PROTOTYPES = Ember.ENV.EXTEND_PROTOTYPES;
        if (typeof Ember.EXTEND_PROTOTYPES === 'undefined') {
          Ember.EXTEND_PROTOTYPES = true;
        }
        Ember.LOG_STACKTRACE_ON_DEPRECATION = Ember.ENV.LOG_STACKTRACE_ON_DEPRECATION !== false;
        Ember.SHIM_ES5 = Ember.ENV.SHIM_ES5 === false ? false : Ember.EXTEND_PROTOTYPES;
        Ember.LOG_VERSION = Ember.ENV.LOG_VERSION === false ? false : true;
        Ember.K = function () {
          return this;
        };
        if ('undefined' === typeof Ember.assert) {
          Ember.assert = Ember.K;
        }
        if ('undefined' === typeof Ember.warn) {
          Ember.warn = Ember.K;
        }
        if ('undefined' === typeof Ember.debug) {
          Ember.debug = Ember.K;
        }
        if ('undefined' === typeof Ember.deprecate) {
          Ember.deprecate = Ember.K;
        }
        if ('undefined' === typeof Ember.deprecateFunc) {
          Ember.deprecateFunc = function (_, func) {
            return func;
          };
        }
        Ember.uuid = 0;
        function consoleMethod(name) {
          if (imports.console && imports.console[name]) {
            if (imports.console[name].apply) {
              return function () {
                imports.console[name].apply(imports.console, arguments);
              };
            } else {
              return function () {
                var message = Array.prototype.join.call(arguments, ', ');
                imports.console[name](message);
              };
            }
          }
        }
        Ember.Logger = {
          log: consoleMethod('log') || Ember.K,
          warn: consoleMethod('warn') || Ember.K,
          error: consoleMethod('error') || Ember.K,
          info: consoleMethod('info') || Ember.K,
          debug: consoleMethod('debug') || consoleMethod('info') || Ember.K
        };
        Ember.onerror = null;
        Ember.handleErrors = function (func, context) {
          if ('function' === typeof Ember.onerror) {
            try {
              return func.call(context || this);
            } catch (error) {
              Ember.onerror(error);
            }
          } else {
            return func.call(context || this);
          }
        };
        Ember.merge = function (original, updates) {
          for (var prop in updates) {
            if (!updates.hasOwnProperty(prop)) {
              continue;
            }
            original[prop] = updates[prop];
          }
          return original;
        };
        Ember.isNone = function (obj) {
          return obj === null || obj === undefined;
        };
        Ember.none = Ember.deprecateFunc('Ember.none is deprecated. Please use Ember.isNone instead.', Ember.isNone);
        Ember.isEmpty = function (obj) {
          return obj === null || obj === undefined || obj.length === 0 && typeof obj !== 'function' || typeof obj === 'object' && Ember.get(obj, 'length') === 0;
        };
        Ember.empty = Ember.deprecateFunc('Ember.empty is deprecated. Please use Ember.isEmpty instead.', Ember.isEmpty);
      }());
      (function () {
        var platform = Ember.platform = {};
        Ember.create = Object.create;
        if (!Ember.create || Ember.ENV.STUB_OBJECT_CREATE) {
          var K = function () {
          };
          Ember.create = function (obj, props) {
            K.prototype = obj;
            obj = new K;
            if (props) {
              K.prototype = obj;
              for (var prop in props) {
                K.prototype[prop] = props[prop].value;
              }
              obj = new K;
            }
            K.prototype = null;
            return obj;
          };
          Ember.create.isSimulated = true;
        }
        var defineProperty = Object.defineProperty;
        var canRedefineProperties, canDefinePropertyOnDOM;
        if (defineProperty) {
          try {
            defineProperty({}, 'a', {
              get: function () {
              }
            });
          } catch (e) {
            defineProperty = null;
          }
        }
        if (defineProperty) {
          canRedefineProperties = function () {
            var obj = {};
            defineProperty(obj, 'a', {
              configurable: true,
              enumerable: true,
              get: function () {
              },
              set: function () {
              }
            });
            defineProperty(obj, 'a', {
              configurable: true,
              enumerable: true,
              writable: true,
              value: true
            });
            return obj.a === true;
          }();
          canDefinePropertyOnDOM = function () {
            try {
              defineProperty(document.createElement('div'), 'definePropertyOnDOM', {});
              return true;
            } catch (e) {
            }
            return false;
          }();
          if (!canRedefineProperties) {
            defineProperty = null;
          } else if (!canDefinePropertyOnDOM) {
            defineProperty = function (obj, keyName, desc) {
              var isNode;
              if (typeof Node === 'object') {
                isNode = obj instanceof Node;
              } else {
                isNode = typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
              }
              if (isNode) {
                return obj[keyName] = desc.value;
              } else {
                return Object.defineProperty(obj, keyName, desc);
              }
            };
          }
        }
        platform.defineProperty = defineProperty;
        platform.hasPropertyAccessors = true;
        if (!platform.defineProperty) {
          platform.hasPropertyAccessors = false;
          platform.defineProperty = function (obj, keyName, desc) {
            if (!desc.get) {
              obj[keyName] = desc.value;
            }
          };
          platform.defineProperty.isSimulated = true;
        }
        if (Ember.ENV.MANDATORY_SETTER && !platform.hasPropertyAccessors) {
          Ember.ENV.MANDATORY_SETTER = false;
        }
      }());
      (function () {
        var o_defineProperty = Ember.platform.defineProperty, o_create = Ember.create, GUID_KEY = '__ember' + +new Date, uuid = 0, numberCache = [], stringCache = {};
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        Ember.GUID_KEY = GUID_KEY;
        var GUID_DESC = {
            writable: false,
            configurable: false,
            enumerable: false,
            value: null
          };
        Ember.generateGuid = function generateGuid(obj, prefix) {
          if (!prefix)
            prefix = 'ember';
          var ret = prefix + uuid++;
          if (obj) {
            GUID_DESC.value = ret;
            o_defineProperty(obj, GUID_KEY, GUID_DESC);
          }
          return ret;
        };
        Ember.guidFor = function guidFor(obj) {
          if (obj === undefined)
            return '(undefined)';
          if (obj === null)
            return '(null)';
          var cache, ret;
          var type = typeof obj;
          switch (type) {
          case 'number':
            ret = numberCache[obj];
            if (!ret)
              ret = numberCache[obj] = 'nu' + obj;
            return ret;
          case 'string':
            ret = stringCache[obj];
            if (!ret)
              ret = stringCache[obj] = 'st' + uuid++;
            return ret;
          case 'boolean':
            return obj ? '(true)' : '(false)';
          default:
            if (obj[GUID_KEY])
              return obj[GUID_KEY];
            if (obj === Object)
              return '(Object)';
            if (obj === Array)
              return '(Array)';
            ret = 'ember' + uuid++;
            GUID_DESC.value = ret;
            o_defineProperty(obj, GUID_KEY, GUID_DESC);
            return ret;
          }
        };
        var META_DESC = {
            writable: true,
            configurable: false,
            enumerable: false,
            value: null
          };
        var META_KEY = Ember.GUID_KEY + '_meta';
        Ember.META_KEY = META_KEY;
        var EMPTY_META = {
            descs: {},
            watching: {}
          };
        if (MANDATORY_SETTER) {
          EMPTY_META.values = {};
        }
        Ember.EMPTY_META = EMPTY_META;
        if (Object.freeze)
          Object.freeze(EMPTY_META);
        var isDefinePropertySimulated = Ember.platform.defineProperty.isSimulated;
        function Meta(obj) {
          this.descs = {};
          this.watching = {};
          this.cache = {};
          this.source = obj;
        }
        if (isDefinePropertySimulated) {
          Meta.prototype.__preventPlainObject__ = true;
          Meta.prototype.toJSON = function () {
          };
        }
        Ember.meta = function meta(obj, writable) {
          var ret = obj[META_KEY];
          if (writable === false)
            return ret || EMPTY_META;
          if (!ret) {
            if (!isDefinePropertySimulated)
              o_defineProperty(obj, META_KEY, META_DESC);
            ret = new Meta(obj);
            if (MANDATORY_SETTER) {
              ret.values = {};
            }
            obj[META_KEY] = ret;
            ret.descs.constructor = null;
          } else if (ret.source !== obj) {
            if (!isDefinePropertySimulated)
              o_defineProperty(obj, META_KEY, META_DESC);
            ret = o_create(ret);
            ret.descs = o_create(ret.descs);
            ret.watching = o_create(ret.watching);
            ret.cache = {};
            ret.source = obj;
            if (MANDATORY_SETTER) {
              ret.values = o_create(ret.values);
            }
            obj[META_KEY] = ret;
          }
          return ret;
        };
        Ember.getMeta = function getMeta(obj, property) {
          var meta = Ember.meta(obj, false);
          return meta[property];
        };
        Ember.setMeta = function setMeta(obj, property, value) {
          var meta = Ember.meta(obj, true);
          meta[property] = value;
          return value;
        };
        Ember.metaPath = function metaPath(obj, path, writable) {
          var meta = Ember.meta(obj, writable), keyName, value;
          for (var i = 0, l = path.length; i < l; i++) {
            keyName = path[i];
            value = meta[keyName];
            if (!value) {
              if (!writable) {
                return undefined;
              }
              value = meta[keyName] = { __ember_source__: obj };
            } else if (value.__ember_source__ !== obj) {
              if (!writable) {
                return undefined;
              }
              value = meta[keyName] = o_create(value);
              value.__ember_source__ = obj;
            }
            meta = value;
          }
          return value;
        };
        Ember.wrap = function (func, superFunc) {
          function K() {
          }
          function superWrapper() {
            var ret, sup = this._super;
            this._super = superFunc || K;
            ret = func.apply(this, arguments);
            this._super = sup;
            return ret;
          }
          superWrapper.wrappedFunction = func;
          superWrapper.__ember_observes__ = func.__ember_observes__;
          superWrapper.__ember_observesBefore__ = func.__ember_observesBefore__;
          return superWrapper;
        };
        Ember.isArray = function (obj) {
          if (!obj || obj.setInterval) {
            return false;
          }
          if (Array.isArray && Array.isArray(obj)) {
            return true;
          }
          if (Ember.Array && Ember.Array.detect(obj)) {
            return true;
          }
          if (obj.length !== undefined && 'object' === typeof obj) {
            return true;
          }
          return false;
        };
        Ember.makeArray = function (obj) {
          if (obj === null || obj === undefined) {
            return [];
          }
          return Ember.isArray(obj) ? obj : [obj];
        };
        function canInvoke(obj, methodName) {
          return !!(obj && typeof obj[methodName] === 'function');
        }
        Ember.canInvoke = canInvoke;
        Ember.tryInvoke = function (obj, methodName, args) {
          if (canInvoke(obj, methodName)) {
            return obj[methodName].apply(obj, args || []);
          }
        };
        var needsFinallyFix = function () {
            var count = 0;
            try {
              try {
              } finally {
                count++;
                throw new Error('needsFinallyFixTest');
              }
            } catch (e) {
            }
            return count !== 1;
          }();
        if (needsFinallyFix) {
          Ember.tryFinally = function (tryable, finalizer, binding) {
            var result, finalResult, finalError;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } finally {
              try {
                finalResult = finalizer.call(binding);
              } catch (e) {
                finalError = e;
              }
            }
            if (finalError) {
              throw finalError;
            }
            return finalResult === undefined ? result : finalResult;
          };
        } else {
          Ember.tryFinally = function (tryable, finalizer, binding) {
            var result, finalResult;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } finally {
              finalResult = finalizer.call(binding);
            }
            return finalResult === undefined ? result : finalResult;
          };
        }
        if (needsFinallyFix) {
          Ember.tryCatchFinally = function (tryable, catchable, finalizer, binding) {
            var result, finalResult, finalError, finalReturn;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } catch (error) {
              result = catchable.call(binding, error);
            } finally {
              try {
                finalResult = finalizer.call(binding);
              } catch (e) {
                finalError = e;
              }
            }
            if (finalError) {
              throw finalError;
            }
            return finalResult === undefined ? result : finalResult;
          };
        } else {
          Ember.tryCatchFinally = function (tryable, catchable, finalizer, binding) {
            var result, finalResult;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } catch (error) {
              result = catchable.call(binding, error);
            } finally {
              finalResult = finalizer.call(binding);
            }
            return finalResult === undefined ? result : finalResult;
          };
        }
      }());
      (function () {
        Ember.Instrumentation = {};
        var subscribers = [], cache = {};
        var populateListeners = function (name) {
          var listeners = [], subscriber;
          for (var i = 0, l = subscribers.length; i < l; i++) {
            subscriber = subscribers[i];
            if (subscriber.regex.test(name)) {
              listeners.push(subscriber.object);
            }
          }
          cache[name] = listeners;
          return listeners;
        };
        var time = function () {
            var perf = 'undefined' !== typeof window ? window.performance || {} : {};
            var fn = perf.now || perf.mozNow || perf.webkitNow || perf.msNow || perf.oNow;
            return fn ? fn.bind(perf) : function () {
              return +new Date;
            };
          }();
        Ember.Instrumentation.instrument = function (name, payload, callback, binding) {
          var listeners = cache[name], timeName, ret;
          if (Ember.STRUCTURED_PROFILE) {
            timeName = name + ': ' + payload.object;
            console.time(timeName);
          }
          if (!listeners) {
            listeners = populateListeners(name);
          }
          if (listeners.length === 0) {
            ret = callback.call(binding);
            if (Ember.STRUCTURED_PROFILE) {
              console.timeEnd(timeName);
            }
            return ret;
          }
          var beforeValues = [], listener, i, l;
          function tryable() {
            for (i = 0, l = listeners.length; i < l; i++) {
              listener = listeners[i];
              beforeValues[i] = listener.before(name, time(), payload);
            }
            return callback.call(binding);
          }
          function catchable(e) {
            payload = payload || {};
            payload.exception = e;
          }
          function finalizer() {
            for (i = 0, l = listeners.length; i < l; i++) {
              listener = listeners[i];
              listener.after(name, time(), payload, beforeValues[i]);
            }
            if (Ember.STRUCTURED_PROFILE) {
              console.timeEnd(timeName);
            }
          }
          return Ember.tryCatchFinally(tryable, catchable, finalizer);
        };
        Ember.Instrumentation.subscribe = function (pattern, object) {
          var paths = pattern.split('.'), path, regex = [];
          for (var i = 0, l = paths.length; i < l; i++) {
            path = paths[i];
            if (path === '*') {
              regex.push('[^\\.]*');
            } else {
              regex.push(path);
            }
          }
          regex = regex.join('\\.');
          regex = regex + '(\\..*)?';
          var subscriber = {
              pattern: pattern,
              regex: new RegExp('^' + regex + '$'),
              object: object
            };
          subscribers.push(subscriber);
          cache = {};
          return subscriber;
        };
        Ember.Instrumentation.unsubscribe = function (subscriber) {
          var index;
          for (var i = 0, l = subscribers.length; i < l; i++) {
            if (subscribers[i] === subscriber) {
              index = i;
            }
          }
          subscribers.splice(index, 1);
          cache = {};
        };
        Ember.Instrumentation.reset = function () {
          subscribers = [];
          cache = {};
        };
        Ember.instrument = Ember.Instrumentation.instrument;
        Ember.subscribe = Ember.Instrumentation.subscribe;
      }());
      (function () {
        var utils = Ember.EnumerableUtils = {
            map: function (obj, callback, thisArg) {
              return obj.map ? obj.map.call(obj, callback, thisArg) : Array.prototype.map.call(obj, callback, thisArg);
            },
            forEach: function (obj, callback, thisArg) {
              return obj.forEach ? obj.forEach.call(obj, callback, thisArg) : Array.prototype.forEach.call(obj, callback, thisArg);
            },
            indexOf: function (obj, element, index) {
              return obj.indexOf ? obj.indexOf.call(obj, element, index) : Array.prototype.indexOf.call(obj, element, index);
            },
            indexesOf: function (obj, elements) {
              return elements === undefined ? [] : utils.map(elements, function (item) {
                return utils.indexOf(obj, item);
              });
            },
            addObject: function (array, item) {
              var index = utils.indexOf(array, item);
              if (index === -1) {
                array.push(item);
              }
            },
            removeObject: function (array, item) {
              var index = utils.indexOf(array, item);
              if (index !== -1) {
                array.splice(index, 1);
              }
            },
            replace: function (array, idx, amt, objects) {
              if (array.replace) {
                return array.replace(idx, amt, objects);
              } else {
                var args = Array.prototype.concat.apply([
                    idx,
                    amt
                  ], objects);
                return array.splice.apply(array, args);
              }
            },
            intersection: function (array1, array2) {
              var intersection = [];
              array1.forEach(function (element) {
                if (array2.indexOf(element) >= 0) {
                  intersection.push(element);
                }
              });
              return intersection;
            }
          };
      }());
      (function () {
        var isNativeFunc = function (func) {
          return func && Function.prototype.toString.call(func).indexOf('[native code]') > -1;
        };
        var arrayMap = isNativeFunc(Array.prototype.map) ? Array.prototype.map : function (fun) {
            if (this === void 0 || this === null) {
              throw new TypeError;
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError;
            }
            var res = new Array(len);
            var thisp = arguments[1];
            for (var i = 0; i < len; i++) {
              if (i in t) {
                res[i] = fun.call(thisp, t[i], i, t);
              }
            }
            return res;
          };
        var arrayForEach = isNativeFunc(Array.prototype.forEach) ? Array.prototype.forEach : function (fun) {
            if (this === void 0 || this === null) {
              throw new TypeError;
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError;
            }
            var thisp = arguments[1];
            for (var i = 0; i < len; i++) {
              if (i in t) {
                fun.call(thisp, t[i], i, t);
              }
            }
          };
        var arrayIndexOf = isNativeFunc(Array.prototype.indexOf) ? Array.prototype.indexOf : function (obj, fromIndex) {
            if (fromIndex === null || fromIndex === undefined) {
              fromIndex = 0;
            } else if (fromIndex < 0) {
              fromIndex = Math.max(0, this.length + fromIndex);
            }
            for (var i = fromIndex, j = this.length; i < j; i++) {
              if (this[i] === obj) {
                return i;
              }
            }
            return -1;
          };
        Ember.ArrayPolyfills = {
          map: arrayMap,
          forEach: arrayForEach,
          indexOf: arrayIndexOf
        };
        if (Ember.SHIM_ES5) {
          if (!Array.prototype.map) {
            Array.prototype.map = arrayMap;
          }
          if (!Array.prototype.forEach) {
            Array.prototype.forEach = arrayForEach;
          }
          if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = arrayIndexOf;
          }
        }
      }());
      (function () {
        var guidFor = Ember.guidFor, indexOf = Ember.ArrayPolyfills.indexOf;
        var copy = function (obj) {
          var output = {};
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              output[prop] = obj[prop];
            }
          }
          return output;
        };
        var copyMap = function (original, newObject) {
          var keys = original.keys.copy(), values = copy(original.values);
          newObject.keys = keys;
          newObject.values = values;
          return newObject;
        };
        var OrderedSet = Ember.OrderedSet = function () {
            this.clear();
          };
        OrderedSet.create = function () {
          return new OrderedSet;
        };
        OrderedSet.prototype = {
          clear: function () {
            this.presenceSet = {};
            this.list = [];
          },
          add: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
            if (guid in presenceSet) {
              return;
            }
            presenceSet[guid] = true;
            list.push(obj);
          },
          remove: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
            delete presenceSet[guid];
            var index = indexOf.call(list, obj);
            if (index > -1) {
              list.splice(index, 1);
            }
          },
          isEmpty: function () {
            return this.list.length === 0;
          },
          has: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet;
            return guid in presenceSet;
          },
          forEach: function (fn, self) {
            var list = this.list.slice();
            for (var i = 0, j = list.length; i < j; i++) {
              fn.call(self, list[i]);
            }
          },
          toArray: function () {
            return this.list.slice();
          },
          copy: function () {
            var set = new OrderedSet;
            set.presenceSet = copy(this.presenceSet);
            set.list = this.list.slice();
            return set;
          }
        };
        var Map = Ember.Map = function () {
            this.keys = Ember.OrderedSet.create();
            this.values = {};
          };
        Map.create = function () {
          return new Map;
        };
        Map.prototype = {
          get: function (key) {
            var values = this.values, guid = guidFor(key);
            return values[guid];
          },
          set: function (key, value) {
            var keys = this.keys, values = this.values, guid = guidFor(key);
            keys.add(key);
            values[guid] = value;
          },
          remove: function (key) {
            var keys = this.keys, values = this.values, guid = guidFor(key), value;
            if (values.hasOwnProperty(guid)) {
              keys.remove(key);
              value = values[guid];
              delete values[guid];
              return true;
            } else {
              return false;
            }
          },
          has: function (key) {
            var values = this.values, guid = guidFor(key);
            return values.hasOwnProperty(guid);
          },
          forEach: function (callback, self) {
            var keys = this.keys, values = this.values;
            keys.forEach(function (key) {
              var guid = guidFor(key);
              callback.call(self, key, values[guid]);
            });
          },
          copy: function () {
            return copyMap(this, new Map);
          }
        };
        var MapWithDefault = Ember.MapWithDefault = function (options) {
            Map.call(this);
            this.defaultValue = options.defaultValue;
          };
        MapWithDefault.create = function (options) {
          if (options) {
            return new MapWithDefault(options);
          } else {
            return new Map;
          }
        };
        MapWithDefault.prototype = Ember.create(Map.prototype);
        MapWithDefault.prototype.get = function (key) {
          var hasValue = this.has(key);
          if (hasValue) {
            return Map.prototype.get.call(this, key);
          } else {
            var defaultValue = this.defaultValue(key);
            this.set(key, defaultValue);
            return defaultValue;
          }
        };
        MapWithDefault.prototype.copy = function () {
          return copyMap(this, new MapWithDefault({ defaultValue: this.defaultValue }));
        };
      }());
      (function () {
        var META_KEY = Ember.META_KEY, get;
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        var IS_GLOBAL_PATH = /^([A-Z$]|([0-9][A-Z$])).*[\.\*]/;
        var HAS_THIS = /^this[\.\*]/;
        var FIRST_KEY = /^([^\.\*]+)/;
        get = function get(obj, keyName) {
          if (keyName === '') {
            return obj;
          }
          if (!keyName && 'string' === typeof obj) {
            keyName = obj;
            obj = null;
          }
          if (!obj || keyName.indexOf('.') !== -1) {
            Ember.assert("Cannot call get with '" + keyName + "' on an undefined object.", obj !== undefined);
            return getPath(obj, keyName);
          }
          Ember.assert('You need to provide an object and key to `get`.', !!obj && keyName);
          var meta = obj[META_KEY], desc = meta && meta.descs[keyName], ret;
          if (desc) {
            return desc.get(obj, keyName);
          } else {
            if (MANDATORY_SETTER && meta && meta.watching[keyName] > 0) {
              ret = meta.values[keyName];
            } else {
              ret = obj[keyName];
            }
            if (ret === undefined && 'object' === typeof obj && !(keyName in obj) && 'function' === typeof obj.unknownProperty) {
              return obj.unknownProperty(keyName);
            }
            return ret;
          }
        };
        if (Ember.config.overrideAccessors) {
          Ember.get = get;
          Ember.config.overrideAccessors();
          get = Ember.get;
        }
        function firstKey(path) {
          return path.match(FIRST_KEY)[0];
        }
        function normalizeTuple(target, path) {
          var hasThis = HAS_THIS.test(path), isGlobal = !hasThis && IS_GLOBAL_PATH.test(path), key;
          if (!target || isGlobal)
            target = Ember.lookup;
          if (hasThis)
            path = path.slice(5);
          if (target === Ember.lookup) {
            key = firstKey(path);
            target = get(target, key);
            path = path.slice(key.length + 1);
          }
          if (!path || path.length === 0)
            throw new Error('Invalid Path');
          return [
            target,
            path
          ];
        }
        var getPath = Ember._getPath = function (root, path) {
            var hasThis, parts, tuple, idx, len;
            if (root === null && path.indexOf('.') === -1) {
              return get(Ember.lookup, path);
            }
            hasThis = HAS_THIS.test(path);
            if (!root || hasThis) {
              tuple = normalizeTuple(root, path);
              root = tuple[0];
              path = tuple[1];
              tuple.length = 0;
            }
            parts = path.split('.');
            len = parts.length;
            for (idx = 0; root && idx < len; idx++) {
              root = get(root, parts[idx], true);
              if (root && root.isDestroyed) {
                return undefined;
              }
            }
            return root;
          };
        Ember.normalizeTuple = function (target, path) {
          return normalizeTuple(target, path);
        };
        Ember.getWithDefault = function (root, key, defaultValue) {
          var value = get(root, key);
          if (value === undefined) {
            return defaultValue;
          }
          return value;
        };
        Ember.get = get;
        Ember.getPath = Ember.deprecateFunc('getPath is deprecated since get now supports paths', Ember.get);
      }());
      (function () {
        var o_create = Ember.create, metaFor = Ember.meta, META_KEY = Ember.META_KEY;
        function indexOf(array, target, method) {
          var index = -1;
          for (var i = 0, l = array.length; i < l; i++) {
            if (target === array[i][0] && method === array[i][1]) {
              index = i;
              break;
            }
          }
          return index;
        }
        function actionsFor(obj, eventName) {
          var meta = metaFor(obj, true), actions;
          if (!meta.listeners) {
            meta.listeners = {};
          }
          if (!meta.hasOwnProperty('listeners')) {
            meta.listeners = o_create(meta.listeners);
          }
          actions = meta.listeners[eventName];
          if (actions && !meta.listeners.hasOwnProperty(eventName)) {
            actions = meta.listeners[eventName] = meta.listeners[eventName].slice();
          } else if (!actions) {
            actions = meta.listeners[eventName] = [];
          }
          return actions;
        }
        function actionsUnion(obj, eventName, otherActions) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            var target = actions[i][0], method = actions[i][1], once = actions[i][2], suspended = actions[i][3], actionIndex = indexOf(otherActions, target, method);
            if (actionIndex === -1) {
              otherActions.push([
                target,
                method,
                once,
                suspended
              ]);
            }
          }
        }
        function actionsDiff(obj, eventName, otherActions) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName], diffActions = [];
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            var target = actions[i][0], method = actions[i][1], once = actions[i][2], suspended = actions[i][3], actionIndex = indexOf(otherActions, target, method);
            if (actionIndex !== -1) {
              continue;
            }
            otherActions.push([
              target,
              method,
              once,
              suspended
            ]);
            diffActions.push([
              target,
              method,
              once,
              suspended
            ]);
          }
          return diffActions;
        }
        function addListener(obj, eventName, target, method, once) {
          Ember.assert('You must pass at least an object and event name to Ember.addListener', !!obj && !!eventName);
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
          if (actionIndex !== -1) {
            return;
          }
          actions.push([
            target,
            method,
            once,
            undefined
          ]);
          if ('function' === typeof obj.didAddListener) {
            obj.didAddListener(eventName, target, method);
          }
        }
        function removeListener(obj, eventName, target, method) {
          Ember.assert('You must pass at least an object and event name to Ember.removeListener', !!obj && !!eventName);
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          function _removeListener(target, method, once) {
            var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
            if (actionIndex === -1) {
              return;
            }
            actions.splice(actionIndex, 1);
            if ('function' === typeof obj.didRemoveListener) {
              obj.didRemoveListener(eventName, target, method);
            }
          }
          if (method) {
            _removeListener(target, method);
          } else {
            var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
            if (!actions) {
              return;
            }
            for (var i = actions.length - 1; i >= 0; i--) {
              _removeListener(actions[i][0], actions[i][1]);
            }
          }
        }
        function suspendListener(obj, eventName, target, method, callback) {
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method), action;
          if (actionIndex !== -1) {
            action = actions[actionIndex].slice();
            action[3] = true;
            actions[actionIndex] = action;
          }
          function tryable() {
            return callback.call(target);
          }
          function finalizer() {
            if (action) {
              action[3] = undefined;
            }
          }
          return Ember.tryFinally(tryable, finalizer);
        }
        function suspendListeners(obj, eventNames, target, method, callback) {
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var suspendedActions = [], eventName, actions, action, i, l;
          for (i = 0, l = eventNames.length; i < l; i++) {
            eventName = eventNames[i];
            actions = actionsFor(obj, eventName);
            var actionIndex = indexOf(actions, target, method);
            if (actionIndex !== -1) {
              action = actions[actionIndex].slice();
              action[3] = true;
              actions[actionIndex] = action;
              suspendedActions.push(action);
            }
          }
          function tryable() {
            return callback.call(target);
          }
          function finalizer() {
            for (i = 0, l = suspendedActions.length; i < l; i++) {
              suspendedActions[i][3] = undefined;
            }
          }
          return Ember.tryFinally(tryable, finalizer);
        }
        function watchedEvents(obj) {
          var listeners = obj[META_KEY].listeners, ret = [];
          if (listeners) {
            for (var eventName in listeners) {
              if (listeners[eventName]) {
                ret.push(eventName);
              }
            }
          }
          return ret;
        }
        function sendEvent(obj, eventName, params, actions) {
          if (obj !== Ember && 'function' === typeof obj.sendEvent) {
            obj.sendEvent(eventName, params);
          }
          if (!actions) {
            var meta = obj[META_KEY];
            actions = meta && meta.listeners && meta.listeners[eventName];
          }
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            if (!actions[i] || actions[i][3] === true) {
              continue;
            }
            var target = actions[i][0], method = actions[i][1], once = actions[i][2];
            if (once) {
              removeListener(obj, eventName, target, method);
            }
            if (!target) {
              target = obj;
            }
            if ('string' === typeof method) {
              method = target[method];
            }
            if (params) {
              method.apply(target, params);
            } else {
              method.call(target);
            }
          }
          return true;
        }
        function hasListeners(obj, eventName) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          return !!(actions && actions.length);
        }
        function listenersFor(obj, eventName) {
          var ret = [];
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          if (!actions) {
            return ret;
          }
          for (var i = 0, l = actions.length; i < l; i++) {
            var target = actions[i][0], method = actions[i][1];
            ret.push([
              target,
              method
            ]);
          }
          return ret;
        }
        Ember.addListener = addListener;
        Ember.removeListener = removeListener;
        Ember._suspendListener = suspendListener;
        Ember._suspendListeners = suspendListeners;
        Ember.sendEvent = sendEvent;
        Ember.hasListeners = hasListeners;
        Ember.watchedEvents = watchedEvents;
        Ember.listenersFor = listenersFor;
        Ember.listenersDiff = actionsDiff;
        Ember.listenersUnion = actionsUnion;
      }());
      (function () {
        var guidFor = Ember.guidFor, sendEvent = Ember.sendEvent;
        var ObserverSet = Ember._ObserverSet = function () {
            this.clear();
          };
        ObserverSet.prototype.add = function (sender, keyName, eventName) {
          var observerSet = this.observerSet, observers = this.observers, senderGuid = guidFor(sender), keySet = observerSet[senderGuid], index;
          if (!keySet) {
            observerSet[senderGuid] = keySet = {};
          }
          index = keySet[keyName];
          if (index === undefined) {
            index = observers.push({
              sender: sender,
              keyName: keyName,
              eventName: eventName,
              listeners: []
            }) - 1;
            keySet[keyName] = index;
          }
          return observers[index].listeners;
        };
        ObserverSet.prototype.flush = function () {
          var observers = this.observers, i, len, observer, sender;
          this.clear();
          for (i = 0, len = observers.length; i < len; ++i) {
            observer = observers[i];
            sender = observer.sender;
            if (sender.isDestroying || sender.isDestroyed) {
              continue;
            }
            sendEvent(sender, observer.eventName, [
              sender,
              observer.keyName
            ], observer.listeners);
          }
        };
        ObserverSet.prototype.clear = function () {
          this.observerSet = {};
          this.observers = [];
        };
      }());
      (function () {
        var metaFor = Ember.meta, guidFor = Ember.guidFor, tryFinally = Ember.tryFinally, sendEvent = Ember.sendEvent, listenersUnion = Ember.listenersUnion, listenersDiff = Ember.listenersDiff, ObserverSet = Ember._ObserverSet, beforeObserverSet = new ObserverSet, observerSet = new ObserverSet, deferred = 0;
        var propertyWillChange = Ember.propertyWillChange = function (obj, keyName) {
            var m = metaFor(obj, false), watching = m.watching[keyName] > 0 || keyName === 'length', proto = m.proto, desc = m.descs[keyName];
            if (!watching) {
              return;
            }
            if (proto === obj) {
              return;
            }
            if (desc && desc.willChange) {
              desc.willChange(obj, keyName);
            }
            dependentKeysWillChange(obj, keyName, m);
            chainsWillChange(obj, keyName, m);
            notifyBeforeObservers(obj, keyName);
          };
        var propertyDidChange = Ember.propertyDidChange = function (obj, keyName) {
            var m = metaFor(obj, false), watching = m.watching[keyName] > 0 || keyName === 'length', proto = m.proto, desc = m.descs[keyName];
            if (proto === obj) {
              return;
            }
            if (desc && desc.didChange) {
              desc.didChange(obj, keyName);
            }
            if (!watching && keyName !== 'length') {
              return;
            }
            dependentKeysDidChange(obj, keyName, m);
            chainsDidChange(obj, keyName, m);
            notifyObservers(obj, keyName);
          };
        var WILL_SEEN, DID_SEEN;
        function dependentKeysWillChange(obj, depKey, meta) {
          if (obj.isDestroying) {
            return;
          }
          var seen = WILL_SEEN, top = !seen;
          if (top) {
            seen = WILL_SEEN = {};
          }
          iterDeps(propertyWillChange, obj, depKey, seen, meta);
          if (top) {
            WILL_SEEN = null;
          }
        }
        function dependentKeysDidChange(obj, depKey, meta) {
          if (obj.isDestroying) {
            return;
          }
          var seen = DID_SEEN, top = !seen;
          if (top) {
            seen = DID_SEEN = {};
          }
          iterDeps(propertyDidChange, obj, depKey, seen, meta);
          if (top) {
            DID_SEEN = null;
          }
        }
        function iterDeps(method, obj, depKey, seen, meta) {
          var guid = guidFor(obj);
          if (!seen[guid])
            seen[guid] = {};
          if (seen[guid][depKey])
            return;
          seen[guid][depKey] = true;
          var deps = meta.deps;
          deps = deps && deps[depKey];
          if (deps) {
            for (var key in deps) {
              var desc = meta.descs[key];
              if (desc && desc._suspended === obj)
                continue;
              method(obj, key);
            }
          }
        }
        var chainsWillChange = function (obj, keyName, m, arg) {
          if (!m.hasOwnProperty('chainWatchers')) {
            return;
          }
          var nodes = m.chainWatchers;
          nodes = nodes[keyName];
          if (!nodes) {
            return;
          }
          for (var i = 0, l = nodes.length; i < l; i++) {
            nodes[i].willChange(arg);
          }
        };
        var chainsDidChange = function (obj, keyName, m, arg) {
          if (!m.hasOwnProperty('chainWatchers')) {
            return;
          }
          var nodes = m.chainWatchers;
          nodes = nodes[keyName];
          if (!nodes) {
            return;
          }
          for (var i = nodes.length - 1; i >= 0; i--) {
            nodes[i].didChange(arg);
          }
        };
        Ember.overrideChains = function (obj, keyName, m) {
          chainsDidChange(obj, keyName, m, true);
        };
        var beginPropertyChanges = Ember.beginPropertyChanges = function () {
            deferred++;
          };
        var endPropertyChanges = Ember.endPropertyChanges = function () {
            deferred--;
            if (deferred <= 0) {
              beforeObserverSet.clear();
              observerSet.flush();
            }
          };
        var changeProperties = Ember.changeProperties = function (cb, binding) {
            beginPropertyChanges();
            tryFinally(cb, endPropertyChanges, binding);
          };
        var notifyBeforeObservers = function (obj, keyName) {
          if (obj.isDestroying) {
            return;
          }
          var eventName = keyName + ':before', listeners, diff;
          if (deferred) {
            listeners = beforeObserverSet.add(obj, keyName, eventName);
            diff = listenersDiff(obj, eventName, listeners);
            sendEvent(obj, eventName, [
              obj,
              keyName
            ], diff);
          } else {
            sendEvent(obj, eventName, [
              obj,
              keyName
            ]);
          }
        };
        var notifyObservers = function (obj, keyName) {
          if (obj.isDestroying) {
            return;
          }
          var eventName = keyName + ':change', listeners;
          if (deferred) {
            listeners = observerSet.add(obj, keyName, eventName);
            listenersUnion(obj, eventName, listeners);
          } else {
            sendEvent(obj, eventName, [
              obj,
              keyName
            ]);
          }
        };
      }());
      (function () {
        var META_KEY = Ember.META_KEY, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, getPath = Ember._getPath;
        var set = function set(obj, keyName, value, tolerant) {
          if (typeof obj === 'string') {
            Ember.assert("Path '" + obj + "' must be global if no obj is given.", IS_GLOBAL.test(obj));
            value = keyName;
            keyName = obj;
            obj = null;
          }
          if (!obj || keyName.indexOf('.') !== -1) {
            return setPath(obj, keyName, value, tolerant);
          }
          Ember.assert('You need to provide an object and key to `set`.', !!obj && keyName !== undefined);
          Ember.assert('calling set on destroyed object', !obj.isDestroyed);
          var meta = obj[META_KEY], desc = meta && meta.descs[keyName], isUnknown, currentValue;
          if (desc) {
            desc.set(obj, keyName, value);
          } else {
            isUnknown = 'object' === typeof obj && !(keyName in obj);
            if (isUnknown && 'function' === typeof obj.setUnknownProperty) {
              obj.setUnknownProperty(keyName, value);
            } else if (meta && meta.watching[keyName] > 0) {
              if (MANDATORY_SETTER) {
                currentValue = meta.values[keyName];
              } else {
                currentValue = obj[keyName];
              }
              if (value !== currentValue) {
                Ember.propertyWillChange(obj, keyName);
                if (MANDATORY_SETTER) {
                  if (currentValue === undefined && !(keyName in obj)) {
                    Ember.defineProperty(obj, keyName, null, value);
                  } else {
                    meta.values[keyName] = value;
                  }
                } else {
                  obj[keyName] = value;
                }
                Ember.propertyDidChange(obj, keyName);
              }
            } else {
              obj[keyName] = value;
            }
          }
          return value;
        };
        if (Ember.config.overrideAccessors) {
          Ember.set = set;
          Ember.config.overrideAccessors();
          set = Ember.set;
        }
        function setPath(root, path, value, tolerant) {
          var keyName;
          keyName = path.slice(path.lastIndexOf('.') + 1);
          path = path.slice(0, path.length - (keyName.length + 1));
          if (path !== 'this') {
            root = getPath(root, path);
          }
          if (!keyName || keyName.length === 0) {
            throw new Error('You passed an empty path');
          }
          if (!root) {
            if (tolerant) {
              return;
            } else {
              throw new Error('Object in path ' + path + ' could not be found or was destroyed.');
            }
          }
          return set(root, keyName, value);
        }
        Ember.set = set;
        Ember.setPath = Ember.deprecateFunc('setPath is deprecated since set now supports paths', Ember.set);
        Ember.trySet = function (root, path, value) {
          return set(root, path, value, true);
        };
        Ember.trySetPath = Ember.deprecateFunc('trySetPath has been renamed to trySet', Ember.trySet);
      }());
      (function () {
        var META_KEY = Ember.META_KEY, metaFor = Ember.meta, objectDefineProperty = Ember.platform.defineProperty;
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        var Descriptor = Ember.Descriptor = function () {
          };
        var MANDATORY_SETTER_FUNCTION = Ember.MANDATORY_SETTER_FUNCTION = function (value) {
            Ember.assert('You must use Ember.set() to access this property (of ' + this + ')', false);
          };
        var DEFAULT_GETTER_FUNCTION = Ember.DEFAULT_GETTER_FUNCTION = function (name) {
            return function () {
              var meta = this[META_KEY];
              return meta && meta.values[name];
            };
          };
        Ember.defineProperty = function (obj, keyName, desc, data, meta) {
          var descs, existingDesc, watching, value;
          if (!meta)
            meta = metaFor(obj);
          descs = meta.descs;
          existingDesc = meta.descs[keyName];
          watching = meta.watching[keyName] > 0;
          if (existingDesc instanceof Ember.Descriptor) {
            existingDesc.teardown(obj, keyName);
          }
          if (desc instanceof Ember.Descriptor) {
            value = desc;
            descs[keyName] = desc;
            if (MANDATORY_SETTER && watching) {
              objectDefineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: undefined
              });
            } else {
              obj[keyName] = undefined;
            }
            desc.setup(obj, keyName);
          } else {
            descs[keyName] = undefined;
            if (desc == null) {
              value = data;
              if (MANDATORY_SETTER && watching) {
                meta.values[keyName] = data;
                objectDefineProperty(obj, keyName, {
                  configurable: true,
                  enumerable: true,
                  set: MANDATORY_SETTER_FUNCTION,
                  get: DEFAULT_GETTER_FUNCTION(keyName)
                });
              } else {
                obj[keyName] = data;
              }
            } else {
              value = desc;
              objectDefineProperty(obj, keyName, desc);
            }
          }
          if (watching) {
            Ember.overrideChains(obj, keyName, meta);
          }
          if (obj.didDefineProperty) {
            obj.didDefineProperty(obj, keyName, value);
          }
          return this;
        };
      }());
      (function () {
        var changeProperties = Ember.changeProperties, set = Ember.set;
        Ember.setProperties = function (self, hash) {
          changeProperties(function () {
            for (var prop in hash) {
              if (hash.hasOwnProperty(prop)) {
                set(self, prop, hash[prop]);
              }
            }
          });
          return self;
        };
      }());
      (function () {
        var metaFor = Ember.meta, isArray = Ember.isArray, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, o_defineProperty = Ember.platform.defineProperty;
        Ember.watchKey = function (obj, keyName) {
          if (keyName === 'length' && isArray(obj)) {
            return this;
          }
          var m = metaFor(obj), watching = m.watching, desc;
          if (!watching[keyName]) {
            watching[keyName] = 1;
            desc = m.descs[keyName];
            if (desc && desc.willWatch) {
              desc.willWatch(obj, keyName);
            }
            if ('function' === typeof obj.willWatchProperty) {
              obj.willWatchProperty(keyName);
            }
            if (MANDATORY_SETTER && keyName in obj) {
              m.values[keyName] = obj[keyName];
              o_defineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                set: Ember.MANDATORY_SETTER_FUNCTION,
                get: Ember.DEFAULT_GETTER_FUNCTION(keyName)
              });
            }
          } else {
            watching[keyName] = (watching[keyName] || 0) + 1;
          }
        };
        Ember.unwatchKey = function (obj, keyName) {
          var m = metaFor(obj), watching = m.watching, desc;
          if (watching[keyName] === 1) {
            watching[keyName] = 0;
            desc = m.descs[keyName];
            if (desc && desc.didUnwatch) {
              desc.didUnwatch(obj, keyName);
            }
            if ('function' === typeof obj.didUnwatchProperty) {
              obj.didUnwatchProperty(keyName);
            }
            if (MANDATORY_SETTER && keyName in obj) {
              o_defineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: m.values[keyName]
              });
              delete m.values[keyName];
            }
          } else if (watching[keyName] > 1) {
            watching[keyName]--;
          }
          return this;
        };
      }());
      (function () {
        var metaFor = Ember.meta, get = Ember.get, normalizeTuple = Ember.normalizeTuple, forEach = Ember.ArrayPolyfills.forEach, warn = Ember.warn, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, FIRST_KEY = /^([^\.\*]+)/;
        function firstKey(path) {
          return path.match(FIRST_KEY)[0];
        }
        var pendingQueue = [];
        Ember.flushPendingChains = function () {
          if (pendingQueue.length === 0) {
            return;
          }
          var queue = pendingQueue;
          pendingQueue = [];
          forEach.call(queue, function (q) {
            q[0].add(q[1]);
          });
          warn('Watching an undefined global, Ember expects watched globals to be setup by the time the run loop is flushed, check for typos', pendingQueue.length === 0);
        };
        function addChainWatcher(obj, keyName, node) {
          if (!obj || 'object' !== typeof obj) {
            return;
          }
          var m = metaFor(obj), nodes = m.chainWatchers;
          if (!m.hasOwnProperty('chainWatchers')) {
            nodes = m.chainWatchers = {};
          }
          if (!nodes[keyName]) {
            nodes[keyName] = [];
          }
          nodes[keyName].push(node);
          watchKey(obj, keyName);
        }
        var removeChainWatcher = Ember.removeChainWatcher = function (obj, keyName, node) {
            if (!obj || 'object' !== typeof obj) {
              return;
            }
            var m = metaFor(obj, false);
            if (!m.hasOwnProperty('chainWatchers')) {
              return;
            }
            var nodes = m.chainWatchers;
            if (nodes[keyName]) {
              nodes = nodes[keyName];
              for (var i = 0, l = nodes.length; i < l; i++) {
                if (nodes[i] === node) {
                  nodes.splice(i, 1);
                }
              }
            }
            unwatchKey(obj, keyName);
          };
        function isProto(pvalue) {
          return metaFor(pvalue, false).proto === pvalue;
        }
        var ChainNode = Ember._ChainNode = function (parent, key, value) {
            var obj;
            this._parent = parent;
            this._key = key;
            this._watching = value === undefined;
            this._value = value;
            this._paths = {};
            if (this._watching) {
              this._object = parent.value();
              if (this._object) {
                addChainWatcher(this._object, this._key, this);
              }
            }
            if (this._parent && this._parent._key === '@each') {
              this.value();
            }
          };
        var ChainNodePrototype = ChainNode.prototype;
        ChainNodePrototype.value = function () {
          if (this._value === undefined && this._watching) {
            var obj = this._parent.value();
            this._value = obj && !isProto(obj) ? get(obj, this._key) : undefined;
          }
          return this._value;
        };
        ChainNodePrototype.destroy = function () {
          if (this._watching) {
            var obj = this._object;
            if (obj) {
              removeChainWatcher(obj, this._key, this);
            }
            this._watching = false;
          }
        };
        ChainNodePrototype.copy = function (obj) {
          var ret = new ChainNode(null, null, obj), paths = this._paths, path;
          for (path in paths) {
            if (paths[path] <= 0) {
              continue;
            }
            ret.add(path);
          }
          return ret;
        };
        ChainNodePrototype.add = function (path) {
          var obj, tuple, key, src, paths;
          paths = this._paths;
          paths[path] = (paths[path] || 0) + 1;
          obj = this.value();
          tuple = normalizeTuple(obj, path);
          if (tuple[0] && tuple[0] === obj) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);
          } else if (!tuple[0]) {
            pendingQueue.push([
              this,
              path
            ]);
            tuple.length = 0;
            return;
          } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            path = tuple[1];
          }
          tuple.length = 0;
          this.chain(key, path, src);
        };
        ChainNodePrototype.remove = function (path) {
          var obj, tuple, key, src, paths;
          paths = this._paths;
          if (paths[path] > 0) {
            paths[path]--;
          }
          obj = this.value();
          tuple = normalizeTuple(obj, path);
          if (tuple[0] === obj) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);
          } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            path = tuple[1];
          }
          tuple.length = 0;
          this.unchain(key, path);
        };
        ChainNodePrototype.count = 0;
        ChainNodePrototype.chain = function (key, path, src) {
          var chains = this._chains, node;
          if (!chains) {
            chains = this._chains = {};
          }
          node = chains[key];
          if (!node) {
            node = chains[key] = new ChainNode(this, key, src);
          }
          node.count++;
          if (path && path.length > 0) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.chain(key, path);
          }
        };
        ChainNodePrototype.unchain = function (key, path) {
          var chains = this._chains, node = chains[key];
          if (path && path.length > 1) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.unchain(key, path);
          }
          node.count--;
          if (node.count <= 0) {
            delete chains[node._key];
            node.destroy();
          }
        };
        ChainNodePrototype.willChange = function () {
          var chains = this._chains;
          if (chains) {
            for (var key in chains) {
              if (!chains.hasOwnProperty(key)) {
                continue;
              }
              chains[key].willChange();
            }
          }
          if (this._parent) {
            this._parent.chainWillChange(this, this._key, 1);
          }
        };
        ChainNodePrototype.chainWillChange = function (chain, path, depth) {
          if (this._key) {
            path = this._key + '.' + path;
          }
          if (this._parent) {
            this._parent.chainWillChange(this, path, depth + 1);
          } else {
            if (depth > 1) {
              propertyWillChange(this.value(), path);
            }
            path = 'this.' + path;
            if (this._paths[path] > 0) {
              propertyWillChange(this.value(), path);
            }
          }
        };
        ChainNodePrototype.chainDidChange = function (chain, path, depth) {
          if (this._key) {
            path = this._key + '.' + path;
          }
          if (this._parent) {
            this._parent.chainDidChange(this, path, depth + 1);
          } else {
            if (depth > 1) {
              propertyDidChange(this.value(), path);
            }
            path = 'this.' + path;
            if (this._paths[path] > 0) {
              propertyDidChange(this.value(), path);
            }
          }
        };
        ChainNodePrototype.didChange = function (suppressEvent) {
          if (this._watching) {
            var obj = this._parent.value();
            if (obj !== this._object) {
              removeChainWatcher(this._object, this._key, this);
              this._object = obj;
              addChainWatcher(obj, this._key, this);
            }
            this._value = undefined;
            if (this._parent && this._parent._key === '@each')
              this.value();
          }
          var chains = this._chains;
          if (chains) {
            for (var key in chains) {
              if (!chains.hasOwnProperty(key)) {
                continue;
              }
              chains[key].didChange(suppressEvent);
            }
          }
          if (suppressEvent) {
            return;
          }
          if (this._parent) {
            this._parent.chainDidChange(this, this._key, 1);
          }
        };
        Ember.finishChains = function (obj) {
          var m = metaFor(obj, false), chains = m.chains;
          if (chains) {
            if (chains.value() !== obj) {
              m.chains = chains = chains.copy(obj);
            }
            chains.didChange(true);
          }
        };
      }());
      (function () {
        var metaFor = Ember.meta, isArray = Ember.isArray, ChainNode = Ember._ChainNode;
        function chainsFor(obj) {
          var m = metaFor(obj), ret = m.chains;
          if (!ret) {
            ret = m.chains = new ChainNode(null, null, obj);
          } else if (ret.value() !== obj) {
            ret = m.chains = ret.copy(obj);
          }
          return ret;
        }
        Ember.watchPath = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return;
          }
          var m = metaFor(obj), watching = m.watching;
          if (!watching[keyPath]) {
            watching[keyPath] = 1;
            chainsFor(obj).add(keyPath);
          } else {
            watching[keyPath] = (watching[keyPath] || 0) + 1;
          }
        };
        Ember.unwatchPath = function (obj, keyPath) {
          var m = metaFor(obj), watching = m.watching, desc;
          if (watching[keyPath] === 1) {
            watching[keyPath] = 0;
            chainsFor(obj).remove(keyPath);
          } else if (watching[keyPath] > 1) {
            watching[keyPath]--;
          }
          return this;
        };
      }());
      (function () {
        var metaFor = Ember.meta, GUID_KEY = Ember.GUID_KEY, META_KEY = Ember.META_KEY, removeChainWatcher = Ember.removeChainWatcher, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, watchPath = Ember.watchPath, unwatchPath = Ember.unwatchPath, isArray = Ember.isArray, generateGuid = Ember.generateGuid, IS_PATH = /[\.\*]/;
        function isKeyName(path) {
          return path === '*' || !IS_PATH.test(path);
        }
        Ember.watch = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return;
          }
          if (isKeyName(keyPath)) {
            watchKey(obj, keyPath);
          } else {
            watchPath(obj, keyPath);
          }
        };
        Ember.isWatching = function isWatching(obj, key) {
          var meta = obj[META_KEY];
          return (meta && meta.watching[key]) > 0;
        };
        Ember.watch.flushPending = Ember.flushPendingChains;
        Ember.unwatch = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return this;
          }
          if (isKeyName(keyPath)) {
            unwatchKey(obj, keyPath);
          } else {
            unwatchPath(obj, keyPath);
          }
        };
        Ember.rewatch = function (obj) {
          var m = metaFor(obj, false), chains = m.chains;
          if (GUID_KEY in obj && !obj.hasOwnProperty(GUID_KEY)) {
            generateGuid(obj, 'ember');
          }
          if (chains && chains.value() !== obj) {
            m.chains = chains.copy(obj);
          }
          return this;
        };
        var NODE_STACK = [];
        Ember.destroy = function (obj) {
          var meta = obj[META_KEY], node, nodes, key, nodeObject;
          if (meta) {
            obj[META_KEY] = null;
            node = meta.chains;
            if (node) {
              NODE_STACK.push(node);
              while (NODE_STACK.length > 0) {
                node = NODE_STACK.pop();
                nodes = node._chains;
                if (nodes) {
                  for (key in nodes) {
                    if (nodes.hasOwnProperty(key)) {
                      NODE_STACK.push(nodes[key]);
                    }
                  }
                }
                if (node._watching) {
                  nodeObject = node._object;
                  if (nodeObject) {
                    removeChainWatcher(nodeObject, node._key, node);
                  }
                }
              }
            }
          }
        };
      }());
      (function () {
        Ember.warn("The CP_DEFAULT_CACHEABLE flag has been removed and computed properties are always cached by default. Use `volatile` if you don't want caching.", Ember.ENV.CP_DEFAULT_CACHEABLE !== false);
        var get = Ember.get, set = Ember.set, metaFor = Ember.meta, a_slice = [].slice, o_create = Ember.create, META_KEY = Ember.META_KEY, watch = Ember.watch, unwatch = Ember.unwatch;
        function keysForDep(obj, depsMeta, depKey) {
          var keys = depsMeta[depKey];
          if (!keys) {
            keys = depsMeta[depKey] = {};
          } else if (!depsMeta.hasOwnProperty(depKey)) {
            keys = depsMeta[depKey] = o_create(keys);
          }
          return keys;
        }
        function metaForDeps(obj, meta) {
          return keysForDep(obj, meta, 'deps');
        }
        function addDependentKeys(desc, obj, keyName, meta) {
          var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
          if (!depKeys)
            return;
          depsMeta = metaForDeps(obj, meta);
          for (idx = 0, len = depKeys.length; idx < len; idx++) {
            depKey = depKeys[idx];
            keys = keysForDep(obj, depsMeta, depKey);
            keys[keyName] = (keys[keyName] || 0) + 1;
            watch(obj, depKey);
          }
        }
        function removeDependentKeys(desc, obj, keyName, meta) {
          var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
          if (!depKeys)
            return;
          depsMeta = metaForDeps(obj, meta);
          for (idx = 0, len = depKeys.length; idx < len; idx++) {
            depKey = depKeys[idx];
            keys = keysForDep(obj, depsMeta, depKey);
            keys[keyName] = (keys[keyName] || 0) - 1;
            unwatch(obj, depKey);
          }
        }
        function ComputedProperty(func, opts) {
          this.func = func;
          this._cacheable = opts && opts.cacheable !== undefined ? opts.cacheable : true;
          this._dependentKeys = opts && opts.dependentKeys;
          this._readOnly = opts && (opts.readOnly !== undefined || !!opts.readOnly);
        }
        Ember.ComputedProperty = ComputedProperty;
        ComputedProperty.prototype = new Ember.Descriptor;
        var ComputedPropertyPrototype = ComputedProperty.prototype;
        ComputedPropertyPrototype.cacheable = function (aFlag) {
          this._cacheable = aFlag !== false;
          return this;
        };
        ComputedPropertyPrototype.volatile = function () {
          return this.cacheable(false);
        };
        ComputedPropertyPrototype.readOnly = function (readOnly) {
          this._readOnly = readOnly === undefined || !!readOnly;
          return this;
        };
        ComputedPropertyPrototype.property = function () {
          var args = [];
          for (var i = 0, l = arguments.length; i < l; i++) {
            args.push(arguments[i]);
          }
          this._dependentKeys = args;
          return this;
        };
        ComputedPropertyPrototype.meta = function (meta) {
          if (arguments.length === 0) {
            return this._meta || {};
          } else {
            this._meta = meta;
            return this;
          }
        };
        ComputedPropertyPrototype.willWatch = function (obj, keyName) {
          var meta = obj[META_KEY];
          Ember.assert('watch should have setup meta to be writable', meta.source === obj);
          if (!(keyName in meta.cache)) {
            addDependentKeys(this, obj, keyName, meta);
          }
        };
        ComputedPropertyPrototype.didUnwatch = function (obj, keyName) {
          var meta = obj[META_KEY];
          Ember.assert('unwatch should have setup meta to be writable', meta.source === obj);
          if (!(keyName in meta.cache)) {
            removeDependentKeys(this, obj, keyName, meta);
          }
        };
        ComputedPropertyPrototype.didChange = function (obj, keyName) {
          if (this._cacheable && this._suspended !== obj) {
            var meta = metaFor(obj);
            if (keyName in meta.cache) {
              delete meta.cache[keyName];
              if (!meta.watching[keyName]) {
                removeDependentKeys(this, obj, keyName, meta);
              }
            }
          }
        };
        ComputedPropertyPrototype.get = function (obj, keyName) {
          var ret, cache, meta;
          if (this._cacheable) {
            meta = metaFor(obj);
            cache = meta.cache;
            if (keyName in cache) {
              return cache[keyName];
            }
            ret = cache[keyName] = this.func.call(obj, keyName);
            if (!meta.watching[keyName]) {
              addDependentKeys(this, obj, keyName, meta);
            }
          } else {
            ret = this.func.call(obj, keyName);
          }
          return ret;
        };
        ComputedPropertyPrototype.set = function (obj, keyName, value) {
          var cacheable = this._cacheable, func = this.func, meta = metaFor(obj, cacheable), watched = meta.watching[keyName], oldSuspended = this._suspended, hadCachedValue = false, cache = meta.cache, cachedValue, ret;
          if (this._readOnly) {
            throw new Error('Cannot Set: ' + keyName + ' on: ' + obj.toString());
          }
          this._suspended = obj;
          try {
            if (cacheable && cache.hasOwnProperty(keyName)) {
              cachedValue = cache[keyName];
              hadCachedValue = true;
            }
            if (func.wrappedFunction) {
              func = func.wrappedFunction;
            }
            if (func.length === 3) {
              ret = func.call(obj, keyName, value, cachedValue);
            } else if (func.length === 2) {
              ret = func.call(obj, keyName, value);
            } else {
              Ember.defineProperty(obj, keyName, null, cachedValue);
              Ember.set(obj, keyName, value);
              return;
            }
            if (hadCachedValue && cachedValue === ret) {
              return;
            }
            if (watched) {
              Ember.propertyWillChange(obj, keyName);
            }
            if (hadCachedValue) {
              delete cache[keyName];
            }
            if (cacheable) {
              if (!watched && !hadCachedValue) {
                addDependentKeys(this, obj, keyName, meta);
              }
              cache[keyName] = ret;
            }
            if (watched) {
              Ember.propertyDidChange(obj, keyName);
            }
          } finally {
            this._suspended = oldSuspended;
          }
          return ret;
        };
        ComputedPropertyPrototype.setup = function (obj, keyName) {
          var meta = obj[META_KEY];
          if (meta && meta.watching[keyName]) {
            addDependentKeys(this, obj, keyName, metaFor(obj));
          }
        };
        ComputedPropertyPrototype.teardown = function (obj, keyName) {
          var meta = metaFor(obj);
          if (meta.watching[keyName] || keyName in meta.cache) {
            removeDependentKeys(this, obj, keyName, meta);
          }
          if (this._cacheable) {
            delete meta.cache[keyName];
          }
          return null;
        };
        Ember.computed = function (func) {
          var args;
          if (arguments.length > 1) {
            args = a_slice.call(arguments, 0, -1);
            func = a_slice.call(arguments, -1)[0];
          }
          if (typeof func !== 'function') {
            throw new Error('Computed Property declared without a property function');
          }
          var cp = new ComputedProperty(func);
          if (args) {
            cp.property.apply(cp, args);
          }
          return cp;
        };
        Ember.cacheFor = function cacheFor(obj, key) {
          var cache = metaFor(obj, false).cache;
          if (cache && key in cache) {
            return cache[key];
          }
        };
        function getProperties(self, propertyNames) {
          var ret = {};
          for (var i = 0; i < propertyNames.length; i++) {
            ret[propertyNames[i]] = get(self, propertyNames[i]);
          }
          return ret;
        }
        function registerComputed(name, macro) {
          Ember.computed[name] = function (dependentKey) {
            var args = a_slice.call(arguments);
            return Ember.computed(dependentKey, function () {
              return macro.apply(this, args);
            });
          };
        }
        function registerComputedWithProperties(name, macro) {
          Ember.computed[name] = function () {
            var properties = a_slice.call(arguments);
            var computed = Ember.computed(function () {
                return macro.apply(this, [getProperties(this, properties)]);
              });
            return computed.property.apply(computed, properties);
          };
        }
        registerComputed('empty', function (dependentKey) {
          return Ember.isEmpty(get(this, dependentKey));
        });
        registerComputed('notEmpty', function (dependentKey) {
          return !Ember.isEmpty(get(this, dependentKey));
        });
        registerComputed('none', function (dependentKey) {
          return Ember.isNone(get(this, dependentKey));
        });
        registerComputed('not', function (dependentKey) {
          return !get(this, dependentKey);
        });
        registerComputed('bool', function (dependentKey) {
          return !!get(this, dependentKey);
        });
        registerComputed('match', function (dependentKey, regexp) {
          var value = get(this, dependentKey);
          return typeof value === 'string' ? !!value.match(regexp) : false;
        });
        registerComputed('equal', function (dependentKey, value) {
          return get(this, dependentKey) === value;
        });
        registerComputed('gt', function (dependentKey, value) {
          return get(this, dependentKey) > value;
        });
        registerComputed('gte', function (dependentKey, value) {
          return get(this, dependentKey) >= value;
        });
        registerComputed('lt', function (dependentKey, value) {
          return get(this, dependentKey) < value;
        });
        registerComputed('lte', function (dependentKey, value) {
          return get(this, dependentKey) <= value;
        });
        registerComputedWithProperties('and', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && !properties[key]) {
              return false;
            }
          }
          return true;
        });
        registerComputedWithProperties('or', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && properties[key]) {
              return true;
            }
          }
          return false;
        });
        registerComputedWithProperties('any', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && properties[key]) {
              return properties[key];
            }
          }
          return null;
        });
        registerComputedWithProperties('map', function (properties) {
          var res = [];
          for (var key in properties) {
            if (properties.hasOwnProperty(key)) {
              if (Ember.isNone(properties[key])) {
                res.push(null);
              } else {
                res.push(properties[key]);
              }
            }
          }
          return res;
        });
        Ember.computed.alias = function (dependentKey) {
          return Ember.computed(dependentKey, function (key, value) {
            if (arguments.length > 1) {
              set(this, dependentKey, value);
              return value;
            } else {
              return get(this, dependentKey);
            }
          });
        };
        Ember.computed.defaultTo = function (defaultPath) {
          return Ember.computed(function (key, newValue, cachedValue) {
            var result;
            if (arguments.length === 1) {
              return cachedValue != null ? cachedValue : get(this, defaultPath);
            }
            return newValue != null ? newValue : get(this, defaultPath);
          });
        };
      }());
      (function () {
        var AFTER_OBSERVERS = ':change';
        var BEFORE_OBSERVERS = ':before';
        var guidFor = Ember.guidFor;
        function changeEvent(keyName) {
          return keyName + AFTER_OBSERVERS;
        }
        function beforeEvent(keyName) {
          return keyName + BEFORE_OBSERVERS;
        }
        Ember.addObserver = function (obj, path, target, method) {
          Ember.addListener(obj, changeEvent(path), target, method);
          Ember.watch(obj, path);
          return this;
        };
        Ember.observersFor = function (obj, path) {
          return Ember.listenersFor(obj, changeEvent(path));
        };
        Ember.removeObserver = function (obj, path, target, method) {
          Ember.unwatch(obj, path);
          Ember.removeListener(obj, changeEvent(path), target, method);
          return this;
        };
        Ember.addBeforeObserver = function (obj, path, target, method) {
          Ember.addListener(obj, beforeEvent(path), target, method);
          Ember.watch(obj, path);
          return this;
        };
        Ember._suspendBeforeObserver = function (obj, path, target, method, callback) {
          return Ember._suspendListener(obj, beforeEvent(path), target, method, callback);
        };
        Ember._suspendObserver = function (obj, path, target, method, callback) {
          return Ember._suspendListener(obj, changeEvent(path), target, method, callback);
        };
        var map = Ember.ArrayPolyfills.map;
        Ember._suspendBeforeObservers = function (obj, paths, target, method, callback) {
          var events = map.call(paths, beforeEvent);
          return Ember._suspendListeners(obj, events, target, method, callback);
        };
        Ember._suspendObservers = function (obj, paths, target, method, callback) {
          var events = map.call(paths, changeEvent);
          return Ember._suspendListeners(obj, events, target, method, callback);
        };
        Ember.beforeObserversFor = function (obj, path) {
          return Ember.listenersFor(obj, beforeEvent(path));
        };
        Ember.removeBeforeObserver = function (obj, path, target, method) {
          Ember.unwatch(obj, path);
          Ember.removeListener(obj, beforeEvent(path), target, method);
          return this;
        };
      }());
      (function () {
        var slice = [].slice, forEach = Ember.ArrayPolyfills.forEach;
        function invoke(target, method, args, ignore) {
          if (method === undefined) {
            method = target;
            target = undefined;
          }
          if ('string' === typeof method) {
            method = target[method];
          }
          if (args && ignore > 0) {
            args = args.length > ignore ? slice.call(args, ignore) : null;
          }
          return Ember.handleErrors(function () {
            return method.apply(target || this, args || []);
          }, this);
        }
        var timerMark;
        var RunLoop = function (prev) {
          this._prev = prev || null;
          this.onceTimers = {};
        };
        RunLoop.prototype = {
          end: function () {
            this.flush();
          },
          prev: function () {
            return this._prev;
          },
          schedule: function (queueName, target, method) {
            var queues = this._queues, queue;
            if (!queues) {
              queues = this._queues = {};
            }
            queue = queues[queueName];
            if (!queue) {
              queue = queues[queueName] = [];
            }
            var args = arguments.length > 3 ? slice.call(arguments, 3) : null;
            queue.push({
              target: target,
              method: method,
              args: args
            });
            return this;
          },
          flush: function (queueName) {
            var queueNames, idx, len, queue, log;
            if (!this._queues) {
              return this;
            }
            function iter(item) {
              invoke(item.target, item.method, item.args);
            }
            function tryable() {
              forEach.call(queue, iter);
            }
            Ember.watch.flushPending();
            if (queueName) {
              while (this._queues && (queue = this._queues[queueName])) {
                this._queues[queueName] = null;
                if (queueName === 'sync') {
                  log = Ember.LOG_BINDINGS;
                  if (log) {
                    Ember.Logger.log('Begin: Flush Sync Queue');
                  }
                  Ember.beginPropertyChanges();
                  Ember.tryFinally(tryable, Ember.endPropertyChanges);
                  if (log) {
                    Ember.Logger.log('End: Flush Sync Queue');
                  }
                } else {
                  forEach.call(queue, iter);
                }
              }
            } else {
              queueNames = Ember.run.queues;
              len = queueNames.length;
              idx = 0;
              outerloop:
                while (idx < len) {
                  queueName = queueNames[idx];
                  queue = this._queues && this._queues[queueName];
                  delete this._queues[queueName];
                  if (queue) {
                    if (queueName === 'sync') {
                      log = Ember.LOG_BINDINGS;
                      if (log) {
                        Ember.Logger.log('Begin: Flush Sync Queue');
                      }
                      Ember.beginPropertyChanges();
                      Ember.tryFinally(tryable, Ember.endPropertyChanges);
                      if (log) {
                        Ember.Logger.log('End: Flush Sync Queue');
                      }
                    } else {
                      forEach.call(queue, iter);
                    }
                  }
                  for (var i = 0; i <= idx; i++) {
                    if (this._queues && this._queues[queueNames[i]]) {
                      idx = i;
                      continue outerloop;
                    }
                  }
                  idx++;
                }
            }
            timerMark = null;
            return this;
          }
        };
        Ember.RunLoop = RunLoop;
        Ember.run = function (target, method) {
          var args = arguments;
          run.begin();
          function tryable() {
            if (target || method) {
              return invoke(target, method, args, 2);
            }
          }
          return Ember.tryFinally(tryable, run.end);
        };
        var run = Ember.run;
        Ember.run.begin = function () {
          run.currentRunLoop = new RunLoop(run.currentRunLoop);
        };
        Ember.run.end = function () {
          Ember.assert('must have a current run loop', run.currentRunLoop);
          function tryable() {
            run.currentRunLoop.end();
          }
          function finalizer() {
            run.currentRunLoop = run.currentRunLoop.prev();
          }
          Ember.tryFinally(tryable, finalizer);
        };
        Ember.run.queues = [
          'sync',
          'actions',
          'destroy'
        ];
        Ember.run.schedule = function (queue, target, method) {
          var loop = run.autorun();
          loop.schedule.apply(loop, arguments);
        };
        var scheduledAutorun;
        function autorun() {
          scheduledAutorun = null;
          if (run.currentRunLoop) {
            run.end();
          }
        }
        Ember.run.hasScheduledTimers = function () {
          return !!(scheduledAutorun || scheduledLater);
        };
        Ember.run.cancelTimers = function () {
          if (scheduledAutorun) {
            clearTimeout(scheduledAutorun);
            scheduledAutorun = null;
          }
          if (scheduledLater) {
            clearTimeout(scheduledLater);
            scheduledLater = null;
          }
          timers = {};
        };
        Ember.run.autorun = function () {
          if (!run.currentRunLoop) {
            Ember.assert("You have turned on testing mode, which disabled the run-loop's autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run", !Ember.testing);
            run.begin();
            if (!scheduledAutorun) {
              scheduledAutorun = setTimeout(autorun, 1);
            }
          }
          return run.currentRunLoop;
        };
        Ember.run.sync = function () {
          run.autorun();
          run.currentRunLoop.flush('sync');
        };
        var timers = {};
        var scheduledLater, scheduledLaterExpires;
        function invokeLaterTimers() {
          scheduledLater = null;
          run(function () {
            var now = +new Date, earliest = -1;
            for (var key in timers) {
              if (!timers.hasOwnProperty(key)) {
                continue;
              }
              var timer = timers[key];
              if (timer && timer.expires) {
                if (now >= timer.expires) {
                  delete timers[key];
                  invoke(timer.target, timer.method, timer.args, 2);
                } else {
                  if (earliest < 0 || timer.expires < earliest) {
                    earliest = timer.expires;
                  }
                }
              }
            }
            if (earliest > 0) {
              scheduledLater = setTimeout(invokeLaterTimers, earliest - now);
              scheduledLaterExpires = earliest;
            }
          });
        }
        Ember.run.later = function (target, method) {
          var args, expires, timer, guid, wait;
          if (arguments.length === 2 && 'function' === typeof target) {
            wait = method;
            method = target;
            target = undefined;
            args = [
              target,
              method
            ];
          } else {
            args = slice.call(arguments);
            wait = args.pop();
          }
          expires = +new Date + wait;
          timer = {
            target: target,
            method: method,
            expires: expires,
            args: args
          };
          guid = Ember.guidFor(timer);
          timers[guid] = timer;
          if (scheduledLater && expires < scheduledLaterExpires) {
            clearTimeout(scheduledLater);
            scheduledLater = null;
          }
          if (!scheduledLater) {
            scheduledLater = setTimeout(invokeLaterTimers, wait);
            scheduledLaterExpires = expires;
          }
          return guid;
        };
        function invokeOnceTimer(guid, onceTimers) {
          if (onceTimers[this.tguid]) {
            delete onceTimers[this.tguid][this.mguid];
          }
          if (timers[guid]) {
            invoke(this.target, this.method, this.args);
          }
          delete timers[guid];
        }
        function scheduleOnce(queue, target, method, args) {
          var tguid = Ember.guidFor(target), mguid = Ember.guidFor(method), onceTimers = run.autorun().onceTimers, guid = onceTimers[tguid] && onceTimers[tguid][mguid], timer;
          if (guid && timers[guid]) {
            timers[guid].args = args;
          } else {
            timer = {
              target: target,
              method: method,
              args: args,
              tguid: tguid,
              mguid: mguid
            };
            guid = Ember.guidFor(timer);
            timers[guid] = timer;
            if (!onceTimers[tguid]) {
              onceTimers[tguid] = {};
            }
            onceTimers[tguid][mguid] = guid;
            run.schedule(queue, timer, invokeOnceTimer, guid, onceTimers);
          }
          return guid;
        }
        Ember.run.once = function (target, method) {
          return scheduleOnce('actions', target, method, slice.call(arguments, 2));
        };
        Ember.run.scheduleOnce = function (queue, target, method, args) {
          return scheduleOnce(queue, target, method, slice.call(arguments, 3));
        };
        Ember.run.next = function () {
          var args = slice.call(arguments);
          args.push(1);
          return run.later.apply(this, args);
        };
        Ember.run.cancel = function (timer) {
          delete timers[timer];
        };
      }());
      (function () {
        Ember.LOG_BINDINGS = false || !!Ember.ENV.LOG_BINDINGS;
        var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/;
        var isGlobalPath = Ember.isGlobalPath = function (path) {
            return IS_GLOBAL.test(path);
          };
        function getWithGlobals(obj, path) {
          return get(isGlobalPath(path) ? Ember.lookup : obj, path);
        }
        var Binding = function (toPath, fromPath) {
          this._direction = 'fwd';
          this._from = fromPath;
          this._to = toPath;
          this._directionMap = Ember.Map.create();
        };
        Binding.prototype = {
          copy: function () {
            var copy = new Binding(this._to, this._from);
            if (this._oneWay) {
              copy._oneWay = true;
            }
            return copy;
          },
          from: function (path) {
            this._from = path;
            return this;
          },
          to: function (path) {
            this._to = path;
            return this;
          },
          oneWay: function () {
            this._oneWay = true;
            return this;
          },
          toString: function () {
            var oneWay = this._oneWay ? '[oneWay]' : '';
            return 'Ember.Binding<' + guidFor(this) + '>(' + this._from + ' -> ' + this._to + ')' + oneWay;
          },
          connect: function (obj) {
            Ember.assert('Must pass a valid object to Ember.Binding.connect()', !!obj);
            var fromPath = this._from, toPath = this._to;
            Ember.trySet(obj, toPath, getWithGlobals(obj, fromPath));
            Ember.addObserver(obj, fromPath, this, this.fromDidChange);
            if (!this._oneWay) {
              Ember.addObserver(obj, toPath, this, this.toDidChange);
            }
            this._readyToSync = true;
            return this;
          },
          disconnect: function (obj) {
            Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);
            var twoWay = !this._oneWay;
            Ember.removeObserver(obj, this._from, this, this.fromDidChange);
            if (twoWay) {
              Ember.removeObserver(obj, this._to, this, this.toDidChange);
            }
            this._readyToSync = false;
            return this;
          },
          fromDidChange: function (target) {
            this._scheduleSync(target, 'fwd');
          },
          toDidChange: function (target) {
            this._scheduleSync(target, 'back');
          },
          _scheduleSync: function (obj, dir) {
            var directionMap = this._directionMap;
            var existingDir = directionMap.get(obj);
            if (!existingDir) {
              Ember.run.schedule('sync', this, this._sync, obj);
              directionMap.set(obj, dir);
            }
            if (existingDir === 'back' && dir === 'fwd') {
              directionMap.set(obj, 'fwd');
            }
          },
          _sync: function (obj) {
            var log = Ember.LOG_BINDINGS;
            if (obj.isDestroyed || !this._readyToSync) {
              return;
            }
            var directionMap = this._directionMap;
            var direction = directionMap.get(obj);
            var fromPath = this._from, toPath = this._to;
            directionMap.remove(obj);
            if (direction === 'fwd') {
              var fromValue = getWithGlobals(obj, this._from);
              if (log) {
                Ember.Logger.log(' ', this.toString(), '->', fromValue, obj);
              }
              if (this._oneWay) {
                Ember.trySet(obj, toPath, fromValue);
              } else {
                Ember._suspendObserver(obj, toPath, this, this.toDidChange, function () {
                  Ember.trySet(obj, toPath, fromValue);
                });
              }
            } else if (direction === 'back') {
              var toValue = get(obj, this._to);
              if (log) {
                Ember.Logger.log(' ', this.toString(), '<-', toValue, obj);
              }
              Ember._suspendObserver(obj, fromPath, this, this.fromDidChange, function () {
                Ember.trySet(Ember.isGlobalPath(fromPath) ? Ember.lookup : obj, fromPath, toValue);
              });
            }
          }
        };
        function mixinProperties(to, from) {
          for (var key in from) {
            if (from.hasOwnProperty(key)) {
              to[key] = from[key];
            }
          }
        }
        mixinProperties(Binding, {
          from: function () {
            var C = this, binding = new C;
            return binding.from.apply(binding, arguments);
          },
          to: function () {
            var C = this, binding = new C;
            return binding.to.apply(binding, arguments);
          },
          oneWay: function (from, flag) {
            var C = this, binding = new C(null, from);
            return binding.oneWay(flag);
          }
        });
        Ember.Binding = Binding;
        Ember.bind = function (obj, to, from) {
          return new Ember.Binding(to, from).connect(obj);
        };
        Ember.oneWay = function (obj, to, from) {
          return new Ember.Binding(to, from).oneWay().connect(obj);
        };
      }());
      (function () {
        var Mixin, REQUIRED, Alias, a_map = Ember.ArrayPolyfills.map, a_indexOf = Ember.ArrayPolyfills.indexOf, a_forEach = Ember.ArrayPolyfills.forEach, a_slice = [].slice, o_create = Ember.create, defineProperty = Ember.defineProperty, guidFor = Ember.guidFor;
        function mixinsMeta(obj) {
          var m = Ember.meta(obj, true), ret = m.mixins;
          if (!ret) {
            ret = m.mixins = {};
          } else if (!m.hasOwnProperty('mixins')) {
            ret = m.mixins = o_create(ret);
          }
          return ret;
        }
        function initMixin(mixin, args) {
          if (args && args.length > 0) {
            mixin.mixins = a_map.call(args, function (x) {
              if (x instanceof Mixin) {
                return x;
              }
              var mixin = new Mixin;
              mixin.properties = x;
              return mixin;
            });
          }
          return mixin;
        }
        function isMethod(obj) {
          return 'function' === typeof obj && obj.isMethod !== false && obj !== Boolean && obj !== Object && obj !== Number && obj !== Array && obj !== Date && obj !== String;
        }
        var CONTINUE = {};
        function mixinProperties(mixinsMeta, mixin) {
          var guid;
          if (mixin instanceof Mixin) {
            guid = guidFor(mixin);
            if (mixinsMeta[guid]) {
              return CONTINUE;
            }
            mixinsMeta[guid] = mixin;
            return mixin.properties;
          } else {
            return mixin;
          }
        }
        function concatenatedProperties(props, values, base) {
          var concats;
          concats = values.concatenatedProperties || base.concatenatedProperties;
          if (props.concatenatedProperties) {
            concats = concats ? concats.concat(props.concatenatedProperties) : props.concatenatedProperties;
          }
          return concats;
        }
        function giveDescriptorSuper(meta, key, property, values, descs) {
          var superProperty;
          if (values[key] === undefined) {
            superProperty = descs[key];
          }
          superProperty = superProperty || meta.descs[key];
          if (!superProperty || !(superProperty instanceof Ember.ComputedProperty)) {
            return property;
          }
          property = o_create(property);
          property.func = Ember.wrap(property.func, superProperty.func);
          return property;
        }
        function giveMethodSuper(obj, key, method, values, descs) {
          var superMethod;
          if (descs[key] === undefined) {
            superMethod = values[key];
          }
          superMethod = superMethod || obj[key];
          if ('function' !== typeof superMethod) {
            return method;
          }
          return Ember.wrap(method, superMethod);
        }
        function applyConcatenatedProperties(obj, key, value, values) {
          var baseValue = values[key] || obj[key];
          if (baseValue) {
            if ('function' === typeof baseValue.concat) {
              return baseValue.concat(value);
            } else {
              return Ember.makeArray(baseValue).concat(value);
            }
          } else {
            return Ember.makeArray(value);
          }
        }
        function addNormalizedProperty(base, key, value, meta, descs, values, concats) {
          if (value instanceof Ember.Descriptor) {
            if (value === REQUIRED && descs[key]) {
              return CONTINUE;
            }
            if (value.func) {
              value = giveDescriptorSuper(meta, key, value, values, descs);
            }
            descs[key] = value;
            values[key] = undefined;
          } else {
            if (isMethod(value)) {
              value = giveMethodSuper(base, key, value, values, descs);
            } else if (concats && a_indexOf.call(concats, key) >= 0 || key === 'concatenatedProperties') {
              value = applyConcatenatedProperties(base, key, value, values);
            }
            descs[key] = undefined;
            values[key] = value;
          }
        }
        function mergeMixins(mixins, m, descs, values, base, keys) {
          var mixin, props, key, concats, meta;
          function removeKeys(keyName) {
            delete descs[keyName];
            delete values[keyName];
          }
          for (var i = 0, l = mixins.length; i < l; i++) {
            mixin = mixins[i];
            Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');
            props = mixinProperties(m, mixin);
            if (props === CONTINUE) {
              continue;
            }
            if (props) {
              meta = Ember.meta(base);
              concats = concatenatedProperties(props, values, base);
              for (key in props) {
                if (!props.hasOwnProperty(key)) {
                  continue;
                }
                keys.push(key);
                addNormalizedProperty(base, key, props[key], meta, descs, values, concats);
              }
              if (props.hasOwnProperty('toString')) {
                base.toString = props.toString;
              }
            } else if (mixin.mixins) {
              mergeMixins(mixin.mixins, m, descs, values, base, keys);
              if (mixin._without) {
                a_forEach.call(mixin._without, removeKeys);
              }
            }
          }
        }
        function writableReq(obj) {
          var m = Ember.meta(obj), req = m.required;
          if (!req || !m.hasOwnProperty('required')) {
            req = m.required = req ? o_create(req) : {};
          }
          return req;
        }
        var IS_BINDING = Ember.IS_BINDING = /^.+Binding$/;
        function detectBinding(obj, key, value, m) {
          if (IS_BINDING.test(key)) {
            var bindings = m.bindings;
            if (!bindings) {
              bindings = m.bindings = {};
            } else if (!m.hasOwnProperty('bindings')) {
              bindings = m.bindings = o_create(m.bindings);
            }
            bindings[key] = value;
          }
        }
        function connectBindings(obj, m) {
          var bindings = m.bindings, key, binding, to;
          if (bindings) {
            for (key in bindings) {
              binding = bindings[key];
              if (binding) {
                to = key.slice(0, -7);
                if (binding instanceof Ember.Binding) {
                  binding = binding.copy();
                  binding.to(to);
                } else {
                  binding = new Ember.Binding(to, binding);
                }
                binding.connect(obj);
                obj[key] = binding;
              }
            }
            m.bindings = {};
          }
        }
        function finishPartial(obj, m) {
          connectBindings(obj, m || Ember.meta(obj));
          return obj;
        }
        function followAlias(obj, desc, m, descs, values) {
          var altKey = desc.methodName, value;
          if (descs[altKey] || values[altKey]) {
            value = values[altKey];
            desc = descs[altKey];
          } else if (m.descs[altKey]) {
            desc = m.descs[altKey];
            value = undefined;
          } else {
            desc = undefined;
            value = obj[altKey];
          }
          return {
            desc: desc,
            value: value
          };
        }
        function updateObservers(obj, key, observer, observerKey, method) {
          if ('function' !== typeof observer) {
            return;
          }
          var paths = observer[observerKey];
          if (paths) {
            for (var i = 0, l = paths.length; i < l; i++) {
              Ember[method](obj, paths[i], null, key);
            }
          }
        }
        function replaceObservers(obj, key, observer) {
          var prevObserver = obj[key];
          updateObservers(obj, key, prevObserver, '__ember_observesBefore__', 'removeBeforeObserver');
          updateObservers(obj, key, prevObserver, '__ember_observes__', 'removeObserver');
          updateObservers(obj, key, observer, '__ember_observesBefore__', 'addBeforeObserver');
          updateObservers(obj, key, observer, '__ember_observes__', 'addObserver');
        }
        function applyMixin(obj, mixins, partial) {
          var descs = {}, values = {}, m = Ember.meta(obj), key, value, desc, keys = [];
          mergeMixins(mixins, mixinsMeta(obj), descs, values, obj, keys);
          for (var i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            if (key === 'constructor' || !values.hasOwnProperty(key)) {
              continue;
            }
            desc = descs[key];
            value = values[key];
            if (desc === REQUIRED) {
              continue;
            }
            while (desc && desc instanceof Alias) {
              var followed = followAlias(obj, desc, m, descs, values);
              desc = followed.desc;
              value = followed.value;
            }
            if (desc === undefined && value === undefined) {
              continue;
            }
            replaceObservers(obj, key, value);
            detectBinding(obj, key, value, m);
            defineProperty(obj, key, desc, value, m);
          }
          if (!partial) {
            finishPartial(obj, m);
          }
          return obj;
        }
        Ember.mixin = function (obj) {
          var args = a_slice.call(arguments, 1);
          applyMixin(obj, args, false);
          return obj;
        };
        Ember.Mixin = function () {
          return initMixin(this, arguments);
        };
        Mixin = Ember.Mixin;
        Mixin.prototype = {
          properties: null,
          mixins: null,
          ownerConstructor: null
        };
        Mixin._apply = applyMixin;
        Mixin.applyPartial = function (obj) {
          var args = a_slice.call(arguments, 1);
          return applyMixin(obj, args, true);
        };
        Mixin.finishPartial = finishPartial;
        Ember.anyUnprocessedMixins = false;
        Mixin.create = function () {
          Ember.anyUnprocessedMixins = true;
          var M = this;
          return initMixin(new M, arguments);
        };
        var MixinPrototype = Mixin.prototype;
        MixinPrototype.reopen = function () {
          var mixin, tmp;
          if (this.properties) {
            mixin = Mixin.create();
            mixin.properties = this.properties;
            delete this.properties;
            this.mixins = [mixin];
          } else if (!this.mixins) {
            this.mixins = [];
          }
          var len = arguments.length, mixins = this.mixins, idx;
          for (idx = 0; idx < len; idx++) {
            mixin = arguments[idx];
            Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');
            if (mixin instanceof Mixin) {
              mixins.push(mixin);
            } else {
              tmp = Mixin.create();
              tmp.properties = mixin;
              mixins.push(tmp);
            }
          }
          return this;
        };
        MixinPrototype.apply = function (obj) {
          return applyMixin(obj, [this], false);
        };
        MixinPrototype.applyPartial = function (obj) {
          return applyMixin(obj, [this], true);
        };
        function _detect(curMixin, targetMixin, seen) {
          var guid = guidFor(curMixin);
          if (seen[guid]) {
            return false;
          }
          seen[guid] = true;
          if (curMixin === targetMixin) {
            return true;
          }
          var mixins = curMixin.mixins, loc = mixins ? mixins.length : 0;
          while (--loc >= 0) {
            if (_detect(mixins[loc], targetMixin, seen)) {
              return true;
            }
          }
          return false;
        }
        MixinPrototype.detect = function (obj) {
          if (!obj) {
            return false;
          }
          if (obj instanceof Mixin) {
            return _detect(obj, this, {});
          }
          var mixins = Ember.meta(obj, false).mixins;
          if (mixins) {
            return !!mixins[guidFor(this)];
          }
          return false;
        };
        MixinPrototype.without = function () {
          var ret = new Mixin(this);
          ret._without = a_slice.call(arguments);
          return ret;
        };
        function _keys(ret, mixin, seen) {
          if (seen[guidFor(mixin)]) {
            return;
          }
          seen[guidFor(mixin)] = true;
          if (mixin.properties) {
            var props = mixin.properties;
            for (var key in props) {
              if (props.hasOwnProperty(key)) {
                ret[key] = true;
              }
            }
          } else if (mixin.mixins) {
            a_forEach.call(mixin.mixins, function (x) {
              _keys(ret, x, seen);
            });
          }
        }
        MixinPrototype.keys = function () {
          var keys = {}, seen = {}, ret = [];
          _keys(keys, this, seen);
          for (var key in keys) {
            if (keys.hasOwnProperty(key)) {
              ret.push(key);
            }
          }
          return ret;
        };
        Mixin.mixins = function (obj) {
          var mixins = Ember.meta(obj, false).mixins, ret = [];
          if (!mixins) {
            return ret;
          }
          for (var key in mixins) {
            var mixin = mixins[key];
            if (!mixin.properties) {
              ret.push(mixin);
            }
          }
          return ret;
        };
        REQUIRED = new Ember.Descriptor;
        REQUIRED.toString = function () {
          return '(Required Property)';
        };
        Ember.required = function () {
          return REQUIRED;
        };
        Alias = function (methodName) {
          this.methodName = methodName;
        };
        Alias.prototype = new Ember.Descriptor;
        Ember.alias = function (methodName) {
          return new Alias(methodName);
        };
        Ember.deprecateFunc('Ember.alias is deprecated. Please use Ember.aliasMethod or Ember.computed.alias instead.', Ember.alias);
        Ember.aliasMethod = function (methodName) {
          return new Alias(methodName);
        };
        Ember.observer = function (func) {
          var paths = a_slice.call(arguments, 1);
          func.__ember_observes__ = paths;
          return func;
        };
        Ember.immediateObserver = function () {
          for (var i = 0, l = arguments.length; i < l; i++) {
            var arg = arguments[i];
            Ember.assert('Immediate observers must observe internal properties only, not properties on other objects.', typeof arg !== 'string' || arg.indexOf('.') === -1);
          }
          return Ember.observer.apply(this, arguments);
        };
        Ember.beforeObserver = function (func) {
          var paths = a_slice.call(arguments, 1);
          func.__ember_observesBefore__ = paths;
          return func;
        };
      }());
      (function () {
      }());
      (function () {
        define('rsvp', [], function () {
          'use strict';
          var browserGlobal = typeof window !== 'undefined' ? window : {};
          var MutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
          var RSVP, async;
          if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            async = function (callback, binding) {
              process.nextTick(function () {
                callback.call(binding);
              });
            };
          } else if (MutationObserver) {
            var queue = [];
            var observer = new MutationObserver(function () {
                var toProcess = queue.slice();
                queue = [];
                toProcess.forEach(function (tuple) {
                  var callback = tuple[0], binding = tuple[1];
                  callback.call(binding);
                });
              });
            var element = document.createElement('div');
            observer.observe(element, { attributes: true });
            window.addEventListener('unload', function () {
              observer.disconnect();
              observer = null;
            });
            async = function (callback, binding) {
              queue.push([
                callback,
                binding
              ]);
              element.setAttribute('drainQueue', 'drainQueue');
            };
          } else {
            async = function (callback, binding) {
              setTimeout(function () {
                callback.call(binding);
              }, 1);
            };
          }
          var Event = function (type, options) {
            this.type = type;
            for (var option in options) {
              if (!options.hasOwnProperty(option)) {
                continue;
              }
              this[option] = options[option];
            }
          };
          var indexOf = function (callbacks, callback) {
            for (var i = 0, l = callbacks.length; i < l; i++) {
              if (callbacks[i][0] === callback) {
                return i;
              }
            }
            return -1;
          };
          var callbacksFor = function (object) {
            var callbacks = object._promiseCallbacks;
            if (!callbacks) {
              callbacks = object._promiseCallbacks = {};
            }
            return callbacks;
          };
          var EventTarget = {
              mixin: function (object) {
                object.on = this.on;
                object.off = this.off;
                object.trigger = this.trigger;
                return object;
              },
              on: function (eventNames, callback, binding) {
                var allCallbacks = callbacksFor(this), callbacks, eventName;
                eventNames = eventNames.split(/\s+/);
                binding = binding || this;
                while (eventName = eventNames.shift()) {
                  callbacks = allCallbacks[eventName];
                  if (!callbacks) {
                    callbacks = allCallbacks[eventName] = [];
                  }
                  if (indexOf(callbacks, callback) === -1) {
                    callbacks.push([
                      callback,
                      binding
                    ]);
                  }
                }
              },
              off: function (eventNames, callback) {
                var allCallbacks = callbacksFor(this), callbacks, eventName, index;
                eventNames = eventNames.split(/\s+/);
                while (eventName = eventNames.shift()) {
                  if (!callback) {
                    allCallbacks[eventName] = [];
                    continue;
                  }
                  callbacks = allCallbacks[eventName];
                  index = indexOf(callbacks, callback);
                  if (index !== -1) {
                    callbacks.splice(index, 1);
                  }
                }
              },
              trigger: function (eventName, options) {
                var allCallbacks = callbacksFor(this), callbacks, callbackTuple, callback, binding, event;
                if (callbacks = allCallbacks[eventName]) {
                  for (var i = 0; i < callbacks.length; i++) {
                    callbackTuple = callbacks[i];
                    callback = callbackTuple[0];
                    binding = callbackTuple[1];
                    if (typeof options !== 'object') {
                      options = { detail: options };
                    }
                    event = new Event(eventName, options);
                    callback.call(binding, event);
                  }
                }
              }
            };
          var Promise = function () {
            this.on('promise:resolved', function (event) {
              this.trigger('success', { detail: event.detail });
            }, this);
            this.on('promise:failed', function (event) {
              this.trigger('error', { detail: event.detail });
            }, this);
          };
          var noop = function () {
          };
          var invokeCallback = function (type, promise, callback, event) {
            var hasCallback = typeof callback === 'function', value, error, succeeded, failed;
            if (hasCallback) {
              try {
                value = callback(event.detail);
                succeeded = true;
              } catch (e) {
                failed = true;
                error = e;
              }
            } else {
              value = event.detail;
              succeeded = true;
            }
            if (value && typeof value.then === 'function') {
              value.then(function (value) {
                promise.resolve(value);
              }, function (error) {
                promise.reject(error);
              });
            } else if (hasCallback && succeeded) {
              promise.resolve(value);
            } else if (failed) {
              promise.reject(error);
            } else {
              promise[type](value);
            }
          };
          Promise.prototype = {
            then: function (done, fail) {
              var thenPromise = new Promise;
              if (this.isResolved) {
                RSVP.async(function () {
                  invokeCallback('resolve', thenPromise, done, { detail: this.resolvedValue });
                }, this);
              }
              if (this.isRejected) {
                RSVP.async(function () {
                  invokeCallback('reject', thenPromise, fail, { detail: this.rejectedValue });
                }, this);
              }
              this.on('promise:resolved', function (event) {
                invokeCallback('resolve', thenPromise, done, event);
              });
              this.on('promise:failed', function (event) {
                invokeCallback('reject', thenPromise, fail, event);
              });
              return thenPromise;
            },
            resolve: function (value) {
              resolve(this, value);
              this.resolve = noop;
              this.reject = noop;
            },
            reject: function (value) {
              reject(this, value);
              this.resolve = noop;
              this.reject = noop;
            }
          };
          function resolve(promise, value) {
            RSVP.async(function () {
              promise.trigger('promise:resolved', { detail: value });
              promise.isResolved = true;
              promise.resolvedValue = value;
            });
          }
          function reject(promise, value) {
            RSVP.async(function () {
              promise.trigger('promise:failed', { detail: value });
              promise.isRejected = true;
              promise.rejectedValue = value;
            });
          }
          function all(promises) {
            var i, results = [];
            var allPromise = new Promise;
            var remaining = promises.length;
            if (remaining === 0) {
              allPromise.resolve([]);
            }
            var resolver = function (index) {
              return function (value) {
                resolve(index, value);
              };
            };
            var resolve = function (index, value) {
              results[index] = value;
              if (--remaining === 0) {
                allPromise.resolve(results);
              }
            };
            var reject = function (error) {
              allPromise.reject(error);
            };
            for (i = 0; i < remaining; i++) {
              promises[i].then(resolver(i), reject);
            }
            return allPromise;
          }
          EventTarget.mixin(Promise.prototype);
          RSVP = {
            async: async,
            Promise: Promise,
            Event: Event,
            EventTarget: EventTarget,
            all: all,
            raiseOnUncaughtExceptions: true
          };
          return RSVP;
        });
      }());
      (function () {
        define('container', [], function () {
          function InheritingDict(parent) {
            this.parent = parent;
            this.dict = {};
          }
          InheritingDict.prototype = {
            get: function (key) {
              var dict = this.dict;
              if (dict.hasOwnProperty(key)) {
                return dict[key];
              }
              if (this.parent) {
                return this.parent.get(key);
              }
            },
            set: function (key, value) {
              this.dict[key] = value;
            },
            has: function (key) {
              var dict = this.dict;
              if (dict.hasOwnProperty(key)) {
                return true;
              }
              if (this.parent) {
                return this.parent.has(key);
              }
              return false;
            },
            eachLocal: function (callback, binding) {
              var dict = this.dict;
              for (var prop in dict) {
                if (dict.hasOwnProperty(prop)) {
                  callback.call(binding, prop, dict[prop]);
                }
              }
            }
          };
          function Container(parent) {
            this.parent = parent;
            this.children = [];
            this.resolver = parent && parent.resolver || function () {
            };
            this.registry = new InheritingDict(parent && parent.registry);
            this.cache = new InheritingDict(parent && parent.cache);
            this.typeInjections = new InheritingDict(parent && parent.typeInjections);
            this.injections = {};
            this._options = new InheritingDict(parent && parent._options);
            this._typeOptions = new InheritingDict(parent && parent._typeOptions);
          }
          Container.prototype = {
            child: function () {
              var container = new Container(this);
              this.children.push(container);
              return container;
            },
            set: function (object, key, value) {
              object[key] = value;
            },
            register: function (type, name, factory, options) {
              var fullName;
              if (type.indexOf(':') !== -1) {
                options = factory;
                factory = name;
                fullName = type;
              } else {
                Ember.deprecate('register("' + type + '", "' + name + '") is now deprecated in-favour of register("' + type + ':' + name + '");', false);
                fullName = type + ':' + name;
              }
              var normalizedName = this.normalize(fullName);
              this.registry.set(normalizedName, factory);
              this._options.set(normalizedName, options || {});
            },
            resolve: function (fullName) {
              return this.resolver(fullName) || this.registry.get(fullName);
            },
            normalize: function (fullName) {
              return fullName;
            },
            lookup: function (fullName, options) {
              fullName = this.normalize(fullName);
              options = options || {};
              if (this.cache.has(fullName) && options.singleton !== false) {
                return this.cache.get(fullName);
              }
              var value = instantiate(this, fullName);
              if (!value) {
                return;
              }
              if (isSingleton(this, fullName) && options.singleton !== false) {
                this.cache.set(fullName, value);
              }
              return value;
            },
            has: function (fullName) {
              if (this.cache.has(fullName)) {
                return true;
              }
              return !!factoryFor(this, fullName);
            },
            optionsForType: function (type, options) {
              if (this.parent) {
                illegalChildOperation('optionsForType');
              }
              this._typeOptions.set(type, options);
            },
            options: function (type, options) {
              this.optionsForType(type, options);
            },
            typeInjection: function (type, property, fullName) {
              if (this.parent) {
                illegalChildOperation('typeInjection');
              }
              var injections = this.typeInjections.get(type);
              if (!injections) {
                injections = [];
                this.typeInjections.set(type, injections);
              }
              injections.push({
                property: property,
                fullName: fullName
              });
            },
            injection: function (factoryName, property, injectionName) {
              if (this.parent) {
                illegalChildOperation('injection');
              }
              if (factoryName.indexOf(':') === -1) {
                return this.typeInjection(factoryName, property, injectionName);
              }
              var injections = this.injections[factoryName] = this.injections[factoryName] || [];
              injections.push({
                property: property,
                fullName: injectionName
              });
            },
            destroy: function () {
              this.isDestroyed = true;
              for (var i = 0, l = this.children.length; i < l; i++) {
                this.children[i].destroy();
              }
              this.children = [];
              eachDestroyable(this, function (item) {
                item.isDestroying = true;
              });
              eachDestroyable(this, function (item) {
                item.destroy();
              });
              delete this.parent;
              this.isDestroyed = true;
            },
            reset: function () {
              for (var i = 0, l = this.children.length; i < l; i++) {
                resetCache(this.children[i]);
              }
              resetCache(this);
            }
          };
          function illegalChildOperation(operation) {
            throw new Error(operation + ' is not currently supported on child containers');
          }
          function isSingleton(container, fullName) {
            var singleton = option(container, fullName, 'singleton');
            return singleton !== false;
          }
          function buildInjections(container, injections) {
            var hash = {};
            if (!injections) {
              return hash;
            }
            var injection, lookup;
            for (var i = 0, l = injections.length; i < l; i++) {
              injection = injections[i];
              lookup = container.lookup(injection.fullName);
              hash[injection.property] = lookup;
            }
            return hash;
          }
          function option(container, fullName, optionName) {
            var options = container._options.get(fullName);
            if (options && options[optionName] !== undefined) {
              return options[optionName];
            }
            var type = fullName.split(':')[0];
            options = container._typeOptions.get(type);
            if (options) {
              return options[optionName];
            }
          }
          function factoryFor(container, fullName) {
            var name = container.normalize(fullName);
            return container.resolve(name);
          }
          function instantiate(container, fullName) {
            var factory = factoryFor(container, fullName);
            var splitName = fullName.split(':'), type = splitName[0], name = splitName[1], value;
            if (option(container, fullName, 'instantiate') === false) {
              return factory;
            }
            if (factory) {
              var injections = [];
              injections = injections.concat(container.typeInjections.get(type) || []);
              injections = injections.concat(container.injections[fullName] || []);
              var hash = buildInjections(container, injections);
              hash.container = container;
              hash._debugContainerKey = fullName;
              value = factory.create(hash);
              return value;
            }
          }
          function eachDestroyable(container, callback) {
            container.cache.eachLocal(function (key, value) {
              if (option(container, key, 'instantiate') === false) {
                return;
              }
              callback(value);
            });
          }
          function resetCache(container) {
            container.cache.eachLocal(function (key, value) {
              if (option(container, key, 'instantiate') === false) {
                return;
              }
              value.destroy();
            });
            container.cache.dict = {};
          }
          return Container;
        });
      }());
      (function () {
        var indexOf = Ember.EnumerableUtils.indexOf;
        var TYPE_MAP = {};
        var t = 'Boolean Number String Function Array Date RegExp Object'.split(' ');
        Ember.ArrayPolyfills.forEach.call(t, function (name) {
          TYPE_MAP['[object ' + name + ']'] = name.toLowerCase();
        });
        var toString = Object.prototype.toString;
        Ember.typeOf = function (item) {
          var ret;
          ret = item === null || item === undefined ? String(item) : TYPE_MAP[toString.call(item)] || 'object';
          if (ret === 'function') {
            if (Ember.Object && Ember.Object.detect(item))
              ret = 'class';
          } else if (ret === 'object') {
            if (item instanceof Error)
              ret = 'error';
            else if (Ember.Object && item instanceof Ember.Object)
              ret = 'instance';
            else
              ret = 'object';
          }
          return ret;
        };
        Ember.compare = function compare(v, w) {
          if (v === w) {
            return 0;
          }
          var type1 = Ember.typeOf(v);
          var type2 = Ember.typeOf(w);
          var Comparable = Ember.Comparable;
          if (Comparable) {
            if (type1 === 'instance' && Comparable.detect(v.constructor)) {
              return v.constructor.compare(v, w);
            }
            if (type2 === 'instance' && Comparable.detect(w.constructor)) {
              return 1 - w.constructor.compare(w, v);
            }
          }
          var mapping = Ember.ORDER_DEFINITION_MAPPING;
          if (!mapping) {
            var order = Ember.ORDER_DEFINITION;
            mapping = Ember.ORDER_DEFINITION_MAPPING = {};
            var idx, len;
            for (idx = 0, len = order.length; idx < len; ++idx) {
              mapping[order[idx]] = idx;
            }
            delete Ember.ORDER_DEFINITION;
          }
          var type1Index = mapping[type1];
          var type2Index = mapping[type2];
          if (type1Index < type2Index) {
            return -1;
          }
          if (type1Index > type2Index) {
            return 1;
          }
          switch (type1) {
          case 'boolean':
          case 'number':
            if (v < w) {
              return -1;
            }
            if (v > w) {
              return 1;
            }
            return 0;
          case 'string':
            var comp = v.localeCompare(w);
            if (comp < 0) {
              return -1;
            }
            if (comp > 0) {
              return 1;
            }
            return 0;
          case 'array':
            var vLen = v.length;
            var wLen = w.length;
            var l = Math.min(vLen, wLen);
            var r = 0;
            var i = 0;
            while (r === 0 && i < l) {
              r = compare(v[i], w[i]);
              i++;
            }
            if (r !== 0) {
              return r;
            }
            if (vLen < wLen) {
              return -1;
            }
            if (vLen > wLen) {
              return 1;
            }
            return 0;
          case 'instance':
            if (Ember.Comparable && Ember.Comparable.detect(v)) {
              return v.compare(v, w);
            }
            return 0;
          case 'date':
            var vNum = v.getTime();
            var wNum = w.getTime();
            if (vNum < wNum) {
              return -1;
            }
            if (vNum > wNum) {
              return 1;
            }
            return 0;
          default:
            return 0;
          }
        };
        function _copy(obj, deep, seen, copies) {
          var ret, loc, key;
          if ('object' !== typeof obj || obj === null)
            return obj;
          if (deep && (loc = indexOf(seen, obj)) >= 0)
            return copies[loc];
          Ember.assert('Cannot clone an Ember.Object that does not implement Ember.Copyable', !(obj instanceof Ember.Object) || Ember.Copyable && Ember.Copyable.detect(obj));
          if (Ember.typeOf(obj) === 'array') {
            ret = obj.slice();
            if (deep) {
              loc = ret.length;
              while (--loc >= 0)
                ret[loc] = _copy(ret[loc], deep, seen, copies);
            }
          } else if (Ember.Copyable && Ember.Copyable.detect(obj)) {
            ret = obj.copy(deep, seen, copies);
          } else {
            ret = {};
            for (key in obj) {
              if (!obj.hasOwnProperty(key))
                continue;
              if (key.substring(0, 2) === '__')
                continue;
              ret[key] = deep ? _copy(obj[key], deep, seen, copies) : obj[key];
            }
          }
          if (deep) {
            seen.push(obj);
            copies.push(ret);
          }
          return ret;
        }
        Ember.copy = function (obj, deep) {
          if ('object' !== typeof obj || obj === null)
            return obj;
          if (Ember.Copyable && Ember.Copyable.detect(obj))
            return obj.copy(deep);
          return _copy(obj, deep, deep ? [] : null, deep ? [] : null);
        };
        Ember.inspect = function (obj) {
          if (typeof obj !== 'object' || obj === null) {
            return obj + '';
          }
          var v, ret = [];
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              v = obj[key];
              if (v === 'toString') {
                continue;
              }
              if (Ember.typeOf(v) === 'function') {
                v = 'function() { ... }';
              }
              ret.push(key + ': ' + v);
            }
          }
          return '{' + ret.join(', ') + '}';
        };
        Ember.isEqual = function (a, b) {
          if (a && 'function' === typeof a.isEqual)
            return a.isEqual(b);
          return a === b;
        };
        Ember.ORDER_DEFINITION = Ember.ENV.ORDER_DEFINITION || [
          'undefined',
          'null',
          'boolean',
          'number',
          'string',
          'array',
          'object',
          'instance',
          'function',
          'class',
          'date'
        ];
        Ember.keys = Object.keys;
        if (!Ember.keys) {
          Ember.keys = function (obj) {
            var ret = [];
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) {
                ret.push(key);
              }
            }
            return ret;
          };
        }
        var errorProps = [
            'description',
            'fileName',
            'lineNumber',
            'message',
            'name',
            'number',
            'stack'
          ];
        Ember.Error = function () {
          var tmp = Error.prototype.constructor.apply(this, arguments);
          for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]];
          }
        };
        Ember.Error.prototype = Ember.create(Error.prototype);
      }());
      (function () {
        Ember.RSVP = requireModule('rsvp');
      }());
      (function () {
        var STRING_DASHERIZE_REGEXP = /[ _]/g;
        var STRING_DASHERIZE_CACHE = {};
        var STRING_DECAMELIZE_REGEXP = /([a-z])([A-Z])/g;
        var STRING_CAMELIZE_REGEXP = /(\-|_|\.|\s)+(.)?/g;
        var STRING_UNDERSCORE_REGEXP_1 = /([a-z\d])([A-Z]+)/g;
        var STRING_UNDERSCORE_REGEXP_2 = /\-|\s+/g;
        Ember.STRINGS = {};
        Ember.String = {
          fmt: function (str, formats) {
            var idx = 0;
            return str.replace(/%@([0-9]+)?/g, function (s, argIndex) {
              argIndex = argIndex ? parseInt(argIndex, 0) - 1 : idx++;
              s = formats[argIndex];
              return (s === null ? '(null)' : s === undefined ? '' : s).toString();
            });
          },
          loc: function (str, formats) {
            str = Ember.STRINGS[str] || str;
            return Ember.String.fmt(str, formats);
          },
          w: function (str) {
            return str.split(/\s+/);
          },
          decamelize: function (str) {
            return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();
          },
          dasherize: function (str) {
            var cache = STRING_DASHERIZE_CACHE, hit = cache.hasOwnProperty(str), ret;
            if (hit) {
              return cache[str];
            } else {
              ret = Ember.String.decamelize(str).replace(STRING_DASHERIZE_REGEXP, '-');
              cache[str] = ret;
            }
            return ret;
          },
          camelize: function (str) {
            return str.replace(STRING_CAMELIZE_REGEXP, function (match, separator, chr) {
              return chr ? chr.toUpperCase() : '';
            }).replace(/^([A-Z])/, function (match, separator, chr) {
              return match.toLowerCase();
            });
          },
          classify: function (str) {
            var parts = str.split('.'), out = [];
            for (var i = 0, l = parts.length; i < l; i++) {
              var camelized = Ember.String.camelize(parts[i]);
              out.push(camelized.charAt(0).toUpperCase() + camelized.substr(1));
            }
            return out.join('.');
          },
          underscore: function (str) {
            return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();
          },
          capitalize: function (str) {
            return str.charAt(0).toUpperCase() + str.substr(1);
          }
        };
      }());
      (function () {
        var fmt = Ember.String.fmt, w = Ember.String.w, loc = Ember.String.loc, camelize = Ember.String.camelize, decamelize = Ember.String.decamelize, dasherize = Ember.String.dasherize, underscore = Ember.String.underscore, capitalize = Ember.String.capitalize, classify = Ember.String.classify;
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.String) {
          String.prototype.fmt = function () {
            return fmt(this, arguments);
          };
          String.prototype.w = function () {
            return w(this);
          };
          String.prototype.loc = function () {
            return loc(this, arguments);
          };
          String.prototype.camelize = function () {
            return camelize(this);
          };
          String.prototype.decamelize = function () {
            return decamelize(this);
          };
          String.prototype.dasherize = function () {
            return dasherize(this);
          };
          String.prototype.underscore = function () {
            return underscore(this);
          };
          String.prototype.classify = function () {
            return classify(this);
          };
          String.prototype.capitalize = function () {
            return capitalize(this);
          };
        }
      }());
      (function () {
        var a_slice = Array.prototype.slice;
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Function) {
          Function.prototype.property = function () {
            var ret = Ember.computed(this);
            return ret.property.apply(ret, arguments);
          };
          Function.prototype.observes = function () {
            this.__ember_observes__ = a_slice.call(arguments);
            return this;
          };
          Function.prototype.observesBefore = function () {
            this.__ember_observesBefore__ = a_slice.call(arguments);
            return this;
          };
        }
      }());
      (function () {
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        var a_slice = Array.prototype.slice;
        var a_indexOf = Ember.EnumerableUtils.indexOf;
        var contexts = [];
        function popCtx() {
          return contexts.length === 0 ? {} : contexts.pop();
        }
        function pushCtx(ctx) {
          contexts.push(ctx);
          return null;
        }
        function iter(key, value) {
          var valueProvided = arguments.length === 2;
          function i(item) {
            var cur = get(item, key);
            return valueProvided ? value === cur : !!cur;
          }
          return i;
        }
        Ember.Enumerable = Ember.Mixin.create({
          isEnumerable: true,
          nextObject: Ember.required(Function),
          firstObject: Ember.computed(function () {
            if (get(this, 'length') === 0)
              return undefined;
            var context = popCtx(), ret;
            ret = this.nextObject(0, null, context);
            pushCtx(context);
            return ret;
          }).property('[]'),
          lastObject: Ember.computed(function () {
            var len = get(this, 'length');
            if (len === 0)
              return undefined;
            var context = popCtx(), idx = 0, cur, last = null;
            do {
              last = cur;
              cur = this.nextObject(idx++, last, context);
            } while (cur !== undefined);
            pushCtx(context);
            return last;
          }).property('[]'),
          contains: function (obj) {
            return this.find(function (item) {
              return item === obj;
            }) !== undefined;
          },
          forEach: function (callback, target) {
            if (typeof callback !== 'function')
              throw new TypeError;
            var len = get(this, 'length'), last = null, context = popCtx();
            if (target === undefined)
              target = null;
            for (var idx = 0; idx < len; idx++) {
              var next = this.nextObject(idx, last, context);
              callback.call(target, next, idx, this);
              last = next;
            }
            last = null;
            context = pushCtx(context);
            return this;
          },
          getEach: function (key) {
            return this.mapProperty(key);
          },
          setEach: function (key, value) {
            return this.forEach(function (item) {
              set(item, key, value);
            });
          },
          map: function (callback, target) {
            var ret = Ember.A([]);
            this.forEach(function (x, idx, i) {
              ret[idx] = callback.call(target, x, idx, i);
            });
            return ret;
          },
          mapProperty: function (key) {
            return this.map(function (next) {
              return get(next, key);
            });
          },
          filter: function (callback, target) {
            var ret = Ember.A([]);
            this.forEach(function (x, idx, i) {
              if (callback.call(target, x, idx, i))
                ret.push(x);
            });
            return ret;
          },
          reject: function (callback, target) {
            return this.filter(function () {
              return !callback.apply(target, arguments);
            });
          },
          filterProperty: function (key, value) {
            return this.filter(iter.apply(this, arguments));
          },
          rejectProperty: function (key, value) {
            var exactValue = function (item) {
                return get(item, key) === value;
              }, hasValue = function (item) {
                return !!get(item, key);
              }, use = arguments.length === 2 ? exactValue : hasValue;
            return this.reject(use);
          },
          find: function (callback, target) {
            var len = get(this, 'length');
            if (target === undefined)
              target = null;
            var last = null, next, found = false, ret;
            var context = popCtx();
            for (var idx = 0; idx < len && !found; idx++) {
              next = this.nextObject(idx, last, context);
              if (found = callback.call(target, next, idx, this))
                ret = next;
              last = next;
            }
            next = last = null;
            context = pushCtx(context);
            return ret;
          },
          findProperty: function (key, value) {
            return this.find(iter.apply(this, arguments));
          },
          every: function (callback, target) {
            return !this.find(function (x, idx, i) {
              return !callback.call(target, x, idx, i);
            });
          },
          everyProperty: function (key, value) {
            return this.every(iter.apply(this, arguments));
          },
          some: function (callback, target) {
            return !!this.find(function (x, idx, i) {
              return !!callback.call(target, x, idx, i);
            });
          },
          someProperty: function (key, value) {
            return this.some(iter.apply(this, arguments));
          },
          reduce: function (callback, initialValue, reducerProperty) {
            if (typeof callback !== 'function') {
              throw new TypeError;
            }
            var ret = initialValue;
            this.forEach(function (item, i) {
              ret = callback.call(null, ret, item, i, this, reducerProperty);
            }, this);
            return ret;
          },
          invoke: function (methodName) {
            var args, ret = Ember.A([]);
            if (arguments.length > 1)
              args = a_slice.call(arguments, 1);
            this.forEach(function (x, idx) {
              var method = x && x[methodName];
              if ('function' === typeof method) {
                ret[idx] = args ? method.apply(x, args) : method.call(x);
              }
            }, this);
            return ret;
          },
          toArray: function () {
            var ret = Ember.A([]);
            this.forEach(function (o, idx) {
              ret[idx] = o;
            });
            return ret;
          },
          compact: function () {
            return this.filter(function (value) {
              return value != null;
            });
          },
          without: function (value) {
            if (!this.contains(value))
              return this;
            var ret = Ember.A([]);
            this.forEach(function (k) {
              if (k !== value)
                ret[ret.length] = k;
            });
            return ret;
          },
          uniq: function () {
            var ret = Ember.A([]);
            this.forEach(function (k) {
              if (a_indexOf(ret, k) < 0)
                ret.push(k);
            });
            return ret;
          },
          '[]': Ember.computed(function (key, value) {
            return this;
          }),
          addEnumerableObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'enumerableWillChange', didChange = opts && opts.didChange || 'enumerableDidChange';
            var hasObservers = get(this, 'hasEnumerableObservers');
            if (!hasObservers)
              Ember.propertyWillChange(this, 'hasEnumerableObservers');
            Ember.addListener(this, '@enumerable:before', target, willChange);
            Ember.addListener(this, '@enumerable:change', target, didChange);
            if (!hasObservers)
              Ember.propertyDidChange(this, 'hasEnumerableObservers');
            return this;
          },
          removeEnumerableObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'enumerableWillChange', didChange = opts && opts.didChange || 'enumerableDidChange';
            var hasObservers = get(this, 'hasEnumerableObservers');
            if (hasObservers)
              Ember.propertyWillChange(this, 'hasEnumerableObservers');
            Ember.removeListener(this, '@enumerable:before', target, willChange);
            Ember.removeListener(this, '@enumerable:change', target, didChange);
            if (hasObservers)
              Ember.propertyDidChange(this, 'hasEnumerableObservers');
            return this;
          },
          hasEnumerableObservers: Ember.computed(function () {
            return Ember.hasListeners(this, '@enumerable:change') || Ember.hasListeners(this, '@enumerable:before');
          }),
          enumerableContentWillChange: function (removing, adding) {
            var removeCnt, addCnt, hasDelta;
            if ('number' === typeof removing)
              removeCnt = removing;
            else if (removing)
              removeCnt = get(removing, 'length');
            else
              removeCnt = removing = -1;
            if ('number' === typeof adding)
              addCnt = adding;
            else if (adding)
              addCnt = get(adding, 'length');
            else
              addCnt = adding = -1;
            hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
            if (removing === -1)
              removing = null;
            if (adding === -1)
              adding = null;
            Ember.propertyWillChange(this, '[]');
            if (hasDelta)
              Ember.propertyWillChange(this, 'length');
            Ember.sendEvent(this, '@enumerable:before', [
              this,
              removing,
              adding
            ]);
            return this;
          },
          enumerableContentDidChange: function (removing, adding) {
            var removeCnt, addCnt, hasDelta;
            if ('number' === typeof removing)
              removeCnt = removing;
            else if (removing)
              removeCnt = get(removing, 'length');
            else
              removeCnt = removing = -1;
            if ('number' === typeof adding)
              addCnt = adding;
            else if (adding)
              addCnt = get(adding, 'length');
            else
              addCnt = adding = -1;
            hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
            if (removing === -1)
              removing = null;
            if (adding === -1)
              adding = null;
            Ember.sendEvent(this, '@enumerable:change', [
              this,
              removing,
              adding
            ]);
            if (hasDelta)
              Ember.propertyDidChange(this, 'length');
            Ember.propertyDidChange(this, '[]');
            return this;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, map = Ember.EnumerableUtils.map, cacheFor = Ember.cacheFor;
        function none(obj) {
          return obj === null || obj === undefined;
        }
        Ember.Array = Ember.Mixin.create(Ember.Enumerable, {
          isSCArray: true,
          length: Ember.required(),
          objectAt: function (idx) {
            if (idx < 0 || idx >= get(this, 'length'))
              return undefined;
            return get(this, idx);
          },
          objectsAt: function (indexes) {
            var self = this;
            return map(indexes, function (idx) {
              return self.objectAt(idx);
            });
          },
          nextObject: function (idx) {
            return this.objectAt(idx);
          },
          '[]': Ember.computed(function (key, value) {
            if (value !== undefined)
              this.replace(0, get(this, 'length'), value);
            return this;
          }),
          firstObject: Ember.computed(function () {
            return this.objectAt(0);
          }),
          lastObject: Ember.computed(function () {
            return this.objectAt(get(this, 'length') - 1);
          }),
          contains: function (obj) {
            return this.indexOf(obj) >= 0;
          },
          slice: function (beginIndex, endIndex) {
            var ret = Ember.A([]);
            var length = get(this, 'length');
            if (none(beginIndex))
              beginIndex = 0;
            if (none(endIndex) || endIndex > length)
              endIndex = length;
            if (beginIndex < 0)
              beginIndex = length + beginIndex;
            if (endIndex < 0)
              endIndex = length + endIndex;
            while (beginIndex < endIndex) {
              ret[ret.length] = this.objectAt(beginIndex++);
            }
            return ret;
          },
          indexOf: function (object, startAt) {
            var idx, len = get(this, 'length');
            if (startAt === undefined)
              startAt = 0;
            if (startAt < 0)
              startAt += len;
            for (idx = startAt; idx < len; idx++) {
              if (this.objectAt(idx, true) === object)
                return idx;
            }
            return -1;
          },
          lastIndexOf: function (object, startAt) {
            var idx, len = get(this, 'length');
            if (startAt === undefined || startAt >= len)
              startAt = len - 1;
            if (startAt < 0)
              startAt += len;
            for (idx = startAt; idx >= 0; idx--) {
              if (this.objectAt(idx) === object)
                return idx;
            }
            return -1;
          },
          addArrayObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'arrayWillChange', didChange = opts && opts.didChange || 'arrayDidChange';
            var hasObservers = get(this, 'hasArrayObservers');
            if (!hasObservers)
              Ember.propertyWillChange(this, 'hasArrayObservers');
            Ember.addListener(this, '@array:before', target, willChange);
            Ember.addListener(this, '@array:change', target, didChange);
            if (!hasObservers)
              Ember.propertyDidChange(this, 'hasArrayObservers');
            return this;
          },
          removeArrayObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'arrayWillChange', didChange = opts && opts.didChange || 'arrayDidChange';
            var hasObservers = get(this, 'hasArrayObservers');
            if (hasObservers)
              Ember.propertyWillChange(this, 'hasArrayObservers');
            Ember.removeListener(this, '@array:before', target, willChange);
            Ember.removeListener(this, '@array:change', target, didChange);
            if (hasObservers)
              Ember.propertyDidChange(this, 'hasArrayObservers');
            return this;
          },
          hasArrayObservers: Ember.computed(function () {
            return Ember.hasListeners(this, '@array:change') || Ember.hasListeners(this, '@array:before');
          }),
          arrayContentWillChange: function (startIdx, removeAmt, addAmt) {
            if (startIdx === undefined) {
              startIdx = 0;
              removeAmt = addAmt = -1;
            } else {
              if (removeAmt === undefined)
                removeAmt = -1;
              if (addAmt === undefined)
                addAmt = -1;
            }
            if (Ember.isWatching(this, '@each')) {
              get(this, '@each');
            }
            Ember.sendEvent(this, '@array:before', [
              this,
              startIdx,
              removeAmt,
              addAmt
            ]);
            var removing, lim;
            if (startIdx >= 0 && removeAmt >= 0 && get(this, 'hasEnumerableObservers')) {
              removing = [];
              lim = startIdx + removeAmt;
              for (var idx = startIdx; idx < lim; idx++)
                removing.push(this.objectAt(idx));
            } else {
              removing = removeAmt;
            }
            this.enumerableContentWillChange(removing, addAmt);
            return this;
          },
          arrayContentDidChange: function (startIdx, removeAmt, addAmt) {
            if (startIdx === undefined) {
              startIdx = 0;
              removeAmt = addAmt = -1;
            } else {
              if (removeAmt === undefined)
                removeAmt = -1;
              if (addAmt === undefined)
                addAmt = -1;
            }
            var adding, lim;
            if (startIdx >= 0 && addAmt >= 0 && get(this, 'hasEnumerableObservers')) {
              adding = [];
              lim = startIdx + addAmt;
              for (var idx = startIdx; idx < lim; idx++)
                adding.push(this.objectAt(idx));
            } else {
              adding = addAmt;
            }
            this.enumerableContentDidChange(removeAmt, adding);
            Ember.sendEvent(this, '@array:change', [
              this,
              startIdx,
              removeAmt,
              addAmt
            ]);
            var length = get(this, 'length'), cachedFirst = cacheFor(this, 'firstObject'), cachedLast = cacheFor(this, 'lastObject');
            if (this.objectAt(0) !== cachedFirst) {
              Ember.propertyWillChange(this, 'firstObject');
              Ember.propertyDidChange(this, 'firstObject');
            }
            if (this.objectAt(length - 1) !== cachedLast) {
              Ember.propertyWillChange(this, 'lastObject');
              Ember.propertyDidChange(this, 'lastObject');
            }
            return this;
          },
          '@each': Ember.computed(function () {
            if (!this.__each)
              this.__each = new Ember.EachProxy(this);
            return this.__each;
          })
        });
      }());
      (function () {
        Ember.Comparable = Ember.Mixin.create({
          isComparable: true,
          compare: Ember.required(Function)
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Copyable = Ember.Mixin.create({
          copy: Ember.required(Function),
          frozenCopy: function () {
            if (Ember.Freezable && Ember.Freezable.detect(this)) {
              return get(this, 'isFrozen') ? this : this.copy().freeze();
            } else {
              throw new Error(Ember.String.fmt('%@ does not support freezing', [this]));
            }
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Freezable = Ember.Mixin.create({
          isFrozen: false,
          freeze: function () {
            if (get(this, 'isFrozen'))
              return this;
            set(this, 'isFrozen', true);
            return this;
          }
        });
        Ember.FROZEN_ERROR = 'Frozen object cannot be modified.';
      }());
      (function () {
        var forEach = Ember.EnumerableUtils.forEach;
        Ember.MutableEnumerable = Ember.Mixin.create(Ember.Enumerable, {
          addObject: Ember.required(Function),
          addObjects: function (objects) {
            Ember.beginPropertyChanges(this);
            forEach(objects, function (obj) {
              this.addObject(obj);
            }, this);
            Ember.endPropertyChanges(this);
            return this;
          },
          removeObject: Ember.required(Function),
          removeObjects: function (objects) {
            Ember.beginPropertyChanges(this);
            forEach(objects, function (obj) {
              this.removeObject(obj);
            }, this);
            Ember.endPropertyChanges(this);
            return this;
          }
        });
      }());
      (function () {
        var OUT_OF_RANGE_EXCEPTION = 'Index out of range';
        var EMPTY = [];
        var get = Ember.get, set = Ember.set;
        Ember.MutableArray = Ember.Mixin.create(Ember.Array, Ember.MutableEnumerable, {
          replace: Ember.required(),
          clear: function () {
            var len = get(this, 'length');
            if (len === 0)
              return this;
            this.replace(0, len, EMPTY);
            return this;
          },
          insertAt: function (idx, object) {
            if (idx > get(this, 'length'))
              throw new Error(OUT_OF_RANGE_EXCEPTION);
            this.replace(idx, 0, [object]);
            return this;
          },
          removeAt: function (start, len) {
            if ('number' === typeof start) {
              if (start < 0 || start >= get(this, 'length')) {
                throw new Error(OUT_OF_RANGE_EXCEPTION);
              }
              if (len === undefined)
                len = 1;
              this.replace(start, len, EMPTY);
            }
            return this;
          },
          pushObject: function (obj) {
            this.insertAt(get(this, 'length'), obj);
            return obj;
          },
          pushObjects: function (objects) {
            this.replace(get(this, 'length'), 0, objects);
            return this;
          },
          popObject: function () {
            var len = get(this, 'length');
            if (len === 0)
              return null;
            var ret = this.objectAt(len - 1);
            this.removeAt(len - 1, 1);
            return ret;
          },
          shiftObject: function () {
            if (get(this, 'length') === 0)
              return null;
            var ret = this.objectAt(0);
            this.removeAt(0);
            return ret;
          },
          unshiftObject: function (obj) {
            this.insertAt(0, obj);
            return obj;
          },
          unshiftObjects: function (objects) {
            this.replace(0, 0, objects);
            return this;
          },
          reverseObjects: function () {
            var len = get(this, 'length');
            if (len === 0)
              return this;
            var objects = this.toArray().reverse();
            this.replace(0, len, objects);
            return this;
          },
          setObjects: function (objects) {
            if (objects.length === 0)
              return this.clear();
            var len = get(this, 'length');
            this.replace(0, len, objects);
            return this;
          },
          removeObject: function (obj) {
            var loc = get(this, 'length') || 0;
            while (--loc >= 0) {
              var curObject = this.objectAt(loc);
              if (curObject === obj)
                this.removeAt(loc);
            }
            return this;
          },
          addObject: function (obj) {
            if (!this.contains(obj))
              this.pushObject(obj);
            return this;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Observable = Ember.Mixin.create({
          get: function (keyName) {
            return get(this, keyName);
          },
          getProperties: function () {
            var ret = {};
            var propertyNames = arguments;
            if (arguments.length === 1 && Ember.typeOf(arguments[0]) === 'array') {
              propertyNames = arguments[0];
            }
            for (var i = 0; i < propertyNames.length; i++) {
              ret[propertyNames[i]] = get(this, propertyNames[i]);
            }
            return ret;
          },
          set: function (keyName, value) {
            set(this, keyName, value);
            return this;
          },
          setProperties: function (hash) {
            return Ember.setProperties(this, hash);
          },
          beginPropertyChanges: function () {
            Ember.beginPropertyChanges();
            return this;
          },
          endPropertyChanges: function () {
            Ember.endPropertyChanges();
            return this;
          },
          propertyWillChange: function (keyName) {
            Ember.propertyWillChange(this, keyName);
            return this;
          },
          propertyDidChange: function (keyName) {
            Ember.propertyDidChange(this, keyName);
            return this;
          },
          notifyPropertyChange: function (keyName) {
            this.propertyWillChange(keyName);
            this.propertyDidChange(keyName);
            return this;
          },
          addBeforeObserver: function (key, target, method) {
            Ember.addBeforeObserver(this, key, target, method);
          },
          addObserver: function (key, target, method) {
            Ember.addObserver(this, key, target, method);
          },
          removeObserver: function (key, target, method) {
            Ember.removeObserver(this, key, target, method);
          },
          hasObserverFor: function (key) {
            return Ember.hasListeners(this, key + ':change');
          },
          getPath: function (path) {
            Ember.deprecate('getPath is deprecated since get now supports paths');
            return this.get(path);
          },
          setPath: function (path, value) {
            Ember.deprecate('setPath is deprecated since set now supports paths');
            return this.set(path, value);
          },
          getWithDefault: function (keyName, defaultValue) {
            return Ember.getWithDefault(this, keyName, defaultValue);
          },
          incrementProperty: function (keyName, increment) {
            if (!increment) {
              increment = 1;
            }
            set(this, keyName, (get(this, keyName) || 0) + increment);
            return get(this, keyName);
          },
          decrementProperty: function (keyName, increment) {
            if (!increment) {
              increment = 1;
            }
            set(this, keyName, (get(this, keyName) || 0) - increment);
            return get(this, keyName);
          },
          toggleProperty: function (keyName) {
            set(this, keyName, !get(this, keyName));
            return get(this, keyName);
          },
          cacheFor: function (keyName) {
            return Ember.cacheFor(this, keyName);
          },
          observersForKey: function (keyName) {
            return Ember.observersFor(this, keyName);
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.TargetActionSupport = Ember.Mixin.create({
          target: null,
          action: null,
          targetObject: Ember.computed(function () {
            var target = get(this, 'target');
            if (Ember.typeOf(target) === 'string') {
              var value = get(this, target);
              if (value === undefined) {
                value = get(Ember.lookup, target);
              }
              return value;
            } else {
              return target;
            }
          }).property('target'),
          triggerAction: function () {
            var action = get(this, 'action'), target = get(this, 'targetObject');
            if (target && action) {
              var ret;
              if (typeof target.send === 'function') {
                ret = target.send(action, this);
              } else {
                if (typeof action === 'string') {
                  action = target[action];
                }
                ret = action.call(target, this);
              }
              if (ret !== false)
                ret = true;
              return ret;
            } else {
              return false;
            }
          }
        });
      }());
      (function () {
        Ember.Evented = Ember.Mixin.create({
          on: function (name, target, method) {
            Ember.addListener(this, name, target, method);
            return this;
          },
          one: function (name, target, method) {
            if (!method) {
              method = target;
              target = null;
            }
            Ember.addListener(this, name, target, method, true);
            return this;
          },
          trigger: function (name) {
            var args = [], i, l;
            for (i = 1, l = arguments.length; i < l; i++) {
              args.push(arguments[i]);
            }
            Ember.sendEvent(this, name, args);
          },
          fire: function (name) {
            Ember.deprecate('Ember.Evented#fire() has been deprecated in favor of trigger() for compatibility with jQuery. It will be removed in 1.0. Please update your code to call trigger() instead.');
            this.trigger.apply(this, arguments);
          },
          off: function (name, target, method) {
            Ember.removeListener(this, name, target, method);
            return this;
          },
          has: function (name) {
            return Ember.hasListeners(this, name);
          }
        });
      }());
      (function () {
        var RSVP = requireModule('rsvp');
        RSVP.async = function (callback, binding) {
          Ember.run.schedule('actions', binding, callback);
        };
        var get = Ember.get;
        Ember.DeferredMixin = Ember.Mixin.create({
          then: function (doneCallback, failCallback) {
            var promise = get(this, 'promise');
            return promise.then.apply(promise, arguments);
          },
          resolve: function (value) {
            get(this, 'promise').resolve(value);
          },
          reject: function (value) {
            get(this, 'promise').reject(value);
          },
          promise: Ember.computed(function () {
            return new RSVP.Promise;
          })
        });
      }());
      (function () {
      }());
      (function () {
        Ember.Container = requireModule('container');
        Ember.Container.set = Ember.set;
      }());
      (function () {
        var set = Ember.set, get = Ember.get, o_create = Ember.create, o_defineProperty = Ember.platform.defineProperty, GUID_KEY = Ember.GUID_KEY, guidFor = Ember.guidFor, generateGuid = Ember.generateGuid, meta = Ember.meta, rewatch = Ember.rewatch, finishChains = Ember.finishChains, destroy = Ember.destroy, schedule = Ember.run.schedule, Mixin = Ember.Mixin, applyMixin = Mixin._apply, finishPartial = Mixin.finishPartial, reopen = Mixin.prototype.reopen, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, indexOf = Ember.EnumerableUtils.indexOf;
        var undefinedDescriptor = {
            configurable: true,
            writable: true,
            enumerable: false,
            value: undefined
          };
        function makeCtor() {
          var wasApplied = false, initMixins, initProperties;
          var Class = function () {
            if (!wasApplied) {
              Class.proto();
            }
            o_defineProperty(this, GUID_KEY, undefinedDescriptor);
            o_defineProperty(this, '_super', undefinedDescriptor);
            var m = meta(this);
            m.proto = this;
            if (initMixins) {
              var mixins = initMixins;
              initMixins = null;
              this.reopen.apply(this, mixins);
            }
            if (initProperties) {
              var props = initProperties;
              initProperties = null;
              var concatenatedProperties = this.concatenatedProperties;
              for (var i = 0, l = props.length; i < l; i++) {
                var properties = props[i];
                for (var keyName in properties) {
                  if (!properties.hasOwnProperty(keyName)) {
                    continue;
                  }
                  var value = properties[keyName], IS_BINDING = Ember.IS_BINDING;
                  if (IS_BINDING.test(keyName)) {
                    var bindings = m.bindings;
                    if (!bindings) {
                      bindings = m.bindings = {};
                    } else if (!m.hasOwnProperty('bindings')) {
                      bindings = m.bindings = o_create(m.bindings);
                    }
                    bindings[keyName] = value;
                  }
                  var desc = m.descs[keyName];
                  Ember.assert('Ember.Object.create no longer supports defining computed properties.', !(value instanceof Ember.ComputedProperty));
                  Ember.assert('Ember.Object.create no longer supports defining methods that call _super.', !(typeof value === 'function' && value.toString().indexOf('._super') !== -1));
                  if (concatenatedProperties && indexOf(concatenatedProperties, keyName) >= 0) {
                    var baseValue = this[keyName];
                    if (baseValue) {
                      if ('function' === typeof baseValue.concat) {
                        value = baseValue.concat(value);
                      } else {
                        value = Ember.makeArray(baseValue).concat(value);
                      }
                    } else {
                      value = Ember.makeArray(value);
                    }
                  }
                  if (desc) {
                    desc.set(this, keyName, value);
                  } else {
                    if (typeof this.setUnknownProperty === 'function' && !(keyName in this)) {
                      this.setUnknownProperty(keyName, value);
                    } else if (MANDATORY_SETTER) {
                      Ember.defineProperty(this, keyName, null, value);
                    } else {
                      this[keyName] = value;
                    }
                  }
                }
              }
            }
            finishPartial(this, m);
            delete m.proto;
            finishChains(this);
            this.init.apply(this, arguments);
          };
          Class.toString = Mixin.prototype.toString;
          Class.willReopen = function () {
            if (wasApplied) {
              Class.PrototypeMixin = Mixin.create(Class.PrototypeMixin);
            }
            wasApplied = false;
          };
          Class._initMixins = function (args) {
            initMixins = args;
          };
          Class._initProperties = function (args) {
            initProperties = args;
          };
          Class.proto = function () {
            var superclass = Class.superclass;
            if (superclass) {
              superclass.proto();
            }
            if (!wasApplied) {
              wasApplied = true;
              Class.PrototypeMixin.applyPartial(Class.prototype);
              rewatch(Class.prototype);
            }
            return this.prototype;
          };
          return Class;
        }
        var CoreObject = makeCtor();
        CoreObject.toString = function () {
          return 'Ember.CoreObject';
        };
        CoreObject.PrototypeMixin = Mixin.create({
          reopen: function () {
            applyMixin(this, arguments, true);
            return this;
          },
          isInstance: true,
          init: function () {
          },
          concatenatedProperties: null,
          isDestroyed: false,
          isDestroying: false,
          destroy: function () {
            if (this._didCallDestroy) {
              return;
            }
            this.isDestroying = true;
            this._didCallDestroy = true;
            schedule('destroy', this, this._scheduledDestroy);
            return this;
          },
          willDestroy: Ember.K,
          _scheduledDestroy: function () {
            if (this.willDestroy) {
              this.willDestroy();
            }
            destroy(this);
            this.isDestroyed = true;
            if (this.didDestroy) {
              this.didDestroy();
            }
          },
          bind: function (to, from) {
            if (!(from instanceof Ember.Binding)) {
              from = Ember.Binding.from(from);
            }
            from.to(to).connect(this);
            return from;
          },
          toString: function toString() {
            var hasToStringExtension = typeof this.toStringExtension === 'function', extension = hasToStringExtension ? ':' + this.toStringExtension() : '';
            var ret = '<' + this.constructor.toString() + ':' + guidFor(this) + extension + '>';
            this.toString = makeToString(ret);
            return ret;
          }
        });
        CoreObject.PrototypeMixin.ownerConstructor = CoreObject;
        function makeToString(ret) {
          return function () {
            return ret;
          };
        }
        if (Ember.config.overridePrototypeMixin) {
          Ember.config.overridePrototypeMixin(CoreObject.PrototypeMixin);
        }
        CoreObject.__super__ = null;
        var ClassMixin = Mixin.create({
            ClassMixin: Ember.required(),
            PrototypeMixin: Ember.required(),
            isClass: true,
            isMethod: false,
            extend: function () {
              var Class = makeCtor(), proto;
              Class.ClassMixin = Mixin.create(this.ClassMixin);
              Class.PrototypeMixin = Mixin.create(this.PrototypeMixin);
              Class.ClassMixin.ownerConstructor = Class;
              Class.PrototypeMixin.ownerConstructor = Class;
              reopen.apply(Class.PrototypeMixin, arguments);
              Class.superclass = this;
              Class.__super__ = this.prototype;
              proto = Class.prototype = o_create(this.prototype);
              proto.constructor = Class;
              generateGuid(proto, 'ember');
              meta(proto).proto = proto;
              Class.ClassMixin.apply(Class);
              return Class;
            },
            createWithMixins: function () {
              var C = this;
              if (arguments.length > 0) {
                this._initMixins(arguments);
              }
              return new C;
            },
            create: function () {
              var C = this;
              if (arguments.length > 0) {
                this._initProperties(arguments);
              }
              return new C;
            },
            reopen: function () {
              this.willReopen();
              reopen.apply(this.PrototypeMixin, arguments);
              return this;
            },
            reopenClass: function () {
              reopen.apply(this.ClassMixin, arguments);
              applyMixin(this, arguments, false);
              return this;
            },
            detect: function (obj) {
              if ('function' !== typeof obj) {
                return false;
              }
              while (obj) {
                if (obj === this) {
                  return true;
                }
                obj = obj.superclass;
              }
              return false;
            },
            detectInstance: function (obj) {
              return obj instanceof this;
            },
            metaForProperty: function (key) {
              var desc = meta(this.proto(), false).descs[key];
              Ember.assert("metaForProperty() could not find a computed property with key '" + key + "'.", !!desc && desc instanceof Ember.ComputedProperty);
              return desc._meta || {};
            },
            eachComputedProperty: function (callback, binding) {
              var proto = this.proto(), descs = meta(proto).descs, empty = {}, property;
              for (var name in descs) {
                property = descs[name];
                if (property instanceof Ember.ComputedProperty) {
                  callback.call(binding || this, name, property._meta || empty);
                }
              }
            }
          });
        ClassMixin.ownerConstructor = CoreObject;
        if (Ember.config.overrideClassMixin) {
          Ember.config.overrideClassMixin(ClassMixin);
        }
        CoreObject.ClassMixin = ClassMixin;
        ClassMixin.apply(CoreObject);
        Ember.CoreObject = CoreObject;
      }());
      (function () {
        Ember.Object = Ember.CoreObject.extend(Ember.Observable);
        Ember.Object.toString = function () {
          return 'Ember.Object';
        };
      }());
      (function () {
        var get = Ember.get, indexOf = Ember.ArrayPolyfills.indexOf;
        var Namespace = Ember.Namespace = Ember.Object.extend({
            isNamespace: true,
            init: function () {
              Ember.Namespace.NAMESPACES.push(this);
              Ember.Namespace.PROCESSED = false;
            },
            toString: function () {
              var name = get(this, 'name');
              if (name) {
                return name;
              }
              findNamespaces();
              return this[Ember.GUID_KEY + '_name'];
            },
            nameClasses: function () {
              processNamespace([this.toString()], this, {});
            },
            destroy: function () {
              var namespaces = Ember.Namespace.NAMESPACES;
              Ember.lookup[this.toString()] = undefined;
              namespaces.splice(indexOf.call(namespaces, this), 1);
              this._super();
            }
          });
        Namespace.reopenClass({
          NAMESPACES: [Ember],
          NAMESPACES_BY_ID: {},
          PROCESSED: false,
          processAll: processAllNamespaces,
          byName: function (name) {
            if (!Ember.BOOTED) {
              processAllNamespaces();
            }
            return NAMESPACES_BY_ID[name];
          }
        });
        var NAMESPACES_BY_ID = Namespace.NAMESPACES_BY_ID;
        var hasOwnProp = {}.hasOwnProperty, guidFor = Ember.guidFor;
        function processNamespace(paths, root, seen) {
          var idx = paths.length;
          NAMESPACES_BY_ID[paths.join('.')] = root;
          for (var key in root) {
            if (!hasOwnProp.call(root, key)) {
              continue;
            }
            var obj = root[key];
            paths[idx] = key;
            if (obj && obj.toString === classToString) {
              obj.toString = makeToString(paths.join('.'));
              obj[NAME_KEY] = paths.join('.');
            } else if (obj && obj.isNamespace) {
              if (seen[guidFor(obj)]) {
                continue;
              }
              seen[guidFor(obj)] = true;
              processNamespace(paths, obj, seen);
            }
          }
          paths.length = idx;
        }
        function findNamespaces() {
          var Namespace = Ember.Namespace, lookup = Ember.lookup, obj, isNamespace;
          if (Namespace.PROCESSED) {
            return;
          }
          for (var prop in lookup) {
            if (prop === 'parent' || prop === 'top' || prop === 'frameElement') {
              continue;
            }
            if (prop === 'globalStorage' && lookup.StorageList && lookup.globalStorage instanceof lookup.StorageList) {
              continue;
            }
            if (lookup.hasOwnProperty && !lookup.hasOwnProperty(prop)) {
              continue;
            }
            try {
              obj = Ember.lookup[prop];
              isNamespace = obj && obj.isNamespace;
            } catch (e) {
              continue;
            }
            if (isNamespace) {
              Ember.deprecate('Namespaces should not begin with lowercase.', /^[A-Z]/.test(prop));
              obj[NAME_KEY] = prop;
            }
          }
        }
        var NAME_KEY = Ember.NAME_KEY = Ember.GUID_KEY + '_name';
        function superClassString(mixin) {
          var superclass = mixin.superclass;
          if (superclass) {
            if (superclass[NAME_KEY]) {
              return superclass[NAME_KEY];
            } else {
              return superClassString(superclass);
            }
          } else {
            return;
          }
        }
        function classToString() {
          if (!Ember.BOOTED && !this[NAME_KEY]) {
            processAllNamespaces();
          }
          var ret;
          if (this[NAME_KEY]) {
            ret = this[NAME_KEY];
          } else {
            var str = superClassString(this);
            if (str) {
              ret = '(subclass of ' + str + ')';
            } else {
              ret = '(unknown mixin)';
            }
            this.toString = makeToString(ret);
          }
          return ret;
        }
        function processAllNamespaces() {
          var unprocessedNamespaces = !Namespace.PROCESSED, unprocessedMixins = Ember.anyUnprocessedMixins;
          if (unprocessedNamespaces) {
            findNamespaces();
            Namespace.PROCESSED = true;
          }
          if (unprocessedNamespaces || unprocessedMixins) {
            var namespaces = Namespace.NAMESPACES, namespace;
            for (var i = 0, l = namespaces.length; i < l; i++) {
              namespace = namespaces[i];
              processNamespace([namespace.toString()], namespace, {});
            }
            Ember.anyUnprocessedMixins = false;
          }
        }
        function makeToString(ret) {
          return function () {
            return ret;
          };
        }
        Ember.Mixin.prototype.toString = classToString;
      }());
      (function () {
        Ember.Application = Ember.Namespace.extend();
      }());
      (function () {
        var OUT_OF_RANGE_EXCEPTION = 'Index out of range';
        var EMPTY = [];
        var get = Ember.get, set = Ember.set;
        Ember.ArrayProxy = Ember.Object.extend(Ember.MutableArray, {
          content: null,
          arrangedContent: Ember.computed.alias('content'),
          objectAtContent: function (idx) {
            return get(this, 'arrangedContent').objectAt(idx);
          },
          replaceContent: function (idx, amt, objects) {
            get(this, 'content').replace(idx, amt, objects);
          },
          _contentWillChange: Ember.beforeObserver(function () {
            this._teardownContent();
          }, 'content'),
          _teardownContent: function () {
            var content = get(this, 'content');
            if (content) {
              content.removeArrayObserver(this, {
                willChange: 'contentArrayWillChange',
                didChange: 'contentArrayDidChange'
              });
            }
          },
          contentArrayWillChange: Ember.K,
          contentArrayDidChange: Ember.K,
          _contentDidChange: Ember.observer(function () {
            var content = get(this, 'content');
            Ember.assert("Can't set ArrayProxy's content to itself", content !== this);
            this._setupContent();
          }, 'content'),
          _setupContent: function () {
            var content = get(this, 'content');
            if (content) {
              content.addArrayObserver(this, {
                willChange: 'contentArrayWillChange',
                didChange: 'contentArrayDidChange'
              });
            }
          },
          _arrangedContentWillChange: Ember.beforeObserver(function () {
            var arrangedContent = get(this, 'arrangedContent'), len = arrangedContent ? get(arrangedContent, 'length') : 0;
            this.arrangedContentArrayWillChange(this, 0, len, undefined);
            this.arrangedContentWillChange(this);
            this._teardownArrangedContent(arrangedContent);
          }, 'arrangedContent'),
          _arrangedContentDidChange: Ember.observer(function () {
            var arrangedContent = get(this, 'arrangedContent'), len = arrangedContent ? get(arrangedContent, 'length') : 0;
            Ember.assert("Can't set ArrayProxy's content to itself", arrangedContent !== this);
            this._setupArrangedContent();
            this.arrangedContentDidChange(this);
            this.arrangedContentArrayDidChange(this, 0, undefined, len);
          }, 'arrangedContent'),
          _setupArrangedContent: function () {
            var arrangedContent = get(this, 'arrangedContent');
            if (arrangedContent) {
              arrangedContent.addArrayObserver(this, {
                willChange: 'arrangedContentArrayWillChange',
                didChange: 'arrangedContentArrayDidChange'
              });
            }
          },
          _teardownArrangedContent: function () {
            var arrangedContent = get(this, 'arrangedContent');
            if (arrangedContent) {
              arrangedContent.removeArrayObserver(this, {
                willChange: 'arrangedContentArrayWillChange',
                didChange: 'arrangedContentArrayDidChange'
              });
            }
          },
          arrangedContentWillChange: Ember.K,
          arrangedContentDidChange: Ember.K,
          objectAt: function (idx) {
            return get(this, 'content') && this.objectAtContent(idx);
          },
          length: Ember.computed(function () {
            var arrangedContent = get(this, 'arrangedContent');
            return arrangedContent ? get(arrangedContent, 'length') : 0;
          }),
          _replace: function (idx, amt, objects) {
            var content = get(this, 'content');
            Ember.assert('The content property of ' + this.constructor + ' should be set before modifying it', content);
            if (content)
              this.replaceContent(idx, amt, objects);
            return this;
          },
          replace: function () {
            if (get(this, 'arrangedContent') === get(this, 'content')) {
              this._replace.apply(this, arguments);
            } else {
              throw new Ember.Error('Using replace on an arranged ArrayProxy is not allowed.');
            }
          },
          _insertAt: function (idx, object) {
            if (idx > get(this, 'content.length'))
              throw new Error(OUT_OF_RANGE_EXCEPTION);
            this._replace(idx, 0, [object]);
            return this;
          },
          insertAt: function (idx, object) {
            if (get(this, 'arrangedContent') === get(this, 'content')) {
              return this._insertAt(idx, object);
            } else {
              throw new Ember.Error('Using insertAt on an arranged ArrayProxy is not allowed.');
            }
          },
          removeAt: function (start, len) {
            if ('number' === typeof start) {
              var content = get(this, 'content'), arrangedContent = get(this, 'arrangedContent'), indices = [], i;
              if (start < 0 || start >= get(this, 'length')) {
                throw new Error(OUT_OF_RANGE_EXCEPTION);
              }
              if (len === undefined)
                len = 1;
              for (i = start; i < start + len; i++) {
                indices.push(content.indexOf(arrangedContent.objectAt(i)));
              }
              indices.sort(function (a, b) {
                return b - a;
              });
              Ember.beginPropertyChanges();
              for (i = 0; i < indices.length; i++) {
                this._replace(indices[i], 1, EMPTY);
              }
              Ember.endPropertyChanges();
            }
            return this;
          },
          pushObject: function (obj) {
            this._insertAt(get(this, 'content.length'), obj);
            return obj;
          },
          pushObjects: function (objects) {
            this._replace(get(this, 'length'), 0, objects);
            return this;
          },
          setObjects: function (objects) {
            if (objects.length === 0)
              return this.clear();
            var len = get(this, 'length');
            this._replace(0, len, objects);
            return this;
          },
          unshiftObject: function (obj) {
            this._insertAt(0, obj);
            return obj;
          },
          unshiftObjects: function (objects) {
            this._replace(0, 0, objects);
            return this;
          },
          slice: function () {
            var arr = this.toArray();
            return arr.slice.apply(arr, arguments);
          },
          arrangedContentArrayWillChange: function (item, idx, removedCnt, addedCnt) {
            this.arrayContentWillChange(idx, removedCnt, addedCnt);
          },
          arrangedContentArrayDidChange: function (item, idx, removedCnt, addedCnt) {
            this.arrayContentDidChange(idx, removedCnt, addedCnt);
          },
          init: function () {
            this._super();
            this._setupContent();
            this._setupArrangedContent();
          },
          willDestroy: function () {
            this._teardownArrangedContent();
            this._teardownContent();
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt, addBeforeObserver = Ember.addBeforeObserver, addObserver = Ember.addObserver, removeBeforeObserver = Ember.removeBeforeObserver, removeObserver = Ember.removeObserver, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange;
        function contentPropertyWillChange(content, contentKey) {
          var key = contentKey.slice(8);
          if (key in this) {
            return;
          }
          propertyWillChange(this, key);
        }
        function contentPropertyDidChange(content, contentKey) {
          var key = contentKey.slice(8);
          if (key in this) {
            return;
          }
          propertyDidChange(this, key);
        }
        Ember.ObjectProxy = Ember.Object.extend({
          content: null,
          _contentDidChange: Ember.observer(function () {
            Ember.assert("Can't set ObjectProxy's content to itself", this.get('content') !== this);
          }, 'content'),
          isTruthy: Ember.computed.bool('content'),
          _debugContainerKey: null,
          willWatchProperty: function (key) {
            var contentKey = 'content.' + key;
            addBeforeObserver(this, contentKey, null, contentPropertyWillChange);
            addObserver(this, contentKey, null, contentPropertyDidChange);
          },
          didUnwatchProperty: function (key) {
            var contentKey = 'content.' + key;
            removeBeforeObserver(this, contentKey, null, contentPropertyWillChange);
            removeObserver(this, contentKey, null, contentPropertyDidChange);
          },
          unknownProperty: function (key) {
            var content = get(this, 'content');
            if (content) {
              return get(content, key);
            }
          },
          setUnknownProperty: function (key, value) {
            var content = get(this, 'content');
            Ember.assert(fmt("Cannot delegate set('%@', %@) to the 'content' property of object proxy %@: its 'content' is undefined.", [
              key,
              value,
              this
            ]), content);
            return set(content, key, value);
          }
        });
        Ember.ObjectProxy.reopenClass({
          create: function () {
            var mixin, prototype, i, l, properties, keyName;
            if (arguments.length) {
              prototype = this.proto();
              for (i = 0, l = arguments.length; i < l; i++) {
                properties = arguments[i];
                for (keyName in properties) {
                  if (!properties.hasOwnProperty(keyName) || keyName in prototype) {
                    continue;
                  }
                  if (!mixin)
                    mixin = {};
                  mixin[keyName] = null;
                }
              }
              if (mixin)
                this._initMixins([mixin]);
            }
            return this._super.apply(this, arguments);
          }
        });
      }());
      (function () {
        var set = Ember.set, get = Ember.get, guidFor = Ember.guidFor;
        var forEach = Ember.EnumerableUtils.forEach;
        var EachArray = Ember.Object.extend(Ember.Array, {
            init: function (content, keyName, owner) {
              this._super();
              this._keyName = keyName;
              this._owner = owner;
              this._content = content;
            },
            objectAt: function (idx) {
              var item = this._content.objectAt(idx);
              return item && get(item, this._keyName);
            },
            length: Ember.computed(function () {
              var content = this._content;
              return content ? get(content, 'length') : 0;
            })
          });
        var IS_OBSERVER = /^.+:(before|change)$/;
        function addObserverForContentKey(content, keyName, proxy, idx, loc) {
          var objects = proxy._objects, guid;
          if (!objects)
            objects = proxy._objects = {};
          while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
              Ember.addBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
              Ember.addObserver(item, keyName, proxy, 'contentKeyDidChange');
              guid = guidFor(item);
              if (!objects[guid])
                objects[guid] = [];
              objects[guid].push(loc);
            }
          }
        }
        function removeObserverForContentKey(content, keyName, proxy, idx, loc) {
          var objects = proxy._objects;
          if (!objects)
            objects = proxy._objects = {};
          var indicies, guid;
          while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
              Ember.removeBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
              Ember.removeObserver(item, keyName, proxy, 'contentKeyDidChange');
              guid = guidFor(item);
              indicies = objects[guid];
              indicies[indicies.indexOf(loc)] = null;
            }
          }
        }
        Ember.EachProxy = Ember.Object.extend({
          init: function (content) {
            this._super();
            this._content = content;
            content.addArrayObserver(this);
            forEach(Ember.watchedEvents(this), function (eventName) {
              this.didAddListener(eventName);
            }, this);
          },
          unknownProperty: function (keyName, value) {
            var ret;
            ret = new EachArray(this._content, keyName, this);
            Ember.defineProperty(this, keyName, null, ret);
            this.beginObservingContentKey(keyName);
            return ret;
          },
          arrayWillChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, lim;
            lim = removedCnt > 0 ? idx + removedCnt : -1;
            Ember.beginPropertyChanges(this);
            for (key in keys) {
              if (!keys.hasOwnProperty(key)) {
                continue;
              }
              if (lim > 0)
                removeObserverForContentKey(content, key, this, idx, lim);
              Ember.propertyWillChange(this, key);
            }
            Ember.propertyWillChange(this._content, '@each');
            Ember.endPropertyChanges(this);
          },
          arrayDidChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, lim;
            lim = addedCnt > 0 ? idx + addedCnt : -1;
            Ember.beginPropertyChanges(this);
            for (key in keys) {
              if (!keys.hasOwnProperty(key)) {
                continue;
              }
              if (lim > 0)
                addObserverForContentKey(content, key, this, idx, lim);
              Ember.propertyDidChange(this, key);
            }
            Ember.propertyDidChange(this._content, '@each');
            Ember.endPropertyChanges(this);
          },
          didAddListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
              this.beginObservingContentKey(eventName.slice(0, -7));
            }
          },
          didRemoveListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
              this.stopObservingContentKey(eventName.slice(0, -7));
            }
          },
          beginObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (!keys)
              keys = this._keys = {};
            if (!keys[keyName]) {
              keys[keyName] = 1;
              var content = this._content, len = get(content, 'length');
              addObserverForContentKey(content, keyName, this, 0, len);
            } else {
              keys[keyName]++;
            }
          },
          stopObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (keys && keys[keyName] > 0 && --keys[keyName] <= 0) {
              var content = this._content, len = get(content, 'length');
              removeObserverForContentKey(content, keyName, this, 0, len);
            }
          },
          contentKeyWillChange: function (obj, keyName) {
            Ember.propertyWillChange(this, keyName);
          },
          contentKeyDidChange: function (obj, keyName) {
            Ember.propertyDidChange(this, keyName);
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        var NativeArray = Ember.Mixin.create(Ember.MutableArray, Ember.Observable, Ember.Copyable, {
            get: function (key) {
              if (key === 'length')
                return this.length;
              else if ('number' === typeof key)
                return this[key];
              else
                return this._super(key);
            },
            objectAt: function (idx) {
              return this[idx];
            },
            replace: function (idx, amt, objects) {
              if (this.isFrozen)
                throw Ember.FROZEN_ERROR;
              var len = objects ? get(objects, 'length') : 0;
              this.arrayContentWillChange(idx, amt, len);
              if (!objects || objects.length === 0) {
                this.splice(idx, amt);
              } else {
                var args = [
                    idx,
                    amt
                  ].concat(objects);
                this.splice.apply(this, args);
              }
              this.arrayContentDidChange(idx, amt, len);
              return this;
            },
            unknownProperty: function (key, value) {
              var ret;
              if (value !== undefined && ret === undefined) {
                ret = this[key] = value;
              }
              return ret;
            },
            indexOf: function (object, startAt) {
              var idx, len = this.length;
              if (startAt === undefined)
                startAt = 0;
              else
                startAt = startAt < 0 ? Math.ceil(startAt) : Math.floor(startAt);
              if (startAt < 0)
                startAt += len;
              for (idx = startAt; idx < len; idx++) {
                if (this[idx] === object)
                  return idx;
              }
              return -1;
            },
            lastIndexOf: function (object, startAt) {
              var idx, len = this.length;
              if (startAt === undefined)
                startAt = len - 1;
              else
                startAt = startAt < 0 ? Math.ceil(startAt) : Math.floor(startAt);
              if (startAt < 0)
                startAt += len;
              for (idx = startAt; idx >= 0; idx--) {
                if (this[idx] === object)
                  return idx;
              }
              return -1;
            },
            copy: function (deep) {
              if (deep) {
                return this.map(function (item) {
                  return Ember.copy(item, true);
                });
              }
              return this.slice();
            }
          });
        var ignore = ['length'];
        Ember.EnumerableUtils.forEach(NativeArray.keys(), function (methodName) {
          if (Array.prototype[methodName])
            ignore.push(methodName);
        });
        if (ignore.length > 0) {
          NativeArray = NativeArray.without.apply(NativeArray, ignore);
        }
        Ember.NativeArray = NativeArray;
        Ember.A = function (arr) {
          if (arr === undefined) {
            arr = [];
          }
          return Ember.Array.detect(arr) ? arr : Ember.NativeArray.apply(arr);
        };
        Ember.NativeArray.activate = function () {
          NativeArray.apply(Array.prototype);
          Ember.A = function (arr) {
            return arr || [];
          };
        };
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Array) {
          Ember.NativeArray.activate();
        }
      }());
      (function () {
        var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, none = Ember.isNone, fmt = Ember.String.fmt;
        Ember.Set = Ember.CoreObject.extend(Ember.MutableEnumerable, Ember.Copyable, Ember.Freezable, {
          length: 0,
          clear: function () {
            if (this.isFrozen) {
              throw new Error(Ember.FROZEN_ERROR);
            }
            var len = get(this, 'length');
            if (len === 0) {
              return this;
            }
            var guid;
            this.enumerableContentWillChange(len, 0);
            Ember.propertyWillChange(this, 'firstObject');
            Ember.propertyWillChange(this, 'lastObject');
            for (var i = 0; i < len; i++) {
              guid = guidFor(this[i]);
              delete this[guid];
              delete this[i];
            }
            set(this, 'length', 0);
            Ember.propertyDidChange(this, 'firstObject');
            Ember.propertyDidChange(this, 'lastObject');
            this.enumerableContentDidChange(len, 0);
            return this;
          },
          isEqual: function (obj) {
            if (!Ember.Enumerable.detect(obj))
              return false;
            var loc = get(this, 'length');
            if (get(obj, 'length') !== loc)
              return false;
            while (--loc >= 0) {
              if (!obj.contains(this[loc]))
                return false;
            }
            return true;
          },
          add: Ember.aliasMethod('addObject'),
          remove: Ember.aliasMethod('removeObject'),
          pop: function () {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            var obj = this.length > 0 ? this[this.length - 1] : null;
            this.remove(obj);
            return obj;
          },
          push: Ember.aliasMethod('addObject'),
          shift: Ember.aliasMethod('pop'),
          unshift: Ember.aliasMethod('push'),
          addEach: Ember.aliasMethod('addObjects'),
          removeEach: Ember.aliasMethod('removeObjects'),
          init: function (items) {
            this._super();
            if (items)
              this.addObjects(items);
          },
          nextObject: function (idx) {
            return this[idx];
          },
          firstObject: Ember.computed(function () {
            return this.length > 0 ? this[0] : undefined;
          }),
          lastObject: Ember.computed(function () {
            return this.length > 0 ? this[this.length - 1] : undefined;
          }),
          addObject: function (obj) {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            if (none(obj))
              return this;
            var guid = guidFor(obj), idx = this[guid], len = get(this, 'length'), added;
            if (idx >= 0 && idx < len && this[idx] === obj)
              return this;
            added = [obj];
            this.enumerableContentWillChange(null, added);
            Ember.propertyWillChange(this, 'lastObject');
            len = get(this, 'length');
            this[guid] = len;
            this[len] = obj;
            set(this, 'length', len + 1);
            Ember.propertyDidChange(this, 'lastObject');
            this.enumerableContentDidChange(null, added);
            return this;
          },
          removeObject: function (obj) {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            if (none(obj))
              return this;
            var guid = guidFor(obj), idx = this[guid], len = get(this, 'length'), isFirst = idx === 0, isLast = idx === len - 1, last, removed;
            if (idx >= 0 && idx < len && this[idx] === obj) {
              removed = [obj];
              this.enumerableContentWillChange(removed, null);
              if (isFirst) {
                Ember.propertyWillChange(this, 'firstObject');
              }
              if (isLast) {
                Ember.propertyWillChange(this, 'lastObject');
              }
              if (idx < len - 1) {
                last = this[len - 1];
                this[idx] = last;
                this[guidFor(last)] = idx;
              }
              delete this[guid];
              delete this[len - 1];
              set(this, 'length', len - 1);
              if (isFirst) {
                Ember.propertyDidChange(this, 'firstObject');
              }
              if (isLast) {
                Ember.propertyDidChange(this, 'lastObject');
              }
              this.enumerableContentDidChange(removed, null);
            }
            return this;
          },
          contains: function (obj) {
            return this[guidFor(obj)] >= 0;
          },
          copy: function () {
            var C = this.constructor, ret = new C, loc = get(this, 'length');
            set(ret, 'length', loc);
            while (--loc >= 0) {
              ret[loc] = this[loc];
              ret[guidFor(this[loc])] = loc;
            }
            return ret;
          },
          toString: function () {
            var len = this.length, idx, array = [];
            for (idx = 0; idx < len; idx++) {
              array[idx] = this[idx];
            }
            return fmt('Ember.Set<%@>', [array.join(',')]);
          }
        });
      }());
      (function () {
        var DeferredMixin = Ember.DeferredMixin, get = Ember.get;
        var Deferred = Ember.Object.extend(DeferredMixin);
        Deferred.reopenClass({
          promise: function (callback, binding) {
            var deferred = Deferred.create();
            callback.call(binding, deferred);
            return get(deferred, 'promise');
          }
        });
        Ember.Deferred = Deferred;
      }());
      (function () {
        var loadHooks = Ember.ENV.EMBER_LOAD_HOOKS || {};
        var loaded = {};
        Ember.onLoad = function (name, callback) {
          var object;
          loadHooks[name] = loadHooks[name] || Ember.A();
          loadHooks[name].pushObject(callback);
          if (object = loaded[name]) {
            callback(object);
          }
        };
        Ember.runLoadHooks = function (name, object) {
          var hooks;
          loaded[name] = object;
          if (hooks = loadHooks[name]) {
            loadHooks[name].forEach(function (callback) {
              callback(object);
            });
          }
        };
      }());
      (function () {
      }());
      (function () {
        var get = Ember.get;
        Ember.ControllerMixin = Ember.Mixin.create({
          isController: true,
          target: null,
          container: null,
          store: null,
          model: Ember.computed.alias('content'),
          send: function (actionName) {
            var args = [].slice.call(arguments, 1), target;
            if (this[actionName]) {
              Ember.assert('The controller ' + this + ' does not have the action ' + actionName, typeof this[actionName] === 'function');
              this[actionName].apply(this, args);
            } else if (target = get(this, 'target')) {
              Ember.assert('The target for controller ' + this + ' (' + target + ') did not define a `send` method', typeof target.send === 'function');
              target.send.apply(target, arguments);
            }
          }
        });
        Ember.Controller = Ember.Object.extend(Ember.ControllerMixin);
      }());
      (function () {
        var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach;
        Ember.SortableMixin = Ember.Mixin.create(Ember.MutableEnumerable, {
          sortProperties: null,
          sortAscending: true,
          orderBy: function (item1, item2) {
            var result = 0, sortProperties = get(this, 'sortProperties'), sortAscending = get(this, 'sortAscending');
            Ember.assert('you need to define `sortProperties`', !!sortProperties);
            forEach(sortProperties, function (propertyName) {
              if (result === 0) {
                result = Ember.compare(get(item1, propertyName), get(item2, propertyName));
                if (result !== 0 && !sortAscending) {
                  result = -1 * result;
                }
              }
            });
            return result;
          },
          destroy: function () {
            var content = get(this, 'content'), sortProperties = get(this, 'sortProperties');
            if (content && sortProperties) {
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super();
          },
          isSorted: Ember.computed.bool('sortProperties'),
          arrangedContent: Ember.computed('content', 'sortProperties.@each', function (key, value) {
            var content = get(this, 'content'), isSorted = get(this, 'isSorted'), sortProperties = get(this, 'sortProperties'), self = this;
            if (content && isSorted) {
              content = content.slice();
              content.sort(function (item1, item2) {
                return self.orderBy(item1, item2);
              });
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.addObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
              return Ember.A(content);
            }
            return content;
          }),
          _contentWillChange: Ember.beforeObserver(function () {
            var content = get(this, 'content'), sortProperties = get(this, 'sortProperties');
            if (content && sortProperties) {
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            this._super();
          }, 'content'),
          sortAscendingWillChange: Ember.beforeObserver(function () {
            this._lastSortAscending = get(this, 'sortAscending');
          }, 'sortAscending'),
          sortAscendingDidChange: Ember.observer(function () {
            if (get(this, 'sortAscending') !== this._lastSortAscending) {
              var arrangedContent = get(this, 'arrangedContent');
              arrangedContent.reverseObjects();
            }
          }, 'sortAscending'),
          contentArrayWillChange: function (array, idx, removedCount, addedCount) {
            var isSorted = get(this, 'isSorted');
            if (isSorted) {
              var arrangedContent = get(this, 'arrangedContent');
              var removedObjects = array.slice(idx, idx + removedCount);
              var sortProperties = get(this, 'sortProperties');
              forEach(removedObjects, function (item) {
                arrangedContent.removeObject(item);
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super(array, idx, removedCount, addedCount);
          },
          contentArrayDidChange: function (array, idx, removedCount, addedCount) {
            var isSorted = get(this, 'isSorted'), sortProperties = get(this, 'sortProperties');
            if (isSorted) {
              var addedObjects = array.slice(idx, idx + addedCount);
              forEach(addedObjects, function (item) {
                this.insertItemSorted(item);
                forEach(sortProperties, function (sortProperty) {
                  Ember.addObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super(array, idx, removedCount, addedCount);
          },
          insertItemSorted: function (item) {
            var arrangedContent = get(this, 'arrangedContent');
            var length = get(arrangedContent, 'length');
            var idx = this._binarySearch(item, 0, length);
            arrangedContent.insertAt(idx, item);
          },
          contentItemSortPropertyDidChange: function (item) {
            var arrangedContent = get(this, 'arrangedContent'), oldIndex = arrangedContent.indexOf(item), leftItem = arrangedContent.objectAt(oldIndex - 1), rightItem = arrangedContent.objectAt(oldIndex + 1), leftResult = leftItem && this.orderBy(item, leftItem), rightResult = rightItem && this.orderBy(item, rightItem);
            if (leftResult < 0 || rightResult > 0) {
              arrangedContent.removeObject(item);
              this.insertItemSorted(item);
            }
          },
          _binarySearch: function (item, low, high) {
            var mid, midItem, res, arrangedContent;
            if (low === high) {
              return low;
            }
            arrangedContent = get(this, 'arrangedContent');
            mid = low + Math.floor((high - low) / 2);
            midItem = arrangedContent.objectAt(mid);
            res = this.orderBy(midItem, item);
            if (res < 0) {
              return this._binarySearch(item, mid + 1, high);
            } else if (res > 0) {
              return this._binarySearch(item, low, mid);
            }
            return mid;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach, replace = Ember.EnumerableUtils.replace;
        Ember.ArrayController = Ember.ArrayProxy.extend(Ember.ControllerMixin, Ember.SortableMixin, {
          itemController: null,
          lookupItemController: function (object) {
            return get(this, 'itemController');
          },
          objectAtContent: function (idx) {
            var length = get(this, 'length'), arrangedContent = get(this, 'arrangedContent'), object = arrangedContent && arrangedContent.objectAt(idx);
            if (idx >= 0 && idx < length) {
              var controllerClass = this.lookupItemController(object);
              if (controllerClass) {
                return this.controllerAt(idx, object, controllerClass);
              }
            }
            return object;
          },
          arrangedContentDidChange: function () {
            this._super();
            this._resetSubControllers();
          },
          arrayContentDidChange: function (idx, removedCnt, addedCnt) {
            var subControllers = get(this, '_subControllers'), subControllersToRemove = subControllers.slice(idx, idx + removedCnt);
            forEach(subControllersToRemove, function (subController) {
              if (subController) {
                subController.destroy();
              }
            });
            replace(subControllers, idx, removedCnt, new Array(addedCnt));
            this._super(idx, removedCnt, addedCnt);
          },
          init: function () {
            this._super();
            if (!this.get('content')) {
              Ember.defineProperty(this, 'content', undefined, Ember.A());
            }
            this.set('_subControllers', Ember.A());
          },
          controllerAt: function (idx, object, controllerClass) {
            var container = get(this, 'container'), subControllers = get(this, '_subControllers'), subController = subControllers[idx];
            if (!subController) {
              subController = container.lookup('controller:' + controllerClass, { singleton: false });
              subControllers[idx] = subController;
            }
            if (!subController) {
              throw new Error('Could not resolve itemController: "' + controllerClass + '"');
            }
            subController.set('target', this);
            subController.set('content', object);
            return subController;
          },
          _subControllers: null,
          _resetSubControllers: function () {
            var subControllers = get(this, '_subControllers');
            forEach(subControllers, function (subController) {
              if (subController) {
                subController.destroy();
              }
            });
            this.set('_subControllers', Ember.A());
          }
        });
      }());
      (function () {
        Ember.ObjectController = Ember.ObjectProxy.extend(Ember.ControllerMixin);
      }());
      (function () {
      }());
      (function () {
      }());
    }());
  });
  require.define('/src/compiler.coffee', function (module, exports, __dirname, __filename) {
    var any, assignment, beingDeclared, collectIdentifiers, concat, concatMap, CS, declarationsNeeded, declarationsNeededRecursive, defaultRules, difference, divMod, dynamicMemberAccess, emberComputedProperty, enabledHelpers, envEnrichments, exports, expr, fn, fn, foldl1, forceBlock, forceComputedProperty, generateMutatingWalker, generateSoak, genSym, h, h, hasSoak, helperNames, helpers, inlineHelpers, intersect, isIdentifierName, JS, jsReserved, makeReturn, makeVarDeclaration, map, memberAccess, needsCaching, nub, owns, partition, span, stmt, union, usedAsExpression, variableDeclarations;
    cache$ = require('/src/functional-helpers.coffee', module);
    any = cache$.any;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    divMod = cache$.divMod;
    foldl1 = cache$.foldl1;
    intersect = cache$.intersect;
    map = cache$.map;
    nub = cache$.nub;
    owns = cache$.owns;
    partition = cache$.partition;
    span = cache$.span;
    union = cache$.union;
    cache$1 = require('/src/helpers.coffee', module);
    beingDeclared = cache$1.beingDeclared;
    usedAsExpression = cache$1.usedAsExpression;
    envEnrichments = cache$1.envEnrichments;
    CS = require('/src/nodes.coffee', module);
    JS = require('/src/js-nodes.coffee', module);
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    jsReserved = [
      'break',
      'case',
      'catch',
      'class',
      'const',
      'continue',
      'debugger',
      'default',
      'delete',
      'do',
      'else',
      'enum',
      'export',
      'extends',
      'false',
      'finally',
      'for',
      'function',
      'if',
      'implements',
      'import',
      'in',
      'instanceof',
      'interface',
      'let',
      'native',
      'new',
      'null',
      'package',
      'private',
      'protected',
      'public',
      'return',
      'static',
      'super',
      'switch',
      'this',
      'throw',
      'true',
      'try',
      'typeof',
      'var',
      'void',
      'while',
      'with',
      'yield',
      'arguments',
      'eval'
    ];
    genSym = function () {
      var genSymCounter;
      genSymCounter = 0;
      return function (pre) {
        return new JS.GenSym(pre, ++genSymCounter);
      };
    }();
    stmt = function (e) {
      var walk;
      if (!(null != e))
        return e;
      if (e.isStatement) {
        return e;
      } else if (e['instanceof'](JS.SequenceExpression)) {
        walk = function (seq) {
          return concatMap(seq.expressions, function (e) {
            if (e['instanceof'](JS.SequenceExpression)) {
              return walk(e);
            } else {
              return [stmt(e)];
            }
          });
        };
        return new JS.BlockStatement(walk(e));
      } else if (e['instanceof'](JS.ConditionalExpression)) {
        return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
      } else {
        return new JS.ExpressionStatement(e);
      }
    };
    expr = function (s) {
      var accum, alternate, block, consequent, iife, lastExpression, push;
      if (!(null != s))
        return s;
      if (s.isExpression) {
        return s;
      } else if (s['instanceof'](JS.BlockStatement)) {
        switch (s.body.length) {
        case 0:
          return helpers.undef();
        case 1:
          return expr(s.body[0]);
        default:
          return new JS.SequenceExpression(map(s.body, expr));
        }
      } else if (s['instanceof'](JS.ExpressionStatement)) {
        return s.expression;
      } else if (s['instanceof'](JS.ThrowStatement)) {
        return new JS.CallExpression(new JS.FunctionExpression(null, [], forceBlock(s)), []);
      } else if (s['instanceof'](JS.IfStatement)) {
        consequent = expr(null != s.consequent ? s.consequent : helpers.undef());
        alternate = expr(null != s.alternate ? s.alternate : helpers.undef());
        return new JS.ConditionalExpression(s.test, consequent, alternate);
      } else if (s['instanceof'](JS.ForInStatement, JS.ForStatement, JS.WhileStatement)) {
        accum = genSym('accum');
        push = function (x) {
          return stmt(new JS.CallExpression(memberAccess(accum, 'push'), [x]));
        };
        s.body = forceBlock(s.body);
        if (s.body.body.length) {
          lastExpression = s.body.body.slice(-1)[0];
          if (!lastExpression['instanceof'](JS.ThrowStatement))
            s.body.body[s.body.body.length - 1] = push(expr(lastExpression));
        } else {
          s.body.body.push(push(helpers.undef()));
        }
        block = new JS.BlockStatement([
          s,
          new JS.ReturnStatement(accum)
        ]);
        iife = new JS.FunctionExpression(null, [accum], block);
        return new JS.CallExpression(memberAccess(iife.g(), 'call'), [
          new JS.ThisExpression,
          new JS.ArrayExpression([])
        ]);
      } else if (s['instanceof'](JS.SwitchStatement, JS.TryStatement)) {
        block = new JS.BlockStatement([makeReturn(s)]);
        iife = new JS.FunctionExpression(null, [], block);
        return new JS.CallExpression(memberAccess(iife.g(), 'call'), [new JS.ThisExpression]);
      } else {
        throw new Error('expr: Cannot use a ' + s.type + ' as a value');
      }
    };
    makeReturn = function (node) {
      var stmts;
      if (!(null != node))
        return new JS.ReturnStatement;
      if (node['instanceof'](JS.BlockStatement)) {
        return new JS.BlockStatement([].slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
      } else if (node['instanceof'](JS.SequenceExpression)) {
        return new JS.SequenceExpression([].slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
      } else if (node['instanceof'](JS.IfStatement)) {
        return new JS.IfStatement(node.test, makeReturn(node.consequent), null != node.alternate ? makeReturn(node.alternate) : null);
      } else if (node['instanceof'](JS.SwitchStatement)) {
        return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
      } else if (node['instanceof'](JS.SwitchCase)) {
        if (!node.consequent.length)
          return node;
        stmts = node.consequent.slice(-1)[0]['instanceof'](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
        return new JS.SwitchCase(node.test, [].slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
      } else if (node['instanceof'](JS.TryStatement)) {
        return new JS.TryStatement(makeReturn(node.block), map(node.handlers, makeReturn), null != node.finalizer ? makeReturn(node.finalizer) : null);
      } else if (node['instanceof'](JS.CatchClause)) {
        return new JS.CatchClause(node.param, makeReturn(node.body));
      } else if (node['instanceof'](JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement)) {
        return node;
      } else if (node['instanceof'](JS.UnaryExpression) && node.operator === 'void') {
        return new JS.ReturnStatement;
      } else {
        return new JS.ReturnStatement(expr(node));
      }
    };
    generateMutatingWalker = function (fn) {
      return function (node, args) {
        var childName, n;
        args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
        for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
          childName = node.childNodes[i$];
          if (!(null != node[childName]))
            continue;
          node[childName] = in$(childName, node.listMembers) ? function (accum$) {
            for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
              n = node[childName][i$1];
              accum$.push(fn.apply(n, args));
            }
            return accum$;
          }.call(this, []) : fn.apply(node[childName], args);
        }
        return node;
      };
    };
    declarationsNeeded = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.AssignmentExpression) && node.operator === '=' && node.left['instanceof'](JS.Identifier)) {
        return [node.left];
      } else if (node['instanceof'](JS.ForInStatement) && node.left['instanceof'](JS.Identifier)) {
        return [node.left];
      } else {
        return [];
      }
    };
    declarationsNeededRecursive = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !node.generated) {
        return [];
      } else {
        return union(declarationsNeeded(node), concatMap(node.childNodes, function (childName) {
          if (!(null != node[childName]))
            return [];
          if (in$(childName, node.listMembers)) {
            return concatMap(node[childName], declarationsNeededRecursive);
          } else {
            return declarationsNeededRecursive(node[childName]);
          }
        }));
      }
    };
    variableDeclarations = function (node) {
      if (!(null != node))
        return [];
      if (node['instanceof'](JS.FunctionDeclaration)) {
        return [node.id];
      } else if (node['instanceof'](JS.FunctionExpression) && !node.generated) {
        return [];
      } else if (node['instanceof'](JS.VariableDeclarator)) {
        return [node.id];
      } else {
        return concatMap(node.childNodes, function (childName) {
          if (!(null != node[childName]))
            return [];
          if (in$(childName, node.listMembers)) {
            return concatMap(node[childName], variableDeclarations);
          } else {
            return variableDeclarations(node[childName]);
          }
        });
      }
    };
    collectIdentifiers = function (node) {
      return nub(function () {
        switch (false) {
        case !!(null != node):
          return [];
        case !node['instanceof'](JS.Identifier):
          return [node.name];
        case !(node['instanceof'](JS.MemberExpression) && !node.computed):
          return collectIdentifiers(node.object);
        default:
          return concatMap(node.childNodes, function (childName) {
            if (!(null != node[childName]))
              return [];
            if (in$(childName, node.listMembers)) {
              return concatMap(node[childName], collectIdentifiers);
            } else {
              return collectIdentifiers(node[childName]);
            }
          });
        }
      }.call(this));
    };
    needsCaching = function (node) {
      if (!(null != node))
        return false;
      return envEnrichments(node, []).length > 0 || node['instanceof'](CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp, CS.PreIncrementOp, CS.PostIncrementOp, CS.PreDecrementOp, CS.PostDecrementOp, CS.Range) || any(difference(node.childNodes, node.listMembers), function (n) {
        return needsCaching(node[n]);
      }) || any(node.listMembers, function (n) {
        return any(node[n], needsCaching);
      });
    };
    forceBlock = function (node) {
      if (!(null != node))
        return new JS.BlockStatement([]);
      node = stmt(node);
      if (node['instanceof'](JS.BlockStatement)) {
        return node;
      } else {
        return new JS.BlockStatement([node]);
      }
    };
    makeVarDeclaration = function (vars) {
      var decls, v;
      vars.sort(function (a, b) {
        a = a.name.toLowerCase();
        b = b.name.toLowerCase();
        if (a < b) {
          return -1;
        } else if (a > b) {
          return 1;
        } else {
          return 0;
        }
      });
      decls = function (accum$) {
        for (var i$ = 0, length$ = vars.length; i$ < length$; ++i$) {
          v = vars[i$];
          accum$.push(new JS.VariableDeclarator(v));
        }
        return accum$;
      }.call(this, []);
      return new JS.VariableDeclaration('var', decls);
    };
    isIdentifierName = function (name) {
      return !in$(name, jsReserved) && /^[$_a-z][$_a-z0-9]*$/i.test(name);
    };
    memberAccess = function (e, member) {
      if (isIdentifierName(member)) {
        return new JS.MemberExpression(false, expr(e), new JS.Identifier(member));
      } else {
        return new JS.MemberExpression(true, expr(e), new JS.Literal(member));
      }
    };
    dynamicMemberAccess = function (e, index) {
      if (index['instanceof'](JS.Literal) && typeof index.value === 'string') {
        return memberAccess(e, index.value);
      } else {
        return new JS.MemberExpression(true, expr(e), expr(index));
      }
    };
    forceComputedProperty = function (fn, chains) {
      return emberComputedProperty(fn, chains);
    };
    emberComputedProperty = function (fn, chains) {
      var computed;
      computed = new JS.CallExpression(memberAccess(new JS.Identifier('Ember'), 'computed'), [fn]);
      chains = chains.map(function (c) {
        return new JS.Literal(c);
      });
      return new JS.CallExpression(memberAccess(computed, 'property'), chains);
    };
    assignment = function (assignee, expression, valueUsed) {
      var alternate, assignments, consequent, e, elements, i, index, m, numElements, p, propName, restName, size, test;
      if (null == valueUsed)
        valueUsed = false;
      assignments = [];
      expression = expr(expression);
      switch (false) {
      case !assignee.rest:
      case !assignee['instanceof'](JS.ArrayExpression):
        e = expression;
        if (valueUsed || assignee.elements.length > 1) {
          e = genSym('cache');
          assignments.push(new JS.AssignmentExpression('=', e, expression));
        }
        elements = assignee.elements;
        for (var i$ = 0, length$ = elements.length; i$ < length$; ++i$) {
          m = elements[i$];
          i = i$;
          if (m.rest)
            break;
          assignments.push(assignment(m, dynamicMemberAccess(e, new JS.Literal(i)), valueUsed));
        }
        if (elements.length > 0) {
          if (elements.slice(-1)[0].rest) {
            numElements = elements.length;
            restName = elements[numElements - 1] = elements[numElements - 1].expression;
            test = new JS.BinaryExpression('<=', new JS.Literal(numElements), memberAccess(e, 'length'));
            consequent = helpers.slice(e, new JS.Literal(numElements - 1));
            alternate = new JS.ArrayExpression([]);
            assignments.push(stmt(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, alternate))));
          } else if (any(elements, function (p) {
              return p.rest;
            })) {
            restName = index = null;
            for (var i$1 = 0, length$1 = elements.length; i$1 < length$1; ++i$1) {
              p = elements[i$1];
              i = i$1;
              if (!p.rest)
                continue;
              restName = p.expression;
              index = i;
              break;
            }
            elements.splice(index, 1);
            numElements = elements.length;
            size = genSym('size');
            assignments.push(new JS.AssignmentExpression('=', size, memberAccess(e, 'length')));
            test = new JS.BinaryExpression('>', size, new JS.Literal(numElements));
            consequent = helpers.slice(e, new JS.Literal(index), new JS.BinaryExpression('-', size, new JS.Literal(numElements - index)));
            assignments.push(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, new JS.ArrayExpression([]))));
            for (var i$2 = 0, length$2 = elements.slice(index).length; i$2 < length$2; ++i$2) {
              p = elements.slice(index)[i$2];
              i = i$2;
              assignments.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, e, new JS.BinaryExpression('-', size, new JS.Literal(numElements - index - i))))));
            }
          }
          if (any(elements, function (p) {
              return p.rest;
            }))
            throw new Error('Positional destructuring assignments may not have more than one rest operator');
        }
        break;
      case !assignee['instanceof'](JS.ObjectExpression):
        e = expression;
        if (valueUsed || assignee.properties.length > 1) {
          e = genSym('cache');
          assignments.push(new JS.AssignmentExpression('=', e, expression));
        }
        for (var i$3 = 0, length$3 = assignee.properties.length; i$3 < length$3; ++i$3) {
          m = assignee.properties[i$3];
          propName = m.key['instanceof'](JS.Identifier) ? new JS.Literal(m.key.name) : m.key;
          assignments.push(assignment(m.value, dynamicMemberAccess(e, propName), valueUsed));
        }
        break;
      case !assignee['instanceof'](JS.Identifier, JS.GenSym):
        assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
        break;
      case !assignee['instanceof'](JS.MemberExpression):
        if (assignee.computed && !(typeof assignee.property.value === 'string')) {
          assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
        } else if (assignee.computed) {
          assignments.push(helpers.set(assignee.object, assignee.property, expr(expression)));
        } else {
          assignments.push(helpers.set(assignee.object, new JS.Literal(assignee.property.name), expr(expression)));
        }
        break;
      default:
        throw new Error('compile: assignment: unassignable assignee: ' + assignee.type);
      }
      switch (assignments.length) {
      case 0:
        if (e === expression) {
          return helpers.undef();
        } else {
          return expression;
        }
      case 1:
        return assignments[0];
      default:
        return new JS.SequenceExpression(valueUsed ? [].slice.call(assignments).concat([e]) : assignments);
      }
    };
    hasSoak = function (node) {
      switch (false) {
      case !node['instanceof'](CS.SoakedFunctionApplication, CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
        return true;
      case !node['instanceof'](CS.FunctionApplication):
        return hasSoak(node['function']);
      case !node['instanceof'](CS.MemberAccessOps):
        return hasSoak(node.expression);
      default:
        return false;
      }
    };
    generateSoak = function () {
      var fn;
      fn = function (node) {
        var cache$2, cache$3, cache$4, cache$5, cache$6, ctor, e, memberName, sym, tests, typeofTest;
        switch (false) {
        case !node['instanceof'](CS.MemberAccessOp, CS.ProtoMemberAccessOp):
          cache$2 = fn(node.expression);
          tests = cache$2[0];
          e = cache$2[1];
          return [
            tests,
            new node.constructor(e, node.memberName)
          ];
        case !node['instanceof'](CS.DynamicMemberAccessOp, CS.DynamicProtoMemberAccessOp):
          cache$3 = fn(node.expression);
          tests = cache$3[0];
          e = cache$3[1];
          return [
            tests,
            new node.constructor(e, node.indexingExpr)
          ];
        case !node['instanceof'](CS.FunctionApplication):
          cache$4 = fn(node['function']);
          tests = cache$4[0];
          e = cache$4[1];
          return [
            tests,
            new CS.FunctionApplication(e, node['arguments'])
          ];
        case !node['instanceof'](CS.SoakedFunctionApplication):
          cache$5 = fn(node['function']);
          tests = cache$5[0];
          e = cache$5[1];
          typeofTest = function (e) {
            return new CS.EQOp(new CS.String('function'), new CS.TypeofOp(e));
          };
          if (needsCaching(e)) {
            sym = new CS.GenSym('cache');
            return [
              [].slice.call(tests).concat([typeofTest(new CS.AssignOp(sym, e))]),
              new CS.FunctionApplication(sym, node['arguments'])
            ];
          } else {
            return [
              [].slice.call(tests).concat([typeofTest(e)]),
              new CS.FunctionApplication(e, node['arguments'])
            ];
          }
        case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
          memberName = function () {
            switch (false) {
            case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp):
              return 'memberName';
            case !node['instanceof'](CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
              return 'indexingExpr';
            }
          }.call(this);
          ctor = function () {
            switch (false) {
            case !node['instanceof'](CS.SoakedMemberAccessOp):
              return CS.MemberAccessOp;
            case !node['instanceof'](CS.SoakedProtoMemberAccessOp):
              return CS.ProtoMemberAccessOp;
            case !node['instanceof'](CS.SoakedDynamicMemberAccessOp):
              return CS.DynamicMemberAccessOp;
            case !node['instanceof'](CS.SoakedDynamicProtoMemberAccessOp):
              return CS.DynamicProtoMemberAccessOp;
            }
          }.call(this);
          cache$6 = fn(node.expression);
          tests = cache$6[0];
          e = cache$6[1];
          if (needsCaching(e)) {
            sym = new CS.GenSym('cache');
            return [
              [].slice.call(tests).concat([new CS.UnaryExistsOp(new CS.AssignOp(sym, e))]),
              new ctor(sym, node[memberName])
            ];
          } else {
            return [
              [].slice.call(tests).concat([new CS.UnaryExistsOp(e)]),
              new ctor(e, node[memberName])
            ];
          }
        default:
          return [
            [],
            node
          ];
        }
      };
      return function (node) {
        var cache$2, e, tests;
        cache$2 = fn(node);
        tests = cache$2[0];
        e = cache$2[1];
        return new CS.Conditional(foldl1(tests, function (memo, t) {
          return new CS.LogicalAndOp(memo, t);
        }), e);
      };
    }();
    helperNames = {};
    helpers = {
      'extends': function () {
        var block, child, ctor, f, key, parent, protoAccess;
        protoAccess = function (e) {
          return memberAccess(e, 'prototype');
        };
        child = new JS.Identifier('child');
        parent = new JS.Identifier('parent');
        ctor = new JS.Identifier('ctor');
        key = new JS.Identifier('key');
        block = [
          new JS.ForInStatement(new JS.VariableDeclaration('var', [new JS.VariableDeclarator(key, null)]), parent, new JS.IfStatement(helpers.isOwn(parent, key), f = stmt(new JS.AssignmentExpression('=', new JS.MemberExpression(true, child, key), new JS.MemberExpression(true, parent, key))))),
          new JS.FunctionDeclaration(ctor, [], new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', memberAccess(new JS.ThisExpression, 'constructor'), child))])),
          new JS.AssignmentExpression('=', protoAccess(ctor), protoAccess(parent)),
          new JS.AssignmentExpression('=', protoAccess(child), new JS.NewExpression(ctor, [])),
          new JS.AssignmentExpression('=', memberAccess(child, '__super__'), protoAccess(parent)),
          new JS.ReturnStatement(child)
        ];
        return new JS.FunctionDeclaration(helperNames['extends'], [
          child,
          parent
        ], new JS.BlockStatement(map(block, stmt)));
      },
      construct: function () {
        var args, block, child, ctor, fn, result;
        child = new JS.Identifier('child');
        ctor = new JS.Identifier('ctor');
        fn = new JS.Identifier('fn');
        args = new JS.Identifier('args');
        result = new JS.Identifier('result');
        block = [
          new JS.VariableDeclaration('var', [new JS.VariableDeclarator(fn, new JS.FunctionExpression(null, [], new JS.BlockStatement([])))]),
          new JS.AssignmentExpression('=', memberAccess(fn, 'prototype'), memberAccess(ctor, 'prototype')),
          new JS.VariableDeclaration('var', [
            new JS.VariableDeclarator(child, new JS.NewExpression(fn, [])),
            new JS.VariableDeclarator(result, new JS.CallExpression(memberAccess(ctor, 'apply'), [
              child,
              args
            ]))
          ]),
          new JS.ReturnStatement(new JS.ConditionalExpression(new JS.BinaryExpression('===', result, new JS.CallExpression(new JS.Identifier('Object'), [result])), result, child))
        ];
        return new JS.FunctionDeclaration(helperNames.construct, [
          ctor,
          args
        ], new JS.BlockStatement(map(block, stmt)));
      },
      isOwn: function () {
        var args, functionBody, hop, params;
        hop = memberAccess(new JS.ObjectExpression([]), 'hasOwnProperty');
        params = args = [
          new JS.Identifier('o'),
          new JS.Identifier('p')
        ];
        functionBody = [new JS.CallExpression(memberAccess(hop, 'call'), args)];
        return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
      },
      'in': function () {
        var functionBody, i, length, list, loopBody, member, varDeclaration;
        member = new JS.Identifier('member');
        list = new JS.Identifier('list');
        i = new JS.Identifier('i');
        length = new JS.Identifier('length');
        varDeclaration = new JS.VariableDeclaration('var', [
          new JS.VariableDeclarator(i, new JS.Literal(0)),
          new JS.VariableDeclarator(length, memberAccess(list, 'length'))
        ]);
        loopBody = new JS.IfStatement(new JS.LogicalExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(new JS.Literal(true)));
        functionBody = [
          new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody),
          new JS.Literal(false)
        ];
        return new JS.FunctionDeclaration(helperNames['in'], [
          member,
          list
        ], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
      },
      get: function () {
        return new JS.VariableDeclaration('var', [new JS.VariableDeclarator(helperNames.get, memberAccess(new JS.Identifier('Ember'), 'get'))]);
      },
      set: function () {
        return new JS.VariableDeclaration('var', [new JS.VariableDeclarator(helperNames.set, memberAccess(new JS.Identifier('Ember'), 'set'))]);
      }
    };
    enabledHelpers = [];
    for (h in helpers) {
      if (!isOwn$(helpers, h))
        continue;
      fn = helpers[h];
      helperNames[h] = genSym(h);
      helpers[h] = function (h, fn) {
        return function () {
          enabledHelpers.push(fn());
          return (helpers[h] = function () {
            return new JS.CallExpression(helperNames[h], arguments);
          }).apply(this, arguments);
        };
      }(h, fn);
    }
    inlineHelpers = {
      exp: function () {
        return new JS.CallExpression(memberAccess(new JS.Identifier('Math'), 'pow'), arguments);
      },
      undef: function () {
        return new JS.UnaryExpression('void', new JS.Literal(0));
      },
      slice: function () {
        return new JS.CallExpression(memberAccess(memberAccess(new JS.ArrayExpression([]), 'slice'), 'call'), arguments);
      }
    };
    for (h in inlineHelpers) {
      if (!isOwn$(inlineHelpers, h))
        continue;
      fn = inlineHelpers[h];
      helpers[h] = fn;
    }
    exports.Compiler = function () {
      Compiler.compile = function (this$) {
        return function () {
          var cache$2;
          return (cache$2 = new this$).compile.apply(cache$2, [].slice.call(arguments));
        };
      }(Compiler);
      defaultRules = [
        [
          CS.Program,
          function (param$) {
            var block, body, cache$2, cache$3, decls, fnDeclHelpers, inScope, options, otherHelpers, pkg, program;
            {
              cache$2 = param$;
              body = cache$2.body;
              inScope = cache$2.inScope;
              options = cache$2.options;
            }
            if (!(null != body))
              return new JS.Program([]);
            block = stmt(body);
            block = block['instanceof'](JS.BlockStatement) ? block.body : [block];
            cache$3 = partition(enabledHelpers, function (helper) {
              return helper['instanceof'](JS.FunctionDeclaration);
            });
            fnDeclHelpers = cache$3[0];
            otherHelpers = cache$3[1];
            [].push.apply(block, fnDeclHelpers);
            [].unshift.apply(block, otherHelpers);
            decls = nub(concatMap(block, declarationsNeededRecursive));
            if (decls.length > 0)
              if (options.bare) {
                block.unshift(makeVarDeclaration(decls));
              } else {
                block = [stmt(new JS.UnaryExpression('void', new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), 'call'), [new JS.ThisExpression])))];
              }
            pkg = require('/package.json', module);
            program = new JS.Program(block);
            program.leadingComments = [{
                type: 'Line',
                value: ' Generated by EmberScript ' + pkg.version
              }];
            return program;
          }
        ],
        [
          CS.Block,
          function (param$) {
            var statements;
            statements = param$.statements;
            switch (statements.length) {
            case 0:
              return new JS.EmptyStatement;
            case 1:
              return new stmt(statements[0]);
            default:
              return new JS.BlockStatement(concatMap(statements, function (s) {
                if (s['instanceof'](JS.BlockStatement)) {
                  return map(s.body, stmt);
                } else if (s['instanceof'](JS.SequenceExpression)) {
                  return map(s.expressions, stmt);
                } else {
                  return [stmt(s)];
                }
              }));
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.SequenceExpression([
              left,
              right
            ]);
          }
        ],
        [
          CS.Conditional,
          function (param$) {
            var ancestry, cache$2, condition;
            var alternate, consequent;
            {
              cache$2 = param$;
              condition = cache$2.condition;
              consequent = cache$2.consequent;
              alternate = cache$2.alternate;
              ancestry = cache$2.ancestry;
            }
            if (null != alternate) {
              if (!(null != consequent))
                throw new Error('Conditional with non-null alternate requires non-null consequent');
              if (!alternate['instanceof'](JS.IfStatement))
                alternate = forceBlock(alternate);
            }
            if (null != alternate || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.Conditional) : void 0))
              consequent = forceBlock(consequent);
            return new JS.IfStatement(expr(condition), stmt(consequent), alternate);
          }
        ],
        [
          CS.ForIn,
          function (param$) {
            var block, body, cache$2, compile, e, filter, i, k, keyAssignee, length, op, step, target, update, valAssignee, varDeclaration;
            {
              cache$2 = param$;
              valAssignee = cache$2.valAssignee;
              keyAssignee = cache$2.keyAssignee;
              target = cache$2.target;
              step = cache$2.step;
              filter = cache$2.filter;
              body = cache$2.body;
              compile = cache$2.compile;
            }
            i = genSym('i');
            length = genSym('length');
            block = forceBlock(body);
            if (!block.body.length)
              block.body.push(stmt(helpers.undef()));
            if (this.target['instanceof'](CS.Range) && (this.target.left['instanceof'](CS.Int) || this.target.left['instanceof'](CS.UnaryNegateOp) && this.target.left.expression['instanceof'](CS.Int)) && (this.target.right['instanceof'](CS.Int) || this.target.right['instanceof'](CS.UnaryNegateOp) && this.target.right.expression['instanceof'](CS.Int))) {
              varDeclaration = new JS.AssignmentExpression('=', i, compile(this.target.left));
              update = new JS.UpdateExpression('++', true, i);
              if (null != keyAssignee) {
                k = genSym('k');
                varDeclaration = new JS.SequenceExpression([
                  new JS.AssignmentExpression('=', k, new JS.Literal(0)),
                  varDeclaration
                ]);
                update = new JS.SequenceExpression([
                  new JS.UpdateExpression('++', true, k),
                  update
                ]);
                block.body.unshift(stmt(new JS.AssignmentExpression('=', keyAssignee, k)));
              }
              if (null != valAssignee)
                block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, i)));
              op = this.target.isInclusive ? '<=' : '<';
              return new JS.ForStatement(varDeclaration, new JS.BinaryExpression(op, i, compile(this.target.right)), update, block);
            }
            e = needsCaching(this.target) ? genSym('cache') : target;
            varDeclaration = new JS.VariableDeclaration('var', [
              new JS.VariableDeclarator(i, new JS.Literal(0)),
              new JS.VariableDeclarator(length, memberAccess(e, 'length'))
            ]);
            if (!(e === target))
              varDeclaration.declarations.unshift(new JS.VariableDeclarator(e, target));
            if (null != this.filter)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
            if (null != keyAssignee)
              block.body.unshift(stmt(assignment(keyAssignee, i)));
            if (null != valAssignee)
              block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, i))));
            return new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), block);
          }
        ],
        [
          CS.ForOf,
          function (param$) {
            var block, body, cache$2, e, filter, keyAssignee, right, target, valAssignee;
            {
              cache$2 = param$;
              keyAssignee = cache$2.keyAssignee;
              valAssignee = cache$2.valAssignee;
              target = cache$2.target;
              filter = cache$2.filter;
              body = cache$2.body;
            }
            block = forceBlock(body);
            if (!block.body.length)
              block.body.push(stmt(helpers.undef()));
            e = this.isOwn && needsCaching(this.target) ? genSym('cache') : expr(target);
            if (null != this.filter)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
            if (null != valAssignee)
              block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, keyAssignee))));
            if (this.isOwn)
              block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(e, keyAssignee)), new JS.ContinueStatement)));
            right = e === target ? e : new JS.AssignmentExpression('=', e, target);
            return new JS.ForInStatement(keyAssignee, right, block);
          }
        ],
        [
          CS.While,
          function (param$) {
            var body, cache$2, condition;
            {
              cache$2 = param$;
              condition = cache$2.condition;
              body = cache$2.body;
            }
            return new JS.WhileStatement(expr(condition), forceBlock(body));
          }
        ],
        [
          CS.Switch,
          function (param$) {
            var alternate, c, cache$2;
            var cases, expression;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              cases = cache$2.cases;
              alternate = cache$2.alternate;
            }
            cases = concat(cases);
            if (!(null != expression)) {
              expression = new JS.Literal(false);
              for (var i$ = 0, length$ = cases.length; i$ < length$; ++i$) {
                c = cases[i$];
                c.test = new JS.UnaryExpression('!', c.test);
              }
            }
            if (null != alternate)
              cases.push(new JS.SwitchCase(null, [stmt(alternate)]));
            for (var i$1 = 0, length$1 = cases.slice(0, -1).length; i$1 < length$1; ++i$1) {
              c = cases.slice(0, -1)[i$1];
              if (!((null != c.consequent ? c.consequent.length : void 0) > 0))
                continue;
              c.consequent.push(new JS.BreakStatement);
            }
            return new JS.SwitchStatement(expression, cases);
          }
        ],
        [
          CS.SwitchCase,
          function (param$) {
            var block, cache$2, cases, conditions, consequent;
            {
              cache$2 = param$;
              conditions = cache$2.conditions;
              consequent = cache$2.consequent;
            }
            cases = map(conditions, function (c) {
              return new JS.SwitchCase(c, []);
            });
            block = stmt(consequent);
            block = null != block ? block['instanceof'](JS.BlockStatement) ? block.body : [block] : [];
            cases[cases.length - 1].consequent = block;
            return cases;
          }
        ],
        [
          CS.Try,
          function (param$) {
            var body, cache$2, catchAssignee, catchBlock, catchBody, e, finallyBlock, finallyBody, handlers;
            {
              cache$2 = param$;
              body = cache$2.body;
              catchAssignee = cache$2.catchAssignee;
              catchBody = cache$2.catchBody;
              finallyBody = cache$2.finallyBody;
            }
            finallyBlock = null != this.finallyBody ? forceBlock(finallyBody) : null;
            if (null != this.catchBody || !(null != this.finallyBody)) {
              e = genSym('e');
              catchBlock = forceBlock(catchBody);
              if (null != catchAssignee)
                catchBlock.body.unshift(stmt(assignment(catchAssignee, e)));
              handlers = [new JS.CatchClause(e, catchBlock)];
            } else {
              handlers = [];
            }
            return new JS.TryStatement(forceBlock(body), handlers, finallyBlock);
          }
        ],
        [
          CS.Throw,
          function (param$) {
            var expression;
            expression = param$.expression;
            return new JS.ThrowStatement(expression);
          }
        ],
        [
          CS.Range,
          function (param$) {
            var accum, ancestry, body, cache$2, condition, conditionAlternate, conditionConsequent, conditionTest, i, left, left_, range, rawLeft, rawRight, right, right_, update, vars;
            {
              cache$2 = param$;
              left_ = cache$2.left;
              right_ = cache$2.right;
              ancestry = cache$2.ancestry;
            }
            if ((this.left['instanceof'](CS.Int) || this.left['instanceof'](CS.UnaryNegateOp) && this.left.expression['instanceof'](CS.Int)) && (this.right['instanceof'](CS.Int) || this.right['instanceof'](CS.UnaryNegateOp) && this.right.expression['instanceof'](CS.Int))) {
              rawLeft = this.left['instanceof'](CS.UnaryNegateOp) ? -this.left.expression.data : this.left.data;
              rawRight = this.right['instanceof'](CS.UnaryNegateOp) ? -this.right.expression.data : this.right.data;
              if (Math.abs(rawLeft - rawRight) <= 20) {
                range = this.isInclusive ? function () {
                  var accum$;
                  accum$ = [];
                  for (var i$ = rawLeft; rawLeft <= rawRight ? i$ <= rawRight : i$ >= rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                    accum$.push(i$);
                  return accum$;
                }.apply(this, arguments) : function () {
                  var accum$;
                  accum$ = [];
                  for (var i$ = rawLeft; rawLeft <= rawRight ? i$ < rawRight : i$ > rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                    accum$.push(i$);
                  return accum$;
                }.apply(this, arguments);
                return new JS.ArrayExpression(map(range, function (n) {
                  if (n < 0) {
                    return new JS.UnaryExpression('-', new JS.Literal(-n));
                  } else {
                    return new JS.Literal(n);
                  }
                }));
              }
            }
            accum = genSym('accum');
            body = [stmt(new JS.AssignmentExpression('=', accum, new JS.ArrayExpression([])))];
            if (needsCaching(left_)) {
              left = genSym('from');
              body.push(stmt(new JS.AssignmentExpression('=', left, left_)));
            } else {
              left = left_;
            }
            if (needsCaching(right_)) {
              right = genSym('to');
              body.push(stmt(new JS.AssignmentExpression('=', right, right_)));
            } else {
              right = right_;
            }
            i = genSym('i');
            vars = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, left)]);
            conditionTest = new JS.BinaryExpression('<=', left, right);
            conditionConsequent = new JS.BinaryExpression(this.isInclusive ? '<=' : '<', i, right);
            conditionAlternate = new JS.BinaryExpression(this.isInclusive ? '>=' : '>', i, right);
            condition = new JS.ConditionalExpression(conditionTest, conditionConsequent, conditionAlternate);
            update = new JS.ConditionalExpression(conditionTest, new JS.UpdateExpression('++', true, i), new JS.UpdateExpression('--', true, i));
            body.push(new JS.ForStatement(vars, condition, update, stmt(new JS.CallExpression(memberAccess(accum, 'push'), [i]))));
            body.push(new JS.ReturnStatement(accum));
            if (any(ancestry, function (ancestor) {
                return ancestor['instanceof'](CS.Functions);
              })) {
              return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'apply'), [
                new JS.ThisExpression,
                new JS.Identifier('arguments')
              ]);
            } else {
              return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'call'), [new JS.ThisExpression]);
            }
          }
        ],
        [
          CS.ArrayInitialiser,
          function () {
            var groupMembers;
            groupMembers = function (members) {
              var cache$2, cache$3, sliced, ys, zs;
              if (members.length === 0) {
                return [];
              } else {
                cache$2 = span(members, function (x) {
                  return !x.spread;
                });
                ys = cache$2[0];
                zs = cache$2[1];
                if (ys.length === 0) {
                  sliced = helpers.slice(zs[0].expression);
                  cache$3 = [
                    sliced,
                    zs.slice(1)
                  ];
                  ys = cache$3[0];
                  zs = cache$3[1];
                  cache$3;
                } else {
                  ys = new JS.ArrayExpression(map(ys, expr));
                }
                return [ys].concat(groupMembers(zs));
              }
            };
            return function (param$) {
              var cache$2, compile, grouped, members;
              {
                cache$2 = param$;
                members = cache$2.members;
                compile = cache$2.compile;
              }
              if (any(members, function (m) {
                  return m.spread;
                })) {
                grouped = map(groupMembers(members), expr);
                if (grouped.length <= 1) {
                  return grouped[0];
                } else {
                  return new JS.CallExpression(memberAccess(grouped[0], 'concat'), grouped.slice(1));
                }
              } else {
                return new JS.ArrayExpression(map(members, expr));
              }
            };
          }()
        ],
        [
          CS.Spread,
          function (param$) {
            var expression;
            expression = param$.expression;
            return {
              spread: true,
              expression: expr(expression)
            };
          }
        ],
        [
          CS.ObjectInitialiser,
          function (param$) {
            var members;
            members = param$.members;
            return new JS.ObjectExpression(members);
          }
        ],
        [
          CS.ObjectInitialiserMember,
          function (param$) {
            var args, cache$2, computed, keyName, observes, volatile;
            var expression, key;
            {
              cache$2 = param$;
              key = cache$2.key;
              expression = cache$2.expression;
            }
            expression = expr(expression);
            this.annotations || (this.annotations = []);
            if (computed = this.annotations.find(function (a) {
                return a['instanceof'](CS.Computed);
              }))
              expression = forceComputedProperty(expression, computed.parameters);
            if (volatile = this.annotations.find(function (a) {
                return a['instanceof'](CS.Volatile);
              })) {
              expression = forceComputedProperty(expression, volatile.parameters);
              expression = new JS.CallExpression(memberAccess(expression, 'volatile'), []);
            }
            if (observes = this.annotations.find(function (a) {
                return a['instanceof'](CS.Observes);
              })) {
              args = [expression].concat(observes.parameters.map(function (p) {
                return new JS.Literal(p);
              }));
              expression = new JS.CallExpression(memberAccess(new JS.Identifier('Ember'), 'observer'), args);
            }
            keyName = this.key.data;
            key = isIdentifierName(keyName) ? new JS.Identifier(keyName) : new JS.Literal(keyName);
            return new JS.Property(key, expression);
          }
        ],
        [
          CS.DefaultParam,
          function (param$) {
            var cache$2, d, param;
            {
              cache$2 = param$;
              param = cache$2.param;
              d = cache$2['default'];
            }
            return {
              param: param,
              'default': d
            };
          }
        ],
        [
          CS.Function,
          CS.BoundFunction,
          CS.ComputedProperty,
          function () {
            var handleParam;
            handleParam = function (param, original, block, inScope) {
              var decls, p;
              switch (false) {
              case !original['instanceof'](CS.Rest):
                return param;
              case !original['instanceof'](CS.Identifier):
                return param;
              case !original['instanceof'](CS.MemberAccessOps, CS.ObjectInitialiser, CS.ArrayInitialiser):
                p = genSym('param');
                decls = map(intersect(inScope, beingDeclared(original)), function (i) {
                  return new JS.Identifier(i);
                });
                block.body.unshift(stmt(assignment(param, p)));
                if (decls.length)
                  block.body.unshift(makeVarDeclaration(decls));
                return p;
              case !original['instanceof'](CS.DefaultParam):
                p = handleParam.call(this, param.param, original.param, block, inScope);
                block.body.unshift(new JS.IfStatement(new JS.BinaryExpression('==', new JS.Literal(null), p), stmt(assignment(p, param['default']))));
                return p;
              default:
                throw new Error('Unsupported parameter type: ' + original.className);
              }
            };
            return function (param$) {
              var alternate, ancestry, block, cache$2, chains, consequent, i, index, inScope, last, newThis, numArgs, numParams, p, parameters_, paramName, performedRewrite, pIndex, reassignments, rewriteThis, test;
              var body, parameters;
              {
                cache$2 = param$;
                parameters = cache$2.parameters;
                body = cache$2.body;
                ancestry = cache$2.ancestry;
                inScope = cache$2.inScope;
              }
              if (!(null != ancestry[0] ? ancestry[0]['instanceof'](CS.Constructor) : void 0))
                body = makeReturn(body);
              block = forceBlock(body);
              last = block.body.slice(-1)[0];
              if ((null != last ? last['instanceof'](JS.ReturnStatement) : void 0) && !(null != last.argument))
                block.body = block.body.slice(0, -1);
              parameters_ = parameters.length === 0 ? [] : (pIndex = parameters.length, function (accum$) {
                while (pIndex--) {
                  accum$.push(handleParam.call(this, parameters[pIndex], this.parameters[pIndex], block, inScope));
                }
                return accum$;
              }.call(this, []));
              parameters = parameters_.reverse();
              if (parameters.length > 0) {
                if (parameters.slice(-1)[0].rest) {
                  paramName = parameters.pop().expression;
                  numParams = parameters.length;
                  test = new JS.BinaryExpression('>', memberAccess(new JS.Identifier('arguments'), 'length'), new JS.Literal(numParams));
                  consequent = helpers.slice(new JS.Identifier('arguments'), new JS.Literal(numParams));
                  alternate = new JS.ArrayExpression([]);
                  if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                    block.body.unshift(makeVarDeclaration([paramName]));
                  block.body.unshift(stmt(new JS.AssignmentExpression('=', paramName, new JS.ConditionalExpression(test, consequent, alternate))));
                } else if (any(parameters, function (p) {
                    return p.rest;
                  })) {
                  paramName = index = null;
                  for (var i$ = 0, length$ = parameters.length; i$ < length$; ++i$) {
                    p = parameters[i$];
                    i = i$;
                    if (!p.rest)
                      continue;
                    paramName = p.expression;
                    index = i;
                    break;
                  }
                  parameters.splice(index, 1);
                  numParams = parameters.length;
                  numArgs = genSym('numArgs');
                  reassignments = new JS.IfStatement(new JS.BinaryExpression('>', new JS.AssignmentExpression('=', numArgs, memberAccess(new JS.Identifier('arguments'), 'length')), new JS.Literal(numParams)), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, helpers.slice(new JS.Identifier('arguments'), new JS.Literal(index), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index)))))]), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, new JS.ArrayExpression([])))]));
                  for (var i$1 = 0, length$1 = parameters.slice(index).length; i$1 < length$1; ++i$1) {
                    p = parameters.slice(index)[i$1];
                    i = i$1;
                    reassignments.consequent.body.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, new JS.Identifier('arguments'), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index - i))))));
                  }
                  if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                    block.body.unshift(makeVarDeclaration([paramName]));
                  block.body.unshift(reassignments);
                }
                if (any(parameters, function (p) {
                    return p.rest;
                  }))
                  throw new Error('Parameter lists may not have more than one rest operator');
              }
              performedRewrite = false;
              if (this['instanceof'](CS.BoundFunction)) {
                newThis = genSym('this');
                rewriteThis = generateMutatingWalker(function () {
                  if (this['instanceof'](JS.ThisExpression)) {
                    performedRewrite = true;
                    return newThis;
                  } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
                    return this;
                  } else {
                    return rewriteThis(this);
                  }
                });
                rewriteThis(block);
              }
              fn = new JS.FunctionExpression(null, parameters, block);
              if (performedRewrite)
                fn = new JS.CallExpression(new JS.FunctionExpression(null, [newThis], new JS.BlockStatement([new JS.ReturnStatement(fn)])), [new JS.ThisExpression]);
              if (this['instanceof'](CS.ComputedProperty)) {
                chains = Ember.A(this.dependentKeys().map(function (c) {
                  return c.join('.');
                })).uniq();
                return emberComputedProperty(fn, chains);
              } else {
                return fn;
              }
            };
          }()
        ],
        [
          CS.Rest,
          function (param$) {
            var expression;
            expression = param$.expression;
            return {
              rest: true,
              expression: expression,
              isExpression: true,
              isStatement: true
            };
          }
        ],
        [
          CS.Mixin,
          function (param$) {
            var body, cache$2, compile, createArgs, iife, mixinExpr, mixins, name, nameAssignee;
            {
              cache$2 = param$;
              nameAssignee = cache$2.nameAssignee;
              name = cache$2.name;
              body = cache$2.body;
              mixins = cache$2.mixins;
              compile = cache$2.compile;
            }
            createArgs = mixins;
            if (body)
              createArgs.push(body);
            mixinExpr = memberAccess(new JS.Identifier('Ember'), 'Mixin');
            iife = new JS.CallExpression(memberAccess(mixinExpr, 'create'), createArgs);
            if (null != nameAssignee) {
              return assignment(nameAssignee, iife);
            } else {
              return iife;
            }
          }
        ],
        [
          CS.Class,
          function (param$) {
            var args, body, cache$2, compile, ctor, extendArgs, iife, mixins, name, nameAssignee, params, parent, parentExpr, parentRef;
            {
              cache$2 = param$;
              nameAssignee = cache$2.nameAssignee;
              parent = cache$2.parent;
              name = cache$2.name;
              ctor = cache$2.ctor;
              body = cache$2.body;
              mixins = cache$2.mixins;
              compile = cache$2.compile;
            }
            args = [];
            params = [];
            parentRef = genSym('super');
            extendArgs = mixins;
            if (body)
              extendArgs.push(body);
            parentExpr = null != parent ? parent : memberAccess(new JS.Identifier('Ember'), 'Object');
            iife = new JS.CallExpression(memberAccess(parentExpr, 'extend'), extendArgs);
            if (null != nameAssignee) {
              return assignment(nameAssignee, iife);
            } else {
              return iife;
            }
          }
        ],
        [
          CS.Constructor,
          function (param$) {
            var expression, tmpName;
            expression = param$.expression;
            tmpName = genSym('class');
            if (this.expression['instanceof'](CS.Functions)) {
              return new JS.FunctionDeclaration(tmpName, expression.params, forceBlock(expression.body));
            } else {
              return new JS.FunctionDeclaration(tmpName, [], new JS.BlockStatement([]));
            }
          }
        ],
        [
          CS.ClassProtoAssignOp,
          function (param$) {
            var assignee, cache$2, compile, expression, protoMember;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (this.expression['instanceof'](CS.BoundFunction)) {
              return compile(new CS.ClassProtoAssignOp(this.assignee, new CS.Function(this.expression.parameters, this.expression.body)));
            } else {
              protoMember = memberAccess(memberAccess(new JS.ThisExpression, 'prototype'), this.assignee.data);
              return new JS.Property(protoMember, expression);
            }
          }
        ],
        [
          CS.AssignOp,
          function (param$) {
            var ancestry, assignee, cache$2, expression;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              ancestry = cache$2.ancestry;
            }
            return assignment(assignee, expression, usedAsExpression(this, ancestry));
          }
        ],
        [
          CS.CompoundAssignOp,
          function (param$) {
            var assignee, cache$2, condition, expression, inScope, op;
            {
              cache$2 = param$;
              assignee = cache$2.assignee;
              expression = cache$2.expression;
              inScope = cache$2.inScope;
            }
            op = function () {
              switch (this.op) {
              case CS.LogicalAndOp.prototype.className:
                return '&&';
              case CS.LogicalOrOp.prototype.className:
                return '||';
              case CS.ExistsOp.prototype.className:
                return '?';
              case CS.BitOrOp.prototype.className:
                return '|';
              case CS.BitXorOp.prototype.className:
                return '^';
              case CS.BitAndOp.prototype.className:
                return '&';
              case CS.LeftShiftOp.prototype.className:
                return '<<';
              case CS.SignedRightShiftOp.prototype.className:
                return '>>';
              case CS.UnsignedRightShiftOp.prototype.className:
                return '>>>';
              case CS.PlusOp.prototype.className:
                return '+';
              case CS.SubtractOp.prototype.className:
                return '-';
              case CS.MultiplyOp.prototype.className:
                return '*';
              case CS.DivideOp.prototype.className:
                return '/';
              case CS.RemOp.prototype.className:
                return '%';
              case CS.ExpOp.prototype.className:
                return '**';
              default:
                throw new Error('Unrecognised compound assignment operator');
              }
            }.call(this);
            if ((op === '&&' || op === '||' || op === '?') && assignee['instanceof'](JS.Identifier) && !in$(assignee.name, inScope))
              throw new Error('the variable "' + assignee.name + '" can\'t be assigned with ?= because it has not been defined.');
            switch (op) {
            case '&&':
            case '||':
              return new JS.LogicalExpression(op, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
            case '?':
              condition = new JS.BinaryExpression('!=', new JS.Literal(null), assignee);
              return new JS.ConditionalExpression(condition, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
            case '**':
              return new JS.AssignmentExpression('=', assignee, helpers.exp(assignee, expr(expression)));
            default:
              return new JS.AssignmentExpression('' + op + '=', assignee, expr(expression));
            }
          }
        ],
        [
          CS.ChainedComparisonOp,
          function (param$) {
            var cache$2, compile, expression, left, lhs;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (!this.expression.left['instanceof'](CS.ComparisonOps))
              return expression;
            left = expression.left.right;
            lhs = compile(new CS.ChainedComparisonOp(this.expression.left));
            if (needsCaching(this.expression.left.right)) {
              left = genSym('cache');
              if (this.expression.left.left['instanceof'](CS.ComparisonOps)) {
                lhs.right.right = new JS.AssignmentExpression('=', left, lhs.right.right);
              } else {
                lhs.right = new JS.AssignmentExpression('=', left, lhs.right);
              }
            }
            return new JS.LogicalExpression('&&', lhs, new JS.BinaryExpression(expression.operator, left, expression.right));
          }
        ],
        [
          CS.FunctionApplication,
          function (param$) {
            var args, cache$2, compile, context, lhs;
            var fn;
            {
              cache$2 = param$;
              fn = cache$2['function'];
              args = cache$2['arguments'];
              compile = cache$2.compile;
            }
            if (any(args, function (m) {
                return m.spread;
              })) {
              lhs = this['function'];
              context = new CS.Null;
              if (needsCaching(this['function'])) {
                context = new CS.GenSym('cache');
                lhs = this['function']['instanceof'](CS.StaticMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].memberName) : this['function']['instanceof'](CS.DynamicMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].indexingExpr) : new CS.AssignOp(context, lhs);
              } else if (lhs['instanceof'](CS.MemberAccessOps)) {
                context = lhs.expression;
              }
              if (this['function']['instanceof'](CS.ProtoMemberAccessOp, CS.DynamicProtoMemberAccessOp)) {
                context = new CS.MemberAccessOp(context, 'prototype');
              } else if (this['function']['instanceof'](CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp)) {
                context = new CS.SoakedMemberAccessOp(context, 'prototype');
              }
              return compile(new CS.FunctionApplication(new CS.MemberAccessOp(lhs, 'apply'), [
                context,
                new CS.ArrayInitialiser(this['arguments'])
              ]));
            } else if (hasSoak(this)) {
              return compile(generateSoak(this));
            } else {
              return new JS.CallExpression(expr(fn), map(args, expr));
            }
          }
        ],
        [
          CS.SoakedFunctionApplication,
          function (param$) {
            var compile;
            compile = param$.compile;
            return compile(generateSoak(this));
          }
        ],
        [
          CS.NewOp,
          function (param$) {
            var args, cache$2, compile, ctor;
            {
              cache$2 = param$;
              ctor = cache$2.ctor;
              args = cache$2['arguments'];
              compile = cache$2.compile;
            }
            if (any(args, function (m) {
                return m.spread;
              })) {
              return helpers.construct(ctor, compile(new CS.ArrayInitialiser(this['arguments'])));
            } else {
              return new JS.NewExpression(ctor, map(args, expr));
            }
          }
        ],
        [
          CS.HeregExp,
          function (param$) {
            var args, expression, flag, flags;
            expression = param$.expression;
            args = [expression];
            if (flags = function (accum$) {
                for (var cache$2 = [
                      'g',
                      'i',
                      'm',
                      'y'
                    ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
                  flag = cache$2[i$];
                  if (!this.flags[flag])
                    continue;
                  accum$.push(flag);
                }
                return accum$;
              }.call(this, []).join(''))
              args.push(new JS.Literal(flags));
            return new JS.NewExpression(new JS.Identifier('RegExp'), args);
          }
        ],
        [
          CS.RegExp,
          function () {
            var flag, flags, re;
            flags = function (accum$) {
              for (var cache$2 = [
                    'g',
                    'i',
                    'm',
                    'y'
                  ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
                flag = cache$2[i$];
                if (!this.flags[flag])
                  continue;
                accum$.push(flag);
              }
              return accum$;
            }.call(this, []).join('');
            re = new RegExp(this.data, flags);
            return new JS.Literal(re);
          }
        ],
        [
          CS.ConcatOp,
          function (param$) {
            var ancestry, cache$2, left, leftmost, plusOp, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
              ancestry = cache$2.ancestry;
            }
            plusOp = new JS.BinaryExpression('+', expr(left), expr(right));
            if (!ancestry[0]['instanceof'](CS.ConcatOp)) {
              leftmost = plusOp;
              while (null != (null != leftmost.left ? leftmost.left.left : void 0)) {
                leftmost = leftmost.left;
              }
              if (!(leftmost.left['instanceof'](JS.Literal) && 'string' === typeof leftmost.left.value))
                leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
            }
            return plusOp;
          }
        ],
        [
          CS.MemberAccessOp,
          CS.SoakedMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, parent;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            parent = arguments[0].ancestry[0];
            this.isFunctionContext = parent['instanceof'](CS.FunctionApplications) && parent['function'] === this;
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else if (this.isAssignment || this.isFunctionContext || expression['instanceof'](JS.Literal) || parent['instanceof'](CS.DeleteOp) || expression.name === 'Ember') {
              return memberAccess(expression, this.memberName);
            } else {
              return helpers.get(expression, new JS.Literal(this.memberName));
            }
          }
        ],
        [
          CS.NativeMemberAccessOp,
          function (param$) {
            var access, cache$2, compile, expression, offset;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              access = memberAccess(expression, this.memberName);
              if (this.raw) {
                access.property.raw = this.memberName;
                access.property.line = this.line;
                offset = this.raw.length - this.memberName.length;
                access.property.column = this.column + offset - 1;
                access.property.offset = this.offset + offset - 1;
                this.column += this.expression.raw.length;
                this.offset += this.expression.raw.length;
              }
              return access;
            }
          }
        ],
        [
          CS.ProtoMemberAccessOp,
          CS.SoakedProtoMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return memberAccess(memberAccess(expression, 'prototype'), this.memberName);
            }
          }
        ],
        [
          CS.DynamicMemberAccessOp,
          CS.SoakedDynamicMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, indexingExpr;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              indexingExpr = cache$2.indexingExpr;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return dynamicMemberAccess(expression, indexingExpr);
            }
          }
        ],
        [
          CS.DynamicProtoMemberAccessOp,
          CS.SoakedDynamicProtoMemberAccessOp,
          function (param$) {
            var cache$2, compile, expression, indexingExpr;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              indexingExpr = cache$2.indexingExpr;
              compile = cache$2.compile;
            }
            if (hasSoak(this)) {
              return expr(compile(generateSoak(this)));
            } else {
              return dynamicMemberAccess(memberAccess(expression, 'prototype'), indexingExpr);
            }
          }
        ],
        [
          CS.Slice,
          function (param$) {
            var args, cache$2, expression, left, right;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              left = cache$2.left;
              right = cache$2.right;
            }
            args = null != left ? [left] : null != right ? [new JS.Literal(0)] : [];
            if (null != right)
              args.push(this.isInclusive ? right['instanceof'](JS.Literal) && typeof right.data === 'number' ? new JS.Literal(right.data + 1) : new JS.LogicalExpression('||', new JS.BinaryExpression('+', new JS.UnaryExpression('+', right), new JS.Literal(1)), new JS.Literal(9e9)) : right);
            return new JS.CallExpression(memberAccess(expression, 'slice'), args);
          }
        ],
        [
          CS.ExistsOp,
          function (param$) {
            var ancestry, cache$2, condition, e, inScope, node;
            var left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
              ancestry = cache$2.ancestry;
              inScope = cache$2.inScope;
            }
            left = expr(left);
            right = expr(right);
            e = needsCaching(this.left) ? genSym('cache') : left;
            condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
            if (e['instanceof'](JS.Identifier) && !in$(e.name, inScope))
              condition = new JS.LogicalExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
            node = new JS.ConditionalExpression(condition, e, right);
            if (e === left) {
              return node;
            } else {
              return new JS.SequenceExpression([
                new JS.AssignmentExpression('=', e, left),
                node
              ]);
            }
          }
        ],
        [
          CS.UnaryExistsOp,
          function (param$) {
            var cache$2, expression, inScope, nullTest, typeofTest;
            {
              cache$2 = param$;
              expression = cache$2.expression;
              inScope = cache$2.inScope;
            }
            nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
            if (expression['instanceof'](JS.Identifier) && !in$(expression.name, inScope)) {
              typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
              return new JS.LogicalExpression('&&', typeofTest, nullTest);
            } else {
              return nullTest;
            }
          }
        ],
        [
          CS.DoOp,
          function () {
            var deriveArgsFromParams;
            deriveArgsFromParams = function (params) {
              var args, index, param;
              return args = function (accum$) {
                for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                  param = params[i$];
                  index = i$;
                  accum$.push(function () {
                    switch (false) {
                    case !param['instanceof'](CS.DefaultParam):
                      params[index] = param.param;
                      return param['default'];
                    case !param['instanceof'](CS.Identifier, CS.MemberAccessOp):
                      return param;
                    default:
                      return helpers.undef();
                    }
                  }.call(this));
                }
                return accum$;
              }.call(this, []);
            };
            return function (param$) {
              var args, cache$2, compile, expression;
              {
                cache$2 = param$;
                expression = cache$2.expression;
                compile = cache$2.compile;
              }
              args = [];
              if (this.expression['instanceof'](CS.AssignOp) && this.expression.expression['instanceof'](CS.Functions)) {
                args = deriveArgsFromParams(this.expression.expression.parameters);
              } else if (this.expression['instanceof'](CS.Functions)) {
                args = deriveArgsFromParams(this.expression.parameters);
              }
              return compile(new CS.FunctionApplication(this.expression, args));
            };
          }()
        ],
        [
          CS.Return,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.ReturnStatement(expr(e));
          }
        ],
        [
          CS.Break,
          function () {
            return new JS.BreakStatement;
          }
        ],
        [
          CS.Continue,
          function () {
            return new JS.ContinueStatement;
          }
        ],
        [
          CS.Debugger,
          function () {
            return new JS.DebuggerStatement;
          }
        ],
        [
          CS.ExpOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return helpers.exp(expr(left), expr(right));
          }
        ],
        [
          CS.DivideOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('/', expr(left), expr(right));
          }
        ],
        [
          CS.MultiplyOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('*', expr(left), expr(right));
          }
        ],
        [
          CS.RemOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('%', expr(left), expr(right));
          }
        ],
        [
          CS.PlusOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('+', expr(left), expr(right));
          }
        ],
        [
          CS.SubtractOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('-', expr(left), expr(right));
          }
        ],
        [
          CS.OfOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('in', expr(left), expr(right));
          }
        ],
        [
          CS.InOp,
          function (param$) {
            var cache$2, comparisons, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            if (right['instanceof'](JS.ArrayExpression) && right.elements.length < 5) {
              switch (right.elements.length) {
              case 0:
                if (needsCaching(this.left)) {
                  return new JS.SequenceExpression([
                    left,
                    new JS.Literal(false)
                  ]);
                } else {
                  return new JS.Literal(false);
                }
              case 1:
                return new JS.BinaryExpression('===', left, right.elements[0]);
              default:
                if (needsCaching(this.left)) {
                  return helpers['in'](expr(left), expr(right));
                } else {
                  comparisons = map(right.elements, function (e) {
                    return new JS.BinaryExpression('===', left, e);
                  });
                  return foldl1(comparisons, function (l, r) {
                    return new JS.LogicalExpression('||', l, r);
                  });
                }
              }
            } else {
              return helpers['in'](expr(left), expr(right));
            }
          }
        ],
        [
          CS.ExtendsOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return helpers['extends'](expr(left), expr(right));
          }
        ],
        [
          CS.InstanceofOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('instanceof', expr(left), expr(right));
          }
        ],
        [
          CS.LogicalAndOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.LogicalExpression('&&', expr(left), expr(right));
          }
        ],
        [
          CS.LogicalOrOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.LogicalExpression('||', expr(left), expr(right));
          }
        ],
        [
          CS.EQOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('===', expr(left), expr(right));
          }
        ],
        [
          CS.NEQOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('!==', expr(left), expr(right));
          }
        ],
        [
          CS.GTEOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>=', expr(left), expr(right));
          }
        ],
        [
          CS.GTOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>', expr(left), expr(right));
          }
        ],
        [
          CS.LTEOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<=', expr(left), expr(right));
          }
        ],
        [
          CS.LTOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<', expr(left), expr(right));
          }
        ],
        [
          CS.BitAndOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('&', expr(left), expr(right));
          }
        ],
        [
          CS.BitOrOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('|', expr(left), expr(right));
          }
        ],
        [
          CS.BitXorOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('^', expr(left), expr(right));
          }
        ],
        [
          CS.LeftShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('<<', expr(left), expr(right));
          }
        ],
        [
          CS.SignedRightShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>>', expr(left), expr(right));
          }
        ],
        [
          CS.UnsignedRightShiftOp,
          function (param$) {
            var cache$2, left, right;
            {
              cache$2 = param$;
              left = cache$2.left;
              right = cache$2.right;
            }
            return new JS.BinaryExpression('>>>', expr(left), expr(right));
          }
        ],
        [
          CS.PreDecrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('--', true, expr(e));
          }
        ],
        [
          CS.PreIncrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('++', true, expr(e));
          }
        ],
        [
          CS.PostDecrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('--', false, expr(e));
          }
        ],
        [
          CS.PostIncrementOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UpdateExpression('++', false, expr(e));
          }
        ],
        [
          CS.UnaryPlusOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('+', expr(e));
          }
        ],
        [
          CS.UnaryNegateOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('-', expr(e));
          }
        ],
        [
          CS.LogicalNotOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('!', expr(e));
          }
        ],
        [
          CS.BitNotOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('~', expr(e));
          }
        ],
        [
          CS.TypeofOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('typeof', expr(e));
          }
        ],
        [
          CS.DeleteOp,
          function (param$) {
            var e;
            e = param$.expression;
            return new JS.UnaryExpression('delete', expr(e));
          }
        ],
        [
          CS.Identifier,
          function () {
            return new JS.Identifier(this.data);
          }
        ],
        [
          CS.GenSym,
          function () {
            var memos, symbols;
            symbols = [];
            memos = [];
            return function () {
              var memo;
              if (in$(this, symbols)) {
                return memos[symbols.indexOf(this)];
              } else {
                symbols.push(this);
                memos.push(memo = genSym(this.data));
                return memo;
              }
            };
          }()
        ],
        [
          CS.Bool,
          CS.Int,
          CS.Float,
          CS.String,
          function () {
            return new JS.Literal(this.data);
          }
        ],
        [
          CS.Null,
          function () {
            return new JS.Literal(null);
          }
        ],
        [
          CS.Undefined,
          function () {
            return helpers.undef();
          }
        ],
        [
          CS.This,
          function () {
            return new JS.ThisExpression;
          }
        ],
        [
          CS.Super,
          function () {
            return memberAccess(new JS.ThisExpression, '_super');
          }
        ],
        [
          CS.JavaScript,
          function () {
            var js;
            js = new JS.CallExpression(new JS.Identifier('eval'), [new JS.Literal(this.data)]);
            js.verbatim = this.data;
            return js;
          }
        ],
        [
          CS.Volatile,
          CS.Computed,
          CS.Observes,
          function () {
            return new JS.EmptyStatement;
          }
        ]
      ];
      function Compiler() {
        var cache$2, ctor, ctors, handler, size$;
        this.rules = {};
        for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
          {
            cache$2 = defaultRules[i$];
            size$ = cache$2.length;
            ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
            handler = cache$2[size$ - 1];
          }
          for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
            ctor = ctors[i$1];
            this.addRule(ctor, handler);
          }
        }
      }
      Compiler.prototype.addRule = function (ctor, handler) {
        this.rules[ctor.prototype.className] = handler;
        return this;
      };
      Compiler.prototype.compile = function () {
        var defaultRule, generateSymbols, walk;
        walk = function (fn, inScope, ancestry, options) {
          var child, childName, children, jsNode, member;
          if ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Function, CS.BoundFunction, CS.ComputedProperty) : void 0) && this === ancestry[0].body)
            inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
          ancestry.unshift(this);
          children = {};
          for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
            childName = this.childNodes[i$];
            if (!(null != this[childName]))
              continue;
            children[childName] = in$(childName, this.listMembers) ? function (accum$) {
              for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
                member = this[childName][i$1];
                jsNode = walk.call(member, fn, inScope, ancestry);
                inScope = union(inScope, envEnrichments(member, inScope));
                accum$.push(jsNode);
              }
              return accum$;
            }.call(this, []) : (child = this[childName], jsNode = walk.call(child, fn, inScope, ancestry), inScope = union(inScope, envEnrichments(child, inScope)), jsNode);
          }
          children.inScope = inScope;
          children.ancestry = ancestry;
          children.options = options;
          children.compile = function (node) {
            return walk.call(node, fn, inScope, ancestry);
          };
          ancestry.shift();
          jsNode = fn.call(this, children);
          jsNode.raw = this.raw;
          jsNode.line = this.line;
          jsNode.column = this.column - 1;
          jsNode.offset = this.offset;
          return jsNode;
        };
        generateSymbols = function () {
          var format, generatedSymbols, generateName;
          generatedSymbols = {};
          format = function (pre, counter) {
            var cache$2, div, mod;
            if (pre) {
              return '' + pre + '$' + (counter || '');
            } else if (counter < 26) {
              return String.fromCharCode(97 + counter);
            } else {
              cache$2 = divMod(counter, 26);
              div = cache$2[0];
              mod = cache$2[1];
              return format(pre, div - 1) + format(pre, mod);
            }
          };
          generateName = function (node, param$) {
            var cache$2, formatted, nsCounters, usedSymbols;
            {
              cache$2 = param$;
              usedSymbols = cache$2.usedSymbols;
              nsCounters = cache$2.nsCounters;
            }
            if (owns(generatedSymbols, node.uniqueId)) {
              return generatedSymbols[node.uniqueId];
            } else {
              nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
              while (in$(formatted = format(node.ns, nsCounters[node.ns]), usedSymbols)) {
                ++nsCounters[node.ns];
              }
              return generatedSymbols[node.uniqueId] = formatted;
            }
          };
          return generateMutatingWalker(function (state) {
            var alreadyDeclared, cache$2, declaredSymbols, declNames, decls, k, newNode, nsCounters, nsCounters_, params, undeclared, usedSymbols, v;
            state.declaredSymbols = union(state.declaredSymbols, map(declarationsNeeded(this), function (id) {
              return id.name;
            }));
            cache$2 = state;
            declaredSymbols = cache$2.declaredSymbols;
            usedSymbols = cache$2.usedSymbols;
            nsCounters = cache$2.nsCounters;
            newNode = this['instanceof'](JS.GenSym) ? (newNode = new JS.Identifier(generateName(this, state)), usedSymbols.push(newNode.name), newNode) : this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !this.generated ? (params = concatMap(this.params, collectIdentifiers), nsCounters_ = {}, function (accum$) {
              for (k in nsCounters) {
                if (!isOwn$(nsCounters, k))
                  continue;
                v = nsCounters[k];
                accum$.push(nsCounters_[k] = v);
              }
              return accum$;
            }.call(this, []), newNode = generateSymbols(this, {
              declaredSymbols: union(declaredSymbols, params),
              usedSymbols: union(usedSymbols, params),
              nsCounters: nsCounters_
            }), newNode.body = forceBlock(newNode.body), undeclared = map(declarationsNeededRecursive(this.body), function (id) {
              return id.name;
            }), undeclared = difference(undeclared, map(variableDeclarations(this.body), function (id) {
              return id.name;
            })), alreadyDeclared = union(declaredSymbols, concatMap(this.params, collectIdentifiers)), declNames = nub(difference(undeclared, alreadyDeclared)), decls = map(declNames, function (name) {
              return new JS.Identifier(name);
            }), decls.length > 0 ? newNode.body.body.unshift(makeVarDeclaration(decls)) : void 0, newNode) : generateSymbols(this, state);
            state.declaredSymbols = union(declaredSymbols, map(declarationsNeededRecursive(newNode), function (id) {
              return id.name;
            }));
            return newNode;
          });
        }();
        defaultRule = function () {
          throw new Error('compile: Non-exhaustive patterns in case: ' + this.className);
        };
        return function (ast, options) {
          var inScope, jsAST, rules;
          if (null == options)
            options = {};
          if (null != options.bare)
            options.bare;
          else
            options.bare = false;
          rules = this.rules;
          inScope = null != options.inScope ? options.inScope : [];
          jsAST = walk.call(ast, function () {
            return (null != rules[this.className] ? rules[this.className] : defaultRule).apply(this, arguments);
          }, inScope, [], options);
          return generateSymbols(jsAST, {
            declaredSymbols: inScope,
            usedSymbols: union(jsReserved.slice(), collectIdentifiers(jsAST)),
            nsCounters: {}
          });
        };
      }();
      return Compiler;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
  });
  require.define('/src/js-nodes.coffee', function (module, exports, __dirname, __filename) {
    var ArrayExpression, AssignmentExpression, BinaryExpression, BlockStatement, CallExpression, createNode, ctor, difference, exports, FunctionDeclaration, FunctionExpression, GenSym, handleLists, handlePrimitives, Identifier, isStatement, Literal, LogicalExpression, MemberExpression, NewExpression, node, nodeData, Nodes, ObjectExpression, params, Program, SequenceExpression, SwitchCase, SwitchStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclaration;
    difference = require('/src/functional-helpers.coffee', module).difference;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    createNode = function (type, props) {
      return function (super$) {
        extends$(class$, super$);
        function class$() {
          var i, prop;
          for (var i$ = 0, length$ = props.length; i$ < length$; ++i$) {
            prop = props[i$];
            i = i$;
            this[prop] = arguments[i];
          }
        }
        class$.prototype.type = type;
        class$.prototype.childNodes = props;
        return class$;
      }(Nodes);
    };
    this.Nodes = Nodes = function () {
      function Nodes() {
      }
      Nodes.prototype.listMembers = [];
      Nodes.prototype['instanceof'] = function (ctors) {
        var ctor;
        ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
        for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
          ctor = ctors[i$];
          if (!(this.type === ctor.prototype.type))
            continue;
          return true;
        }
        return false;
      };
      Nodes.prototype.toBasicObject = function () {
        var child, obj, p;
        obj = { type: this.type };
        if (null != this.leadingComments)
          obj.leadingComments = this.leadingComments;
        for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
          child = this.childNodes[i$];
          if (in$(child, this.listMembers)) {
            obj[child] = function (accum$) {
              for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
                p = this[child][i$1];
                accum$.push('undefined' !== typeof p && null != p ? p.toBasicObject() : void 0);
              }
              return accum$;
            }.call(this, []);
          } else {
            obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
          }
        }
        if (null != this.line && null != this.column)
          obj.loc = {
            start: {
              line: this.line,
              column: this.column
            }
          };
        if (null != this.offset)
          obj.range = [
            this.offset,
            null != this.raw ? this.offset + this.raw.length : void 0
          ];
        if (null != this.raw)
          obj.raw = this.raw;
        if (null != this.verbatim)
          obj.verbatim = this.verbatim;
        return obj;
      };
      return Nodes;
    }();
    nodeData = [
      [
        'ArrayExpression',
        false,
        ['elements']
      ],
      [
        'AssignmentExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'BinaryExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'BlockStatement',
        true,
        ['body']
      ],
      [
        'BreakStatement',
        true,
        ['label']
      ],
      [
        'CallExpression',
        false,
        [
          'callee',
          'arguments'
        ]
      ],
      [
        'CatchClause',
        true,
        [
          'param',
          'body'
        ]
      ],
      [
        'ConditionalExpression',
        false,
        [
          'test',
          'consequent',
          'alternate'
        ]
      ],
      [
        'ContinueStatement',
        true,
        ['label']
      ],
      [
        'DebuggerStatement',
        true,
        []
      ],
      [
        'DoWhileStatement',
        true,
        [
          'body',
          'test'
        ]
      ],
      [
        'EmptyStatement',
        true,
        []
      ],
      [
        'ExpressionStatement',
        true,
        ['expression']
      ],
      [
        'ForInStatement',
        true,
        [
          'left',
          'right',
          'body'
        ]
      ],
      [
        'ForStatement',
        true,
        [
          'init',
          'test',
          'update',
          'body'
        ]
      ],
      [
        'FunctionDeclaration',
        true,
        [
          'id',
          'params',
          'body'
        ]
      ],
      [
        'FunctionExpression',
        false,
        [
          'id',
          'params',
          'body'
        ]
      ],
      [
        'GenSym',
        false,
        [
          'ns',
          'uniqueId'
        ]
      ],
      [
        'Identifier',
        false,
        ['name']
      ],
      [
        'IfStatement',
        true,
        [
          'test',
          'consequent',
          'alternate'
        ]
      ],
      [
        'LabeledStatement',
        true,
        [
          'label',
          'body'
        ]
      ],
      [
        'Literal',
        false,
        ['value']
      ],
      [
        'LogicalExpression',
        false,
        [
          'operator',
          'left',
          'right'
        ]
      ],
      [
        'MemberExpression',
        false,
        [
          'computed',
          'object',
          'property'
        ]
      ],
      [
        'NewExpression',
        false,
        [
          'callee',
          'arguments'
        ]
      ],
      [
        'ObjectExpression',
        false,
        ['properties']
      ],
      [
        'Program',
        true,
        ['body']
      ],
      [
        'Property',
        true,
        [
          'key',
          'value'
        ]
      ],
      [
        'ReturnStatement',
        true,
        ['argument']
      ],
      [
        'SequenceExpression',
        false,
        ['expressions']
      ],
      [
        'SwitchCase',
        true,
        [
          'test',
          'consequent'
        ]
      ],
      [
        'SwitchStatement',
        true,
        [
          'discriminant',
          'cases'
        ]
      ],
      [
        'ThisExpression',
        false,
        []
      ],
      [
        'ThrowStatement',
        true,
        ['argument']
      ],
      [
        'TryStatement',
        true,
        [
          'block',
          'handlers',
          'finalizer'
        ]
      ],
      [
        'UnaryExpression',
        false,
        [
          'operator',
          'argument'
        ]
      ],
      [
        'UpdateExpression',
        false,
        [
          'operator',
          'prefix',
          'argument'
        ]
      ],
      [
        'VariableDeclaration',
        true,
        [
          'kind',
          'declarations'
        ]
      ],
      [
        'VariableDeclarator',
        true,
        [
          'id',
          'init'
        ]
      ],
      [
        'WhileStatement',
        true,
        [
          'test',
          'body'
        ]
      ],
      [
        'WithStatement',
        true,
        [
          'object',
          'body'
        ]
      ]
    ];
    for (var i$ = 0, length$ = nodeData.length; i$ < length$; ++i$) {
      {
        cache$ = nodeData[i$];
        node = cache$[0];
        isStatement = cache$[1];
        params = cache$[2];
      }
      exports[node] = ctor = createNode(node, params);
      ctor.prototype.isStatement = isStatement;
      ctor.prototype.isExpression = !isStatement;
    }
    cache$1 = exports;
    Program = cache$1.Program;
    BlockStatement = cache$1.BlockStatement;
    Literal = cache$1.Literal;
    Identifier = cache$1.Identifier;
    FunctionExpression = cache$1.FunctionExpression;
    CallExpression = cache$1.CallExpression;
    SequenceExpression = cache$1.SequenceExpression;
    ArrayExpression = cache$1.ArrayExpression;
    BinaryExpression = cache$1.BinaryExpression;
    UnaryExpression = cache$1.UnaryExpression;
    NewExpression = cache$1.NewExpression;
    VariableDeclaration = cache$1.VariableDeclaration;
    ObjectExpression = cache$1.ObjectExpression;
    MemberExpression = cache$1.MemberExpression;
    UpdateExpression = cache$1.UpdateExpression;
    AssignmentExpression = cache$1.AssignmentExpression;
    LogicalExpression = cache$1.LogicalExpression;
    GenSym = cache$1.GenSym;
    FunctionDeclaration = cache$1.FunctionDeclaration;
    VariableDeclaration = cache$1.VariableDeclaration;
    SwitchStatement = cache$1.SwitchStatement;
    SwitchCase = cache$1.SwitchCase;
    TryStatement = cache$1.TryStatement;
    handlePrimitives = function (ctor, primitives) {
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$1 = 0, length$1 = primitives.length; i$1 < length$1; ++i$1) {
          primitive = primitives[i$1];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(AssignmentExpression, ['operator']);
    handlePrimitives(BinaryExpression, ['operator']);
    handlePrimitives(LogicalExpression, ['operator']);
    handlePrimitives(GenSym, [
      'ns',
      'uniqueId'
    ]);
    handlePrimitives(Identifier, ['name']);
    handlePrimitives(Literal, ['value']);
    handlePrimitives(MemberExpression, ['computed']);
    handlePrimitives(UnaryExpression, ['operator']);
    handlePrimitives(UpdateExpression, [
      'operator',
      'prefix'
    ]);
    handlePrimitives(VariableDeclaration, ['kind']);
    handleLists = function (ctor, listProps) {
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayExpression, ['elements']);
    handleLists(BlockStatement, ['body']);
    handleLists(CallExpression, ['arguments']);
    handleLists(FunctionDeclaration, ['params']);
    handleLists(FunctionExpression, ['params']);
    handleLists(NewExpression, ['arguments']);
    handleLists(ObjectExpression, ['properties']);
    handleLists(Program, ['body']);
    handleLists(SequenceExpression, ['expressions']);
    handleLists(SwitchCase, ['consequent']);
    handleLists(SwitchStatement, ['cases']);
    handleLists(TryStatement, ['handlers']);
    handleLists(VariableDeclaration, ['declarations']);
    FunctionDeclaration.prototype.generated = FunctionExpression.prototype.generated = false;
    FunctionDeclaration.prototype.g = FunctionExpression.prototype.g = function () {
      this.generated = true;
      return this;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/functional-helpers.coffee', function (module, exports, __dirname, __filename) {
    var concat, foldl, map, nub, span;
    this.any = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (fn(e))
          return true;
      }
      return false;
    };
    this.all = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (!fn(e))
          return false;
      }
      return true;
    };
    this.foldl = foldl = function (memo, list, fn) {
      var i;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        memo = fn(memo, i);
      }
      return memo;
    };
    this.foldl1 = function (list, fn) {
      return foldl(list[0], list.slice(1), fn);
    };
    this.map = map = function (list, fn) {
      var e;
      return function (accum$) {
        for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
          e = list[i$];
          accum$.push(fn(e));
        }
        return accum$;
      }.call(this, []);
    };
    this.concat = concat = function (list) {
      var cache$;
      return (cache$ = []).concat.apply(cache$, [].slice.call(list));
    };
    this.concatMap = function (list, fn) {
      return concat(map(list, fn));
    };
    this.intersect = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.difference = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.nub = nub = function (list) {
      var i, result;
      result = [];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        if (!!in$(i, result))
          continue;
        result.push(i);
      }
      return result;
    };
    this.union = function (listA, listB) {
      var b;
      return listA.concat(function (accum$) {
        for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          b = cache$[i$];
          if (!!in$(b, listA))
            continue;
          accum$.push(b);
        }
        return accum$;
      }.call(this, []));
    };
    this.flip = function (fn) {
      return function (b, a) {
        return fn.call(this, a, b);
      };
    };
    this.owns = function (hop) {
      return function (a, b) {
        return hop.call(a, b);
      };
    }({}.hasOwnProperty);
    this.span = span = function (list, f) {
      var cache$, ys, zs;
      if (list.length === 0) {
        return [
          [],
          []
        ];
      } else if (f(list[0])) {
        cache$ = span(list.slice(1), f);
        ys = cache$[0];
        zs = cache$[1];
        return [
          [list[0]].concat([].slice.call(ys)),
          zs
        ];
      } else {
        return [
          [],
          list
        ];
      }
    };
    this.divMod = function (a, b) {
      var c, div, mod;
      c = a % b;
      mod = c < 0 ? c + b : c;
      div = Math.floor(a / b);
      return [
        div,
        mod
      ];
    };
    this.partition = function (list, fn) {
      var item, result;
      result = [
        [],
        []
      ];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        item = list[i$];
        result[+!fn(item)].push(item);
      }
      return result;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/nodes.coffee', function (module, exports, __dirname, __filename) {
    var Annotations, ArrayInitialiser, AssignOp, Block, Bool, Class, CompoundAssignOp, ComputedProperty, concat, concatMap, Conditional, createNodes, difference, enumerableMethods, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, MemberAccessOp, Mixin, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, ObjectInitialiserMember, PostDecrementOp, PostIncrementOp, Primitives, Range, RegExp, RegExps, Slice, SoakedMemberAccessOp, StaticMemberAccessOps, Super, Switch, SwitchCase, This, union, While;
    cache$ = require('/src/functional-helpers.coffee', module);
    map = cache$.map;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    nub = cache$.nub;
    union = cache$.union;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    if (!('undefined' !== typeof Ember && null != Ember))
      require('/src/ember-runtime.js', module);
    createNodes = function (subclasses, superclasses) {
      var className, specs;
      if (null == superclasses)
        superclasses = [];
      for (className in subclasses) {
        if (!isOwn$(subclasses, className))
          continue;
        specs = subclasses[className];
        (function (className) {
          var externalCtor$, isCategory, klass, params, superclass;
          superclass = null != superclasses[0] ? superclasses[0] : function () {
          };
          isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
          params = 'undefined' !== typeof specs && null != specs ? function () {
            switch (specs.length) {
            case 0:
              return [];
            case 1:
            case 2:
              return specs[0];
            }
          }.call(this) : null;
          if (null != params)
            params;
          else
            params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
          klass = function (super$) {
            extends$(class$, super$);
            externalCtor$ = isCategory ? function () {
            } : function () {
              var i, param;
              for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                param = params[i$];
                i = i$;
                this[param] = arguments[i];
              }
              if (null != this.initialise)
                this.initialise.apply(this, arguments);
              return this;
            };
            function class$() {
              return externalCtor$.apply(this, arguments);
            }
            class$.prototype.className = className;
            class$.superclasses = superclasses;
            return class$;
          }(superclass);
          if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
            klass.prototype.childNodes = specs[0];
          if (isCategory)
            createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
          return exports[className] = klass;
        }(className));
      }
    };
    createNodes({
      Nodes: [
        [],
        {
          BinOps: [
            [
              'left',
              'right'
            ],
            {
              AssignOps: [
                [
                  'assignee',
                  'expression'
                ],
                {
                  AssignOp: null,
                  ClassProtoAssignOp: null,
                  CompoundAssignOp: [[
                      'op',
                      'assignee',
                      'expression'
                    ]]
                }
              ],
              BitOps: [
                null,
                {
                  BitAndOp: null,
                  BitOrOp: null,
                  BitXorOp: null,
                  LeftShiftOp: null,
                  SignedRightShiftOp: null,
                  UnsignedRightShiftOp: null
                }
              ],
              ComparisonOps: [
                null,
                {
                  EQOp: null,
                  GTEOp: null,
                  GTOp: null,
                  LTEOp: null,
                  LTOp: null,
                  NEQOp: null
                }
              ],
              ConcatOp: null,
              ExistsOp: null,
              ExtendsOp: null,
              InOp: null,
              InstanceofOp: null,
              LogicalOps: [
                null,
                {
                  LogicalAndOp: null,
                  LogicalOrOp: null
                }
              ],
              MathsOps: [
                null,
                {
                  ExpOp: null,
                  DivideOp: null,
                  MultiplyOp: null,
                  RemOp: null,
                  SubtractOp: null
                }
              ],
              OfOp: null,
              PlusOp: null,
              Range: [[
                  'isInclusive',
                  'left',
                  'right'
                ]],
              SeqOp: null
            }
          ],
          Statements: [
            [],
            {
              Break: null,
              Continue: null,
              Debugger: null,
              Return: [['expression']],
              Throw: [['expression']]
            }
          ],
          UnaryOps: [
            ['expression'],
            {
              BitNotOp: null,
              DeleteOp: null,
              DoOp: null,
              LogicalNotOp: null,
              NewOp: [[
                  'ctor',
                  'arguments'
                ]],
              PreDecrementOp: null,
              PreIncrementOp: null,
              PostDecrementOp: null,
              PostIncrementOp: null,
              TypeofOp: null,
              UnaryExistsOp: null,
              UnaryNegateOp: null,
              UnaryPlusOp: null
            }
          ],
          MemberAccessOps: [
            null,
            {
              StaticMemberAccessOps: [
                [
                  'expression',
                  'memberName'
                ],
                {
                  MemberAccessOp: null,
                  NativeMemberAccessOp: null,
                  ProtoMemberAccessOp: null,
                  SoakedMemberAccessOp: null,
                  SoakedProtoMemberAccessOp: null
                }
              ],
              DynamicMemberAccessOps: [
                [
                  'expression',
                  'indexingExpr'
                ],
                {
                  DynamicMemberAccessOp: null,
                  DynamicProtoMemberAccessOp: null,
                  SoakedDynamicMemberAccessOp: null,
                  SoakedDynamicProtoMemberAccessOp: null
                }
              ]
            }
          ],
          ChainedComparisonOp: [['expression']],
          FunctionApplications: [
            [
              'function',
              'arguments'
            ],
            {
              FunctionApplication: null,
              SoakedFunctionApplication: null
            }
          ],
          Super: null,
          Program: [['body']],
          Block: [['statements']],
          Conditional: [[
              'condition',
              'consequent',
              'alternate'
            ]],
          ForIn: [[
              'valAssignee',
              'keyAssignee',
              'target',
              'step',
              'filter',
              'body'
            ]],
          ForOf: [[
              'isOwn',
              'keyAssignee',
              'valAssignee',
              'target',
              'filter',
              'body'
            ]],
          Switch: [[
              'expression',
              'cases',
              'alternate'
            ]],
          SwitchCase: [[
              'conditions',
              'consequent'
            ]],
          Try: [[
              'body',
              'catchAssignee',
              'catchBody',
              'finallyBody'
            ]],
          While: [[
              'condition',
              'body'
            ]],
          ArrayInitialiser: [['members']],
          ObjectInitialiser: [['members']],
          ObjectInitialiserMember: [[
              'key',
              'expression',
              'annotations'
            ]],
          Mixin: [[
              'nameAssignee',
              'body',
              'mixins'
            ]],
          Class: [[
              'nameAssignee',
              'parent',
              'ctor',
              'body',
              'mixins',
              'boundMembers'
            ]],
          Constructor: [['expression']],
          Functions: [
            [
              'parameters',
              'body'
            ],
            {
              Function: null,
              BoundFunction: null,
              ComputedProperty: null
            }
          ],
          DefaultParam: [[
              'param',
              'default'
            ]],
          Annotations: [
            ['parameters'],
            {
              Volatile: null,
              Computed: null,
              Observes: null
            }
          ],
          Identifiers: [
            ['data'],
            {
              Identifier: null,
              GenSym: null
            }
          ],
          Null: null,
          Primitives: [
            ['data'],
            {
              Bool: null,
              JavaScript: null,
              Numbers: [
                null,
                {
                  Int: null,
                  Float: null
                }
              ],
              String: null
            }
          ],
          RegExps: [
            null,
            {
              RegExp: [[
                  'data',
                  'flags'
                ]],
              HeregExp: [[
                  'expression',
                  'flags'
                ]]
            }
          ],
          This: null,
          Undefined: null,
          Slice: [[
              'expression',
              'isInclusive',
              'left',
              'right'
            ]],
          Rest: [['expression']],
          Spread: [['expression']]
        }
      ]
    });
    cache$1 = exports;
    Nodes = cache$1.Nodes;
    Primitives = cache$1.Primitives;
    CompoundAssignOp = cache$1.CompoundAssignOp;
    StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
    Range = cache$1.Range;
    ArrayInitialiser = cache$1.ArrayInitialiser;
    ObjectInitialiser = cache$1.ObjectInitialiser;
    NegatedConditional = cache$1.NegatedConditional;
    Conditional = cache$1.Conditional;
    Identifier = cache$1.Identifier;
    ForOf = cache$1.ForOf;
    Functions = cache$1.Functions;
    While = cache$1.While;
    Mixin = cache$1.Mixin;
    Class = cache$1.Class;
    Block = cache$1.Block;
    NewOp = cache$1.NewOp;
    Bool = cache$1.Bool;
    FunctionApplications = cache$1.FunctionApplications;
    RegExps = cache$1.RegExps;
    RegExp = cache$1.RegExp;
    HeregExp = cache$1.HeregExp;
    Super = cache$1.Super;
    Slice = cache$1.Slice;
    Switch = cache$1.Switch;
    Identifiers = cache$1.Identifiers;
    SwitchCase = cache$1.SwitchCase;
    GenSym = cache$1.GenSym;
    ComputedProperty = cache$1.ComputedProperty;
    ObjectInitialiserMember = cache$1.ObjectInitialiserMember;
    Annotations = cache$1.Annotations;
    PostIncrementOp = cache$1.PostIncrementOp;
    PostDecrementOp = cache$1.PostDecrementOp;
    MemberAccessOp = cache$1.MemberAccessOp;
    This = cache$1.This;
    AssignOp = cache$1.AssignOp;
    SoakedMemberAccessOp = cache$1.SoakedMemberAccessOp;
    Nodes.fromBasicObject = function (obj) {
      return exports[obj.type].fromBasicObject(obj);
    };
    Nodes.prototype.listMembers = [];
    Nodes.prototype.toBasicObject = function () {
      var child, obj, p;
      obj = { type: this.className };
      if (null != this.line)
        obj.line = this.line;
      if (null != this.column)
        obj.column = this.column;
      if (null != this.raw) {
        obj.raw = this.raw;
        if (null != this.offset)
          obj.range = [
            this.offset,
            this.offset + this.raw.length
          ];
      }
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          obj[child] = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.toBasicObject());
            }
            return accum$;
          }.call(this, []);
        } else {
          obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
        }
      }
      return obj;
    };
    Nodes.prototype.fold = function (memo, fn) {
      var child, p;
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          memo = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.fold(memo, fn));
            }
            return accum$;
          }.call(this, []);
        } else {
          memo = this[child].fold(memo, fn);
        }
      }
      return fn(memo, this);
    };
    Nodes.prototype.clone = function () {
      var ctor, k, n, v;
      ctor = function () {
      };
      ctor.prototype = this.constructor.prototype;
      n = new ctor;
      for (k in this) {
        if (!isOwn$(this, k))
          continue;
        v = this[k];
        n[k] = v;
      }
      return n;
    };
    Nodes.prototype['instanceof'] = function (ctors) {
      var ctor, superclasses;
      ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      superclasses = map(this.constructor.superclasses, function (c) {
        return c.prototype.className;
      });
      for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
        ctor = ctors[i$];
        if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
          continue;
        return true;
      }
      return false;
    };
    Nodes.prototype.r = function (param$) {
      this.raw = param$;
      return this;
    };
    Nodes.prototype.p = function (param$, param$1, param$2) {
      this.line = param$;
      this.column = param$1;
      this.offset = param$2;
      return this;
    };
    Nodes.prototype.generated = false;
    Nodes.prototype.g = function () {
      this.generated = true;
      return this;
    };
    handlePrimitives = function (ctor, primitives) {
      primitives = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
          primitive = primitives[i$];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(Class, 'boundMembers');
    handlePrimitives(CompoundAssignOp, 'op');
    handlePrimitives(ForOf, 'isOwn');
    handlePrimitives(HeregExp, 'flags');
    handlePrimitives(Identifiers, 'data');
    handlePrimitives(Primitives, 'data');
    handlePrimitives(Range, 'isInclusive');
    handlePrimitives(RegExp, 'data', 'flags');
    handlePrimitives(Slice, 'isInclusive');
    handlePrimitives(StaticMemberAccessOps, 'memberName');
    handlePrimitives(ComputedProperty, 'chains');
    handlePrimitives(ObjectInitialiserMember, 'annotations');
    handlePrimitives(Annotations, 'parameters');
    handleLists = function (ctor, listProps) {
      listProps = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayInitialiser, 'members');
    handleLists(Block, 'statements');
    handleLists(Functions, 'parameters');
    handleLists(FunctionApplications, 'arguments');
    handleLists(NewOp, 'arguments');
    handleLists(ObjectInitialiser, 'members');
    handleLists(Super, 'arguments');
    handleLists(Switch, 'cases');
    handleLists(SwitchCase, 'conditions');
    handleLists(Class, 'mixins');
    handleLists(Mixin, 'mixins');
    Block.wrap = function (s) {
      return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
    };
    Class.prototype.initialise = function () {
      if (null != this.boundMembers)
        this.boundMembers;
      else
        this.boundMembers = [];
      this.name = new GenSym('class');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Class.prototype.childNodes.push('name');
    Mixin.prototype.initialise = function () {
      this.name = new GenSym('mixin');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Mixin.prototype.childNodes.push('name');
    ObjectInitialiser.prototype.keys = function () {
      return map(this.members, function (m) {
        return m.key;
      });
    };
    ObjectInitialiser.prototype.vals = function () {
      return map(this.members, function (m) {
        return m.expression;
      });
    };
    RegExps.prototype.initialise = function (_, flags) {
      var flag;
      this.flags = {};
      for (var cache$2 = [
            'g',
            'i',
            'm',
            'y'
          ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
        flag = cache$2[i$];
        this.flags[flag] = in$(flag, flags);
      }
    };
    PostIncrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    PostDecrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    Nodes.prototype.dependentKeys = function (scope) {
      var chains, child, childName, member;
      if (null == scope)
        scope = {};
      chains = [];
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            chains = chains.concat(member.dependentKeys(scope));
          }
        } else {
          child = this[childName];
          chains = chains.concat(child.dependentKeys(scope));
        }
      }
      return chains;
    };
    This.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return [[]];
    };
    MemberAccessOp.prototype.dependentKeys = function (scope) {
      var memberName;
      if (null == scope)
        scope = {};
      memberName = this.memberName;
      return this.expression.dependentKeys(scope).map(function (c) {
        if (!(memberName === 'constructor'))
          c.push(memberName);
        return c;
      });
    };
    SoakedMemberAccessOp.prototype.dependentKeys = MemberAccessOp.prototype.dependentKeys;
    enumerableMethods = Ember.Set.create();
    enumerableMethods.addObjects(Ember.Enumerable.keys());
    enumerableMethods.addObjects(Ember.Array.keys());
    enumerableMethods.addObjects(Ember.MutableArray.keys());
    enumerableMethods.addObjects(Ember.MutableEnumerable.keys());
    FunctionApplications.prototype.dependentKeys = function (scope) {
      var argument, res;
      if (null == scope)
        scope = {};
      res = this['function'].dependentKeys(scope);
      if (this['function']['instanceof'](MemberAccessOp) || this['function']['instanceof'](SoakedMemberAccessOp)) {
        res = res.map(function (c) {
          c.pop();
          return c;
        });
        if (enumerableMethods.contains(this['function'].memberName))
          res = res.map(function (c) {
            c.push('@each');
            return c;
          });
      }
      for (var i$ = 0, length$ = this['arguments'].length; i$ < length$; ++i$) {
        argument = this['arguments'][i$];
        argument.dependentKeys(scope).map(function (c) {
          return res.push(c);
        });
      }
      return res;
    };
    Block.prototype.dependentKeys = function (scope) {
      var key, newScope, res;
      if (null == scope)
        scope = {};
      res = [];
      newScope = Ember.copy(scope);
      for (var i$ = 0, length$ = newScope.length; i$ < length$; ++i$) {
        key = newScope[i$];
        newScope[key] = Ember.copy(newScope[key]);
      }
      this.statements.forEach(function (s) {
        return res = res.concat(s.dependentKeys(scope));
      });
      for (var i$1 = 0, length$1 = scope.length; i$1 < length$1; ++i$1) {
        key = scope[i$1];
        scope[key] = scope[key].concat(newScope[key]);
      }
      return res;
    };
    AssignOp.prototype.dependentKeys = function (scope) {
      var res;
      if (null == scope)
        scope = {};
      res = this.expression.dependentKeys(scope);
      if (this.assignee['instanceof'](Identifier))
        scope[this.assignee.data] = (scope[this.assignee.data] || []).concat(res);
      return res;
    };
    Identifier.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return Ember.copy(scope[this.data]) || [];
    };
    exports.NegatedConditional = function (super$) {
      extends$(NegatedConditional, super$);
      function NegatedConditional() {
        Conditional.apply(this, arguments);
      }
      return NegatedConditional;
    }(Conditional);
    exports.NegatedWhile = function (super$1) {
      extends$(NegatedWhile, super$1);
      function NegatedWhile() {
        While.apply(this, arguments);
      }
      return NegatedWhile;
    }(While);
    exports.Loop = function (super$2) {
      extends$(Loop, super$2);
      function Loop(body) {
        While.call(this, new Bool(true).g(), body);
      }
      return Loop;
    }(While);
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/helpers.coffee', function (module, exports, __dirname, __filename) {
    var beingDeclared, cleanMarkers, colourise, COLOURS, concat, concatMap, CS, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, pointToErrorLocation, SUPPORTS_COLOUR, usedAsExpression, usedAsExpression_;
    cache$ = require('/src/functional-helpers.coffee', module);
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    foldl = cache$.foldl;
    map = cache$.map;
    nub = cache$.nub;
    CS = require('/src/nodes.coffee', module);
    COLOURS = {
      red: '\x1B[31m',
      green: '\x1B[32m',
      yellow: '\x1B[33m',
      blue: '\x1B[34m',
      magenta: '\x1B[35m',
      cyan: '\x1B[36m'
    };
    SUPPORTS_COLOUR = ('undefined' !== typeof process && null != process && null != process.stderr ? process.stderr.isTTY : void 0) && !process.env.NODE_DISABLE_COLORS;
    colourise = function (colour, str) {
      if (SUPPORTS_COLOUR) {
        return '' + COLOURS[colour] + str + '\x1B[39m';
      } else {
        return str;
      }
    };
    this.numberLines = numberLines = function (input, startLine) {
      var currLine, i, line, lines, numbered, pad, padSize;
      if (null == startLine)
        startLine = 1;
      lines = input.split('\n');
      padSize = ('' + (lines.length + startLine - 1)).length;
      numbered = function (accum$) {
        for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
          line = lines[i$];
          i = i$;
          currLine = '' + (i + startLine);
          pad = Array(padSize + 1).join('0').slice(currLine.length);
          accum$.push('' + pad + currLine + ' : ' + lines[i]);
        }
        return accum$;
      }.call(this, []);
      return numbered.join('\n');
    };
    cleanMarkers = function (str) {
      return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
    };
    this.humanReadable = humanReadable = function (str) {
      return str.replace(/\uEFEF/g, '(INDENT)').replace(/\uEFFE/g, '(DEDENT)').replace(/\uEFFF/g, '(TERM)');
    };
    this.formatParserError = function (input, e) {
      var found, message, realColumn, unicode;
      realColumn = cleanMarkers(('' + input.split('\n')[e.line - 1] + '\n').slice(0, e.column)).length;
      if (!(null != e.found))
        return 'Syntax error on line ' + e.line + ', column ' + realColumn + ': unexpected end of input';
      found = JSON.stringify(humanReadable(e.found));
      found = found.replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
      unicode = e.found.charCodeAt(0).toString(16).toUpperCase();
      unicode = '\\u' + '0000'.slice(unicode.length) + unicode;
      message = 'Syntax error on line ' + e.line + ', column ' + realColumn + ": unexpected '" + found + "' (" + unicode + ')';
      return '' + message + '\n' + pointToErrorLocation(input, e.line, realColumn);
    };
    this.pointToErrorLocation = pointToErrorLocation = function (source, line, column, numLinesOfContext) {
      var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
      if (null == numLinesOfContext)
        numLinesOfContext = 3;
      lines = source.split('\n');
      if (!lines[lines.length - 1])
        lines.pop();
      currentLineOffset = line - 1;
      startLine = currentLineOffset - numLinesOfContext;
      if (startLine < 0)
        startLine = 0;
      preLines = lines.slice(startLine, +currentLineOffset + 1 || 9e9);
      preLines[preLines.length - 1] = colourise('yellow', preLines[preLines.length - 1]);
      postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1 || 9e9);
      numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
      preLines = numberedLines.slice(0, preLines.length);
      postLines = numberedLines.slice(preLines.length);
      column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
      padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
      return [].slice.call(preLines).concat(['' + colourise('red', Array(padSize + 1).join('^')) + ' : ' + Array(column).join(' ') + colourise('red', '^')], [].slice.call(postLines)).join('\n');
    };
    this.beingDeclared = beingDeclared = function (assignment) {
      switch (false) {
      case !!(null != assignment):
        return [];
      case !assignment['instanceof'](CS.Identifiers):
        return [assignment.data];
      case !assignment['instanceof'](CS.Rest):
        return beingDeclared(assignment.expression);
      case !assignment['instanceof'](CS.MemberAccessOps):
        return [];
      case !assignment['instanceof'](CS.DefaultParam):
        return beingDeclared(assignment.param);
      case !assignment['instanceof'](CS.ArrayInitialiser):
        return concatMap(assignment.members, beingDeclared);
      case !assignment['instanceof'](CS.ObjectInitialiser):
        return concatMap(assignment.vals(), beingDeclared);
      default:
        throw new Error('beingDeclared: Non-exhaustive patterns in case: ' + assignment.className);
      }
    };
    this.declarationsFor = function (node, inScope) {
      var vars;
      vars = envEnrichments(node, inScope);
      return foldl(new CS.Undefined().g(), vars, function (expr, v) {
        return new CS.AssignOp(new CS.Identifier(v).g(), expr).g();
      });
    };
    usedAsExpression_ = function (ancestors) {
      var grandparent, parent;
      parent = ancestors[0];
      grandparent = ancestors[1];
      switch (false) {
      case !!(null != parent):
        return true;
      case !parent['instanceof'](CS.Program, CS.Mixin, CS.Class):
        return false;
      case !parent['instanceof'](CS.SeqOp):
        return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
      case !(parent['instanceof'](CS.Block) && parent.statements.indexOf(this) !== parent.statements.length - 1):
        return false;
      case !(parent['instanceof'](CS.Functions) && parent.body === this && null != grandparent && grandparent['instanceof'](CS.Constructor)):
        return false;
      default:
        return true;
      }
    };
    this.usedAsExpression = usedAsExpression = function (node, ancestors) {
      return usedAsExpression_.call(node, ancestors);
    };
    envEnrichments_ = function (inScope) {
      var possibilities;
      if (null == inScope)
        inScope = [];
      possibilities = nub(function () {
        switch (false) {
        case !this['instanceof'](CS.AssignOp):
          return concat([
            beingDeclared(this.assignee),
            envEnrichments(this.expression)
          ]);
        case !this['instanceof'](CS.Mixin):
          return concat([
            beingDeclared(this.nameAssignee),
            'undefined' !== typeof name && null != name ? [name] : []
          ]);
        case !this['instanceof'](CS.Class):
          return concat([
            beingDeclared(this.nameAssignee),
            envEnrichments(this.parent)
          ]);
        case !this['instanceof'](CS.ForIn, CS.ForOf):
          return concat([
            beingDeclared(this.keyAssignee),
            beingDeclared(this.valAssignee),
            envEnrichments(this.target),
            envEnrichments(this.step),
            envEnrichments(this.filter),
            envEnrichments(this.body)
          ]);
        case !this['instanceof'](CS.Try):
          return concat([
            beingDeclared(this.catchAssignee),
            envEnrichments(this.body),
            envEnrichments(this.catchBody),
            envEnrichments(this.finallyBody)
          ]);
        case !this['instanceof'](CS.Functions):
          return [];
        default:
          return concatMap(this.childNodes, function (this$) {
            return function (child) {
              if (in$(child, this$.listMembers)) {
                return concatMap(this$[child], function (m) {
                  return envEnrichments(m, inScope);
                });
              } else {
                return envEnrichments(this$[child], inScope);
              }
            };
          }(this));
        }
      }.call(this));
      return difference(possibilities, inScope);
    };
    this.envEnrichments = envEnrichments = function (node, args) {
      args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
      if (null != node) {
        return envEnrichments_.apply(node, args);
      } else {
        return [];
      }
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/optimiser.coffee', function (module, exports, __dirname, __filename) {
    var all, any, beingDeclared, concat, concatMap, CS, declarationsFor, defaultRules, difference, envEnrichments, exports, foldl, foldl1, isFalsey, isTruthy, makeDispatcher, mayHaveSideEffects, union, usedAsExpression;
    cache$ = require('/src/functional-helpers.coffee', module);
    all = cache$.all;
    any = cache$.any;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    foldl = cache$.foldl;
    foldl1 = cache$.foldl1;
    union = cache$.union;
    cache$1 = require('/src/helpers.coffee', module);
    beingDeclared = cache$1.beingDeclared;
    declarationsFor = cache$1.declarationsFor;
    usedAsExpression = cache$1.usedAsExpression;
    envEnrichments = cache$1.envEnrichments;
    CS = require('/src/nodes.coffee', module);
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    makeDispatcher = function (defaultValue, handlers, defaultHandler) {
      var cache$2, ctor, ctors, handler, handlers_, size$;
      if (null == defaultHandler)
        defaultHandler = function () {
        };
      handlers_ = {};
      for (var i$ = 0, length$ = handlers.length; i$ < length$; ++i$) {
        {
          cache$2 = handlers[i$];
          size$ = cache$2.length;
          ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
          handler = cache$2[size$ - 1];
        }
        for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
          ctor = ctors[i$1];
          handlers_[ctor.prototype.className] = handler;
        }
      }
      return function (node, args) {
        args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
        if (!(null != node))
          return defaultValue;
        handler = Object.prototype.hasOwnProperty.call(handlers_, node.className) ? handlers_[node.className] : defaultHandler;
        return handler.apply(node, args);
      };
    };
    isTruthy = makeDispatcher(false, [
      [
        CS.ArrayInitialiser,
        CS.Mixin,
        CS.Class,
        CS.DeleteOp,
        CS.ForIn,
        CS.ForOf,
        CS.Function,
        CS.BoundFunction,
        CS.ComputedProperty,
        CS.HeregExp,
        CS.ObjectInitialiser,
        CS.Range,
        CS.RegExp,
        CS.Slice,
        CS.TypeofOp,
        CS.While,
        function () {
          return true;
        }
      ],
      [
        CS.AssignOp,
        function () {
          return isTruthy(this.expression);
        }
      ],
      [
        CS.Block,
        function () {
          if (this.statements.length === 0) {
            return false;
          } else {
            return isTruthy(this.statements[this.statements.length - 1]);
          }
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Int,
        CS.String,
        function () {
          return !!this.data;
        }
      ],
      [
        CS.Conditional,
        function () {
          return isTruthy(this.condition) && isTruthy(this.consequent) || isFalsey(this.condition) && isTruthy(this.alternate);
        }
      ],
      [
        CS.LogicalAndOp,
        function () {
          return isTruthy(this.left) && isTruthy(this.right);
        }
      ],
      [
        CS.LogicalNotOp,
        function () {
          return isFalsey(this.expression);
        }
      ],
      [
        CS.LogicalOrOp,
        function () {
          return isTruthy(this.left) || isTruthy(this.right);
        }
      ],
      [
        CS.Program,
        function () {
          return isTruthy(this.body);
        }
      ],
      [
        CS.SeqOp,
        function () {
          return isTruthy(this.right);
        }
      ],
      [
        CS.Switch,
        function () {
          return all(this.cases, isTruthy) && (null != this.alternate ? isTruthy(this.alternate) : true);
        }
      ],
      [
        CS.SwitchCase,
        function () {
          return isTruthy(this.consequent);
        }
      ],
      [
        CS.UnaryExistsOp,
        function () {
          return isTruthy(this.expression) || this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp);
        }
      ]
    ], function () {
      return false;
    });
    isFalsey = makeDispatcher(false, [
      [
        CS.Null,
        CS.Undefined,
        function () {
          return true;
        }
      ],
      [
        CS.AssignOp,
        function () {
          return isFalsey(this.expression);
        }
      ],
      [
        CS.Block,
        function () {
          if (this.statements.length === 0) {
            return true;
          } else {
            return isFalsey(this.statements[this.statements.length - 1]);
          }
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Int,
        CS.String,
        function () {
          return !this.data;
        }
      ],
      [
        CS.Conditional,
        function () {
          return isTruthy(this.condition) && isFalsey(this.consequent) || isFalsey(this.condition) && isFalsey(this.alternate);
        }
      ],
      [
        CS.LogicalAndOp,
        function () {
          return isFalsey(this.left) || isFalsey(this.right);
        }
      ],
      [
        CS.LogicalNotOp,
        function () {
          return isTruthy(this.expression);
        }
      ],
      [
        CS.LogicalOrOp,
        function () {
          return isFalsey(this.left) && isFalsey(this.right);
        }
      ],
      [
        CS.Program,
        function () {
          return isFalsey(this.body);
        }
      ],
      [
        CS.SeqOp,
        function () {
          return isFalsey(this.right);
        }
      ],
      [
        CS.Switch,
        function () {
          return all(this.cases, isFalsey) && (null != this.alternate ? isFalsey(this.alternate) : true);
        }
      ],
      [
        CS.SwitchCase,
        function () {
          return isFalsey(this.block);
        }
      ],
      [
        CS.UnaryExistsOp,
        function () {
          return this.expression['instanceof'](CS.Null, CS.Undefined);
        }
      ]
    ], function () {
      return false;
    });
    mayHaveSideEffects = makeDispatcher(false, [
      [
        CS.Function,
        CS.BoundFunction,
        CS.ComputedProperty,
        CS.Null,
        CS.RegExp,
        CS.This,
        CS.Undefined,
        function () {
          return false;
        }
      ],
      [
        CS.Break,
        CS.Continue,
        CS.Debugger,
        CS.DeleteOp,
        CS.NewOp,
        CS.Return,
        CS.Super,
        CS.PreDecrementOp,
        CS.PreIncrementOp,
        CS.PostDecrementOp,
        CS.PostIncrementOp,
        CS.ClassProtoAssignOp,
        CS.Constructor,
        CS.Throw,
        CS.JavaScript,
        CS.ExtendsOp,
        function () {
          return true;
        }
      ],
      [
        CS.Class,
        CS.Mixin,
        function (inScope) {
          return mayHaveSideEffects(this.parent, inScope) || null != this.nameAssignee && (this.name || beingDeclared(this.nameAssignee).length > 0);
        }
      ],
      [
        CS.Conditional,
        function (inScope) {
          return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.consequent, inScope) || !isTruthy(this.condition) && mayHaveSideEffects(this.alternate, inScope);
        }
      ],
      [
        CS.DoOp,
        function (inScope) {
          var args, newScope, p;
          if (!this.expression['instanceof'](CS.Functions))
            return true;
          newScope = difference(inScope, concatMap(this.expression.parameters, beingDeclared));
          args = function (accum$) {
            for (var i$ = 0, length$ = this.expression.parameters.length; i$ < length$; ++i$) {
              p = this.expression.parameters[i$];
              accum$.push(p['instanceof'](CS.AssignOp) ? p.expression : p);
            }
            return accum$;
          }.call(this, []);
          if (any(args, function (a) {
              return mayHaveSideEffects(a, newScope);
            }))
            return true;
          return mayHaveSideEffects(this.expression.body, newScope);
        }
      ],
      [
        CS.ExistsOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (this.left['instanceof'](CS.Undefined, CS.Null))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.FunctionApplication,
        CS.SoakedFunctionApplication,
        function (inScope) {
          var newScope;
          if (!this['function']['instanceof'](CS.Function, CS.BoundFunction))
            return true;
          newScope = difference(inScope, concatMap(this['function'].parameters, beingDeclared));
          if (any(this['arguments'], function (a) {
              return mayHaveSideEffects(a, newScope);
            }))
            return true;
          return mayHaveSideEffects(this['function'].body, newScope);
        }
      ],
      [
        CS.LogicalAndOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (isFalsey(this.left))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.LogicalOrOp,
        function (inScope) {
          if (mayHaveSideEffects(this.left, inScope))
            return true;
          if (isTruthy(this.left))
            return false;
          return mayHaveSideEffects(this.right, inScope);
        }
      ],
      [
        CS.While,
        function (inScope) {
          return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.body, inScope);
        }
      ],
      [
        CS.AssignOp,
        CS.ClassProtoAssignOp,
        CS.CompoundAssignOp,
        function (inScope) {
          return true;
        }
      ],
      [
        CS.Bool,
        CS.Float,
        CS.Identifier,
        CS.Int,
        CS.String,
        function () {
          return false;
        }
      ]
    ], function (inScope) {
      return any(this.childNodes, function (this$) {
        return function (child) {
          if (in$(child, this$.listMembers)) {
            return any(this$[child], function (m) {
              return mayHaveSideEffects(m, inScope);
            });
          } else {
            return mayHaveSideEffects(this$[child], inScope);
          }
        };
      }(this));
    });
    exports.Optimiser = function () {
      Optimiser.optimise = function (this$) {
        return function () {
          var cache$2;
          return (cache$2 = new this$).optimise.apply(cache$2, [].slice.call(arguments));
        };
      }(Optimiser);
      Optimiser.isTruthy = isTruthy;
      Optimiser.isFalsey = isFalsey;
      Optimiser.mayHaveSideEffects = mayHaveSideEffects;
      defaultRules = [
        [
          CS.Program,
          function () {
            if (!(null != this.body) || mayHaveSideEffects(this.body, [])) {
              return this;
            } else {
              return new CS.Program(null);
            }
          }
        ],
        [
          CS.Block,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            switch (this.statements.length) {
            case 0:
              return new CS.Undefined().g();
            case 1:
              return this.statements[0];
            default:
              return foldl(this.statements[0], this.statements.slice(1), function (expr, s) {
                return new CS.SeqOp(expr, s);
              });
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var ancestry, cache$2, canDropLast, inScope;
            {
              cache$2 = param$;
              inScope = cache$2.inScope;
              ancestry = cache$2.ancestry;
            }
            canDropLast = !usedAsExpression(this, ancestry);
            if (this.left['instanceof'](CS.Undefined)) {
              return this.right;
            } else if (this.left['instanceof'](CS.Return, CS.Throw)) {
              return this.left;
            } else if (mayHaveSideEffects(this.left, inScope)) {
              if (mayHaveSideEffects(this.right, inScope)) {
                return this;
              } else if (!canDropLast) {
                return this;
              } else if (this.right['instanceof'](CS.Undefined)) {
                return this.left;
              } else {
                return new CS.SeqOp(this.left, declarationsFor(this.right, union(inScope, envEnrichments(this.left, inScope))));
              }
            } else if (this.right['instanceof'](CS.Identifier) && this.right.data === 'eval' && ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.FunctionApplication) : void 0) && ancestry[0]['function'] === this || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.DoOp) : void 0) && ancestry[0].expression === this)) {
              if (this.left['instanceof'](CS.Int) && (0 <= this.left.data && this.left.data <= 9)) {
                return this;
              } else if (mayHaveSideEffects(this.left, inScope)) {
                return this;
              } else {
                return new CS.SeqOp(new CS.Int(0).g(), this.right);
              }
            } else if (mayHaveSideEffects(this.right, inScope)) {
              return new CS.SeqOp(declarationsFor(this.left, inScope), this.right);
            } else if (canDropLast) {
              return declarationsFor(this, inScope);
            } else {
              return this.right;
            }
          }
        ],
        [
          CS.AssignOp,
          function () {
            if (!this.expression['instanceof'](CS.SeqOp))
              return this;
            return new CS.SeqOp(this.expression.left, new CS.AssignOp(this.assignee, this.expression.right));
          }
        ],
        [
          CS.While,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (isFalsey(this.condition)) {
              return new CS.Block([
                mayHaveSideEffects(this.condition, inScope) ? new CS.SeqOp(this.condition, declarationsFor(this.body)) : null != this.body ? declarationsFor(this.body, inScope) : new CS.Undefined,
                new CS.ArrayInitialiser([])
              ]);
            } else if (isTruthy(this.condition)) {
              if (mayHaveSideEffects(this.condition, inScope)) {
                return this;
              } else if (null != this.body) {
                if (this instanceof CS.Loop) {
                  return this;
                } else {
                  return new CS.Loop(this.body).g();
                }
              } else {
                return new CS.ArrayInitialiser([]);
              }
            } else {
              return this;
            }
          }
        ],
        [
          CS.Conditional,
          function (param$) {
            var block, cache$2, cache$3, decls, inScope, removedBlock;
            inScope = param$.inScope;
            if (isFalsey(this.condition)) {
              cache$2 = [
                this.consequent,
                this.alternate
              ];
              removedBlock = cache$2[0];
              block = cache$2[1];
              cache$2;
            } else if (isTruthy(this.condition)) {
              cache$3 = [
                this.consequent,
                this.alternate
              ];
              block = cache$3[0];
              removedBlock = cache$3[1];
              cache$3;
            } else {
              return this;
            }
            decls = declarationsFor(removedBlock, inScope);
            block = null != block ? new CS.SeqOp(decls, block) : decls;
            if (mayHaveSideEffects(this.condition, inScope))
              block = new CS.SeqOp(this.condition, block);
            return block;
          }
        ],
        [
          CS.ForIn,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!(this.target['instanceof'](CS.ArrayInitialiser) && this.target.members.length === 0))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForOf,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!(this.isOwn && this.target['instanceof'](CS.ObjectInitialiser) && this.target.members.length === 0))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForIn,
          CS.ForOf,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            if (!isFalsey(this.filter))
              return this;
            return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
          }
        ],
        [
          CS.ForIn,
          function () {
            if (!isTruthy(this.filter))
              return this;
            return new CS.ForIn(this.valAssignee, this.keyAssignee, this.target, this.step, null, this.body);
          }
        ],
        [
          CS.ForOf,
          function () {
            if (!isTruthy(this.filter))
              return this;
            return new CS.ForOf(this.isOwn, this.keyAssignee, this.valAssignee, this.target, null, this.body);
          }
        ],
        [
          CS.ArrayInitialiser,
          function (param$) {
            var ancestry, cache$2, inScope;
            {
              cache$2 = param$;
              inScope = cache$2.inScope;
              ancestry = cache$2.ancestry;
            }
            if (usedAsExpression(this, ancestry)) {
              return this;
            } else {
              return foldl(new CS.Undefined().g(), this.members, function (expr, m) {
                return new CS.SeqOp(expr, m);
              });
            }
          }
        ],
        [
          CS.ExistsOp,
          function () {
            if (this.left['instanceof'](CS.Null, CS.Undefined)) {
              return this.right;
            } else {
              return this;
            }
          }
        ],
        [
          CS.UnaryExistsOp,
          function () {
            if (this.expression['instanceof'](CS.Null, CS.Undefined)) {
              return new CS.Bool(false).g();
            } else {
              return this;
            }
          }
        ],
        [
          CS.LogicalNotOp,
          function (param$) {
            var inScope;
            inScope = param$.inScope;
            switch (false) {
            case !this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.Bool):
              return new CS.Bool(!this.expression.data).g();
            case !this.expression['instanceof'](CS.Functions):
              return new CS.Bool(false).g();
            case !this.expression['instanceof'](CS.Null, CS.Undefined):
              return new CS.Bool(true).g();
            case !this.expression['instanceof'](CS.ArrayInitialiser, CS.ObjectInitialiser):
              if (mayHaveSideEffects(this.expression, inScope)) {
                return this;
              } else {
                return new CS.SeqOp(declarationsFor(this.expression, inScope), new CS.Bool(false).g());
              }
            case !this.expression['instanceof'](CS.LogicalNotOp):
              if (this.expression.expression['instanceof'](CS.LogicalNotOp)) {
                return this.expression.expression;
              } else {
                return this;
              }
            default:
              return this;
            }
          }
        ],
        [
          CS.TypeofOp,
          function () {
            switch (false) {
            case !this.expression['instanceof'](CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp):
              return new CS.String('number').g();
            case !this.expression['instanceof'](CS.String):
              return new CS.String('string').g();
            case !this.expression['instanceof'](CS.Functions):
              return new CS.String('function').g();
            case !this.expression['instanceof'](CS.Undefined):
              return new CS.String('undefined').g();
            default:
              return this;
            }
          }
        ],
        [
          CS.SeqOp,
          function (param$) {
            var ancestry;
            ancestry = param$.ancestry;
            if (!((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Functions) : void 0) && ancestry[0].body === this))
              return this;
            if (this.right['instanceof'](CS.Return) && null != this.right.expression) {
              return new CS.SeqOp(this.left, this.right.expression);
            } else if (this.right['instanceof'](CS.Undefined)) {
              return new CS.SeqOp(this.left, new CS.Return);
            } else {
              return this;
            }
          }
        ],
        [
          CS.Function,
          CS.BoundFunction,
          function () {
            if (!(null != this.block && (this.block['instanceof'](CS.Undefined) || this.block['instanceof'](CS.Return) && !(null != this.block.expression))))
              return this;
            return new this.constructor(this.parameters, null);
          }
        ],
        [
          CS.Return,
          function () {
            if (null != this.expression ? this.expression['instanceof'](CS.Undefined) : void 0) {
              return new CS.Return;
            } else {
              return this;
            }
          }
        ],
        [
          CS.Slice,
          function () {
            if ((null != this.left ? this.left['instanceof'](CS.Int, CS.String) : void 0) && +this.left.data === 0) {
              return new CS.Slice(this.expression, this.isInclusive, null, this.right);
            } else if (this.isInclusive && (null != this.right ? this.right['instanceof'](CS.UnaryNegateOp) : void 0) && this.right.expression['instanceof'](CS.Int) && this.right.expression.data === 1) {
              return new CS.Slice(this.expression, true, this.left, null);
            } else {
              return this;
            }
          }
        ]
      ];
      function Optimiser() {
        var cache$2, ctor, ctors, handler, size$;
        this.rules = {};
        for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
          {
            cache$2 = defaultRules[i$];
            size$ = cache$2.length;
            ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
            handler = cache$2[size$ - 1];
          }
          for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
            ctor = ctors[i$1];
            this.addRule(ctor.prototype.className, handler);
          }
        }
      }
      Optimiser.prototype.addRule = function (ctor, handler) {
        (null != this.rules[ctor] ? this.rules[ctor] : this.rules[ctor] = []).push(handler);
        return this;
      };
      Optimiser.prototype.optimise = function () {
        var walk;
        walk = function (fn, inScope, ancestry) {
          var childName, member, n, p, replacementNode;
          if (null == inScope)
            inScope = [];
          if (null == ancestry)
            ancestry = [];
          ancestry.unshift(this);
          for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
            childName = this.childNodes[i$];
            if (!(null != this[childName]))
              continue;
            if (in$(childName, this.listMembers)) {
              for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
                member = this[childName][i$1];
                n = i$1;
                while (this[childName][n] !== walk.call(this[childName][n] = fn.call(this[childName][n], {
                    inScope: inScope,
                    ancestry: ancestry
                  }), fn, inScope, ancestry)) {
                }
                inScope = union(inScope, envEnrichments(this[childName][n], inScope));
              }
            } else {
              while (this[childName] !== walk.call(this[childName] = fn.call(this[childName], {
                  inScope: inScope,
                  ancestry: ancestry
                }), fn, inScope, ancestry)) {
              }
              inScope = union(inScope, envEnrichments(this[childName], inScope));
            }
          }
          ancestry.shift();
          replacementNode = fn.call(this, {
            inScope: inScope,
            ancestry: ancestry
          });
          if (this !== replacementNode) {
            while (replacementNode !== walk.call(replacementNode = fn.call(replacementNode, {
                inScope: inScope,
                ancestry: ancestry
              }), fn, inScope, ancestry)) {
            }
            for (var cache$2 = [
                  'raw',
                  'line',
                  'column',
                  'offset'
                ], i$2 = 0, length$2 = cache$2.length; i$2 < length$2; ++i$2) {
              p = cache$2[i$2];
              replacementNode[p] = this[p];
            }
          }
          return replacementNode;
        };
        return function (ast) {
          var rules;
          rules = this.rules;
          return walk.call(ast, function (param$) {
            var ancestry, memo, rule;
            ancestry = param$.ancestry;
            if (!(null != this) || this === global)
              throw new Error('Optimiser rules must produce a node. `null` is not a node.');
            if (in$(this, ancestry))
              return this;
            memo = this;
            for (var cache$2 = null != rules[memo.className] ? rules[memo.className] : [], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
              rule = cache$2[i$];
              memo = rule.apply(memo, arguments);
              if (memo !== this)
                break;
            }
            return memo;
          });
        };
      }();
      return Optimiser;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/src/parser.coffee', function (module, exports, __dirname, __filename) {
    module.exports = function () {
      function subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor;
      }
      function quote(s) {
        return '"' + s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
      }
      var result = {
          parse: function (input) {
            var parseFunctions = { 'program': parse_program };
            var options = arguments.length > 1 ? arguments[1] : {}, startRule;
            if (options.startRule !== undefined) {
              startRule = options.startRule;
              if (parseFunctions[startRule] === undefined) {
                throw new Error("Can't start parsing from rule " + quote(startRule) + '.');
              }
            } else {
              startRule = 'program';
            }
            var pos = 0;
            var reportedPos = 0;
            var cachedReportedPos = 0;
            var cachedReportedPosDetails = {
                line: 1,
                column: 1,
                seenCR: false
              };
            var reportFailures = 0;
            var rightmostFailuresPos = 0;
            var rightmostFailuresExpected = [];
            var cache = {};
            function padLeft(input, padding, length) {
              var result = input;
              var padLength = length - input.length;
              for (var i = 0; i < padLength; i++) {
                result = padding + result;
              }
              return result;
            }
            function escape(ch) {
              var charCode = ch.charCodeAt(0);
              var escapeChar;
              var length;
              if (charCode <= 255) {
                escapeChar = 'x';
                length = 2;
              } else {
                escapeChar = 'u';
                length = 4;
              }
              return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
            }
            function computeReportedPosDetails() {
              function advanceCachedReportedPos() {
                var ch;
                for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
                  ch = input.charAt(cachedReportedPos);
                  if (ch === '\n') {
                    if (!cachedReportedPosDetails.seenCR) {
                      cachedReportedPosDetails.line++;
                    }
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = false;
                  } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
                    cachedReportedPosDetails.line++;
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = true;
                  } else {
                    cachedReportedPosDetails.column++;
                    cachedReportedPosDetails.seenCR = false;
                  }
                }
              }
              if (cachedReportedPos !== reportedPos) {
                if (cachedReportedPos > reportedPos) {
                  cachedReportedPos = 0;
                  cachedReportedPosDetails = {
                    line: 1,
                    column: 1,
                    seenCR: false
                  };
                }
                advanceCachedReportedPos();
              }
              return cachedReportedPosDetails;
            }
            function text() {
              return input.substring(reportedPos, pos);
            }
            function offset() {
              return reportedPos;
            }
            function line() {
              return computeReportedPosDetails().line;
            }
            function column() {
              return computeReportedPosDetails().column;
            }
            function matchFailed(failure) {
              if (pos < rightmostFailuresPos) {
                return;
              }
              if (pos > rightmostFailuresPos) {
                rightmostFailuresPos = pos;
                rightmostFailuresExpected = [];
              }
              rightmostFailuresExpected.push(failure);
            }
            function parse_program() {
              var cacheKey = 'program@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_toplevelBlock();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (leader, b) {
                  return rp(new CS.Program(b || null));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_toplevelBlock() {
              var cacheKey = 'toplevelBlock@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_toplevelStatement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_toplevelStatement();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_toplevelStatement();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s, ss) {
                  return rp(new CS.Block([s].concat(ss.map(function (s) {
                    return s[3];
                  }))));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_toplevelStatement() {
              var cacheKey = 'toplevelStatement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_return();
              if (r3 === null) {
                r3 = parse_continue();
                if (r3 === null) {
                  r3 = parse_break();
                }
              }
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_statement();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s) {
                  return s;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_block() {
              var cacheKey = 'block@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_statement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_statement();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_statement();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (s, ss) {
                  return rp(new CS.Block([s].concat(ss.map(function (s) {
                    return s[3];
                  }))));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_statement() {
              var cacheKey = 'statement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expression();
              if (r0 === null) {
                r0 = parse_return();
                if (r0 === null) {
                  r0 = parse_continue();
                  if (r0 === null) {
                    r0 = parse_break();
                    if (r0 === null) {
                      r0 = parse_throw();
                      if (r0 === null) {
                        r0 = parse_debugger();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_expression() {
              var cacheKey = 'expression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_seqExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryStatement() {
              var cacheKey = 'secondaryStatement@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_secondaryExpression();
              if (r0 === null) {
                r0 = parse_return();
                if (r0 === null) {
                  r0 = parse_continue();
                  if (r0 === null) {
                    r0 = parse_break();
                    if (r0 === null) {
                      r0 = parse_throw();
                      if (r0 === null) {
                        r0 = parse_debugger();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryExpression() {
              var cacheKey = 'secondaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_assignmentExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryExpressionNoImplicitObjectCall() {
              var cacheKey = 'secondaryExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_expressionworthy();
              if (r0 === null) {
                r0 = parse_assignmentExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_expressionworthy() {
              var cacheKey = 'expressionworthy@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_functionLiteral();
              if (r0 === null) {
                r0 = parse_conditional();
                if (r0 === null) {
                  r0 = parse_while();
                  if (r0 === null) {
                    r0 = parse_loop();
                    if (r0 === null) {
                      r0 = parse_try();
                      if (r0 === null) {
                        r0 = parse_forOf();
                        if (r0 === null) {
                          r0 = parse_forIn();
                          if (r0 === null) {
                            r0 = parse_switch();
                            if (r0 === null) {
                              r0 = parse_implicitObjectLiteral();
                              if (r0 === null) {
                                r0 = parse_class();
                                if (r0 === null) {
                                  r0 = parse_mixin();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_seqExpression() {
              var cacheKey = 'seqExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixControlFlowExpression();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  if (input.charCodeAt(pos) === 59) {
                    r7 = ';';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('";"');
                    }
                  }
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    r8 = r8 !== null ? r8 : '';
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_expression();
                        if (r10 !== null) {
                          r4 = [
                            r6,
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  if (!right)
                    return left;
                  return rp(new CS.SeqOp(left, right[4]));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixControlFlowExpression() {
              var cacheKey = 'postfixControlFlowExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_secondaryStatement();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_postfixControlFlowOp();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_postfixControlFlowOp();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (expr, postfixes) {
                  return foldl(function (expr, postfixContainer) {
                    var constructor, cond, postfix = postfixContainer[1], indicator = postfix.type;
                    switch (indicator) {
                    case 'if':
                    case 'unless':
                      constructor = 'unless' === indicator ? CS.NegatedConditional : CS.Conditional;
                      cond = 'unless' === indicator ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                      return rp(new constructor(cond, expr, null));
                    case 'while':
                    case 'until':
                      constructor = 'until' === indicator ? CS.NegatedWhile : CS.While;
                      cond = 'until' === indicator ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                      return rp(new constructor(cond, expr));
                    case 'for-in':
                      return rp(new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr));
                    case 'for-of':
                      return rp(new CS.ForOf(postfix.own, postfix.key, postfix.val, postfix.obj, postfix.filter, expr));
                    }
                  }, expr, postfixes);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixControlFlowOp() {
              var cacheKey = 'postfixControlFlowOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
              r1 = pos;
              r2 = pos;
              r3 = parse_IF();
              if (r3 === null) {
                r3 = parse_UNLESS();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpression();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, e) {
                  return {
                    type: kw,
                    cond: e
                  };
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_WHILE();
                if (r3 === null) {
                  r3 = parse_UNTIL();
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_assignmentExpression();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (kw, e) {
                    return {
                      type: kw,
                      cond: e
                    };
                  }(r3, r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_FOR();
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r6 = pos;
                      r7 = parse_Assignable();
                      if (r7 !== null) {
                        r8 = parse__();
                        if (r8 !== null) {
                          r10 = pos;
                          if (input.charCodeAt(pos) === 44) {
                            r11 = ',';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('","');
                            }
                          }
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_Assignable();
                              if (r13 !== null) {
                                r14 = parse__();
                                if (r14 !== null) {
                                  r9 = [
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r9 = null;
                                  pos = r10;
                                }
                              } else {
                                r9 = null;
                                pos = r10;
                              }
                            } else {
                              r9 = null;
                              pos = r10;
                            }
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r5 = [
                              r7,
                              r8,
                              r9
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                      r5 = r5 !== null ? r5 : '';
                      if (r5 !== null) {
                        r6 = parse_IN();
                        if (r6 !== null) {
                          r7 = parse__();
                          if (r7 !== null) {
                            r8 = parse_assignmentExpression();
                            if (r8 !== null) {
                              r10 = pos;
                              r11 = parse__();
                              if (r11 !== null) {
                                r12 = parse_BY();
                                if (r12 !== null) {
                                  r13 = parse__();
                                  if (r13 !== null) {
                                    r14 = parse_assignmentExpression();
                                    if (r14 !== null) {
                                      r9 = [
                                        r11,
                                        r12,
                                        r13,
                                        r14
                                      ];
                                    } else {
                                      r9 = null;
                                      pos = r10;
                                    }
                                  } else {
                                    r9 = null;
                                    pos = r10;
                                  }
                                } else {
                                  r9 = null;
                                  pos = r10;
                                }
                              } else {
                                r9 = null;
                                pos = r10;
                              }
                              r9 = r9 !== null ? r9 : '';
                              if (r9 !== null) {
                                r11 = pos;
                                r12 = parse__();
                                if (r12 !== null) {
                                  r13 = parse_WHEN();
                                  if (r13 !== null) {
                                    r14 = parse__();
                                    if (r14 !== null) {
                                      r15 = parse_assignmentExpression();
                                      if (r15 !== null) {
                                        r10 = [
                                          r12,
                                          r13,
                                          r14,
                                          r15
                                        ];
                                      } else {
                                        r10 = null;
                                        pos = r11;
                                      }
                                    } else {
                                      r10 = null;
                                      pos = r11;
                                    }
                                  } else {
                                    r10 = null;
                                    pos = r11;
                                  }
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                                r10 = r10 !== null ? r10 : '';
                                if (r10 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (maybeVal, list, maybeStep, maybeFilter) {
                      var val = maybeVal ? maybeVal[0] : null, key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null, step = maybeStep ? maybeStep[3] : new CS.Int(1).r('1').g(), filter = maybeFilter ? maybeFilter[3] : null;
                      return 0, {
                        type: 'for-in',
                        val: val,
                        key: key,
                        list: list,
                        step: step,
                        filter: filter
                      };
                    }(r5, r8, r9, r10);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    r3 = parse_FOR();
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r6 = pos;
                        r7 = parse_OWN();
                        if (r7 !== null) {
                          r8 = parse__();
                          if (r8 !== null) {
                            r5 = [
                              r7,
                              r8
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                        r5 = r5 !== null ? r5 : '';
                        if (r5 !== null) {
                          r6 = parse_Assignable();
                          if (r6 !== null) {
                            r7 = parse__();
                            if (r7 !== null) {
                              r9 = pos;
                              if (input.charCodeAt(pos) === 44) {
                                r10 = ',';
                                pos++;
                              } else {
                                r10 = null;
                                if (reportFailures === 0) {
                                  matchFailed('","');
                                }
                              }
                              if (r10 !== null) {
                                r11 = parse__();
                                if (r11 !== null) {
                                  r12 = parse_Assignable();
                                  if (r12 !== null) {
                                    r13 = parse__();
                                    if (r13 !== null) {
                                      r8 = [
                                        r10,
                                        r11,
                                        r12,
                                        r13
                                      ];
                                    } else {
                                      r8 = null;
                                      pos = r9;
                                    }
                                  } else {
                                    r8 = null;
                                    pos = r9;
                                  }
                                } else {
                                  r8 = null;
                                  pos = r9;
                                }
                              } else {
                                r8 = null;
                                pos = r9;
                              }
                              r8 = r8 !== null ? r8 : '';
                              if (r8 !== null) {
                                r9 = parse_OF();
                                if (r9 !== null) {
                                  r10 = parse__();
                                  if (r10 !== null) {
                                    r11 = parse_assignmentExpression();
                                    if (r11 !== null) {
                                      r13 = pos;
                                      r14 = parse__();
                                      if (r14 !== null) {
                                        r15 = parse_WHEN();
                                        if (r15 !== null) {
                                          r16 = parse__();
                                          if (r16 !== null) {
                                            r17 = parse_assignmentExpression();
                                            if (r17 !== null) {
                                              r12 = [
                                                r14,
                                                r15,
                                                r16,
                                                r17
                                              ];
                                            } else {
                                              r12 = null;
                                              pos = r13;
                                            }
                                          } else {
                                            r12 = null;
                                            pos = r13;
                                          }
                                        } else {
                                          r12 = null;
                                          pos = r13;
                                        }
                                      } else {
                                        r12 = null;
                                        pos = r13;
                                      }
                                      r12 = r12 !== null ? r12 : '';
                                      if (r12 !== null) {
                                        r0 = [
                                          r3,
                                          r4,
                                          r5,
                                          r6,
                                          r7,
                                          r8,
                                          r9,
                                          r10,
                                          r11,
                                          r12
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (maybeOwn, key, maybeVal, obj, maybeFilter) {
                        var own = !!maybeOwn, val = maybeVal ? maybeVal[2] : null, filter = maybeFilter ? maybeFilter[3] : null;
                        return 0, {
                          type: 'for-of',
                          own: own,
                          key: key,
                          val: val,
                          obj: obj,
                          filter: filter
                        };
                      }(r5, r6, r8, r11, r12);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentExpression() {
              var cacheKey = 'assignmentExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_assignmentOp();
              if (r0 === null) {
                r0 = parse_compoundAssignmentOp();
                if (r0 === null) {
                  r0 = parse_existsAssignmentOp();
                  if (r0 === null) {
                    r0 = parse_binaryExpression();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentOp() {
              var cacheKey = 'assignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    reportFailures++;
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    reportFailures--;
                    if (r6 === null) {
                      r6 = '';
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpression();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpression();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.AssignOp(left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_compoundAssignmentOp() {
              var cacheKey = 'compoundAssignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 63) {
                    r5 = '?';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  reportFailures--;
                  if (r5 === null) {
                    r5 = '';
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  if (r5 !== null) {
                    r6 = parse_CompoundAssignmentOperators();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 61) {
                        r7 = '=';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"="');
                        }
                      }
                      if (r7 !== null) {
                        r9 = pos;
                        r10 = pos;
                        r11 = parse_TERMINDENT();
                        if (r11 !== null) {
                          r12 = parse_secondaryExpression();
                          if (r12 !== null) {
                            r13 = parse_DEDENT();
                            if (r13 !== null) {
                              r8 = [
                                r11,
                                r12,
                                r13
                              ];
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                        if (r8 !== null) {
                          reportedPos = r9;
                          r8 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r8 === null) {
                          pos = r9;
                        }
                        if (r8 === null) {
                          r9 = pos;
                          r10 = pos;
                          r11 = parse_TERMINATOR();
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_secondaryExpression();
                              if (r13 !== null) {
                                r8 = [
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r10;
                              }
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                          if (r8 !== null) {
                            reportedPos = r9;
                            r8 = function (e) {
                              return e;
                            }(r13);
                          }
                          if (r8 === null) {
                            pos = r9;
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, op, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
                }(r3, r6, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CompoundAssignmentOperators() {
              var cacheKey = 'CompoundAssignmentOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              if (input.substr(pos, 2) === '&&') {
                r0 = '&&';
                pos += 2;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"&&"');
                }
              }
              if (r0 === null) {
                r0 = parse_AND();
                if (r0 === null) {
                  if (input.substr(pos, 2) === '||') {
                    r0 = '||';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"||"');
                    }
                  }
                  if (r0 === null) {
                    r0 = parse_OR();
                    if (r0 === null) {
                      if (input.substr(pos, 2) === '**') {
                        r0 = '**';
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"**"');
                        }
                      }
                      if (r0 === null) {
                        if (/^[?&\^|*\/%]/.test(input.charAt(pos))) {
                          r0 = input.charAt(pos);
                          pos++;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('[?&\\^|*\\/%]');
                          }
                        }
                        if (r0 === null) {
                          r2 = pos;
                          if (input.charCodeAt(pos) === 43) {
                            r3 = '+';
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('"+"');
                            }
                          }
                          if (r3 !== null) {
                            r5 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 43) {
                              r4 = '+';
                              pos++;
                            } else {
                              r4 = null;
                              if (reportFailures === 0) {
                                matchFailed('"+"');
                              }
                            }
                            reportFailures--;
                            if (r4 === null) {
                              r4 = '';
                            } else {
                              r4 = null;
                              pos = r5;
                            }
                            if (r4 !== null) {
                              r0 = [
                                r3,
                                r4
                              ];
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                          if (r0 === null) {
                            r2 = pos;
                            if (input.charCodeAt(pos) === 45) {
                              r3 = '-';
                              pos++;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('"-"');
                              }
                            }
                            if (r3 !== null) {
                              r5 = pos;
                              reportFailures++;
                              if (input.charCodeAt(pos) === 45) {
                                r4 = '-';
                                pos++;
                              } else {
                                r4 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"-"');
                                }
                              }
                              reportFailures--;
                              if (r4 === null) {
                                r4 = '';
                              } else {
                                r4 = null;
                                pos = r5;
                              }
                              if (r4 !== null) {
                                r0 = [
                                  r3,
                                  r4
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                            if (r0 === null) {
                              if (input.substr(pos, 2) === '<<') {
                                r0 = '<<';
                                pos += 2;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"<<"');
                                }
                              }
                              if (r0 === null) {
                                if (input.substr(pos, 3) === '>>>') {
                                  r0 = '>>>';
                                  pos += 3;
                                } else {
                                  r0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('">>>"');
                                  }
                                }
                                if (r0 === null) {
                                  if (input.substr(pos, 2) === '>>') {
                                    r0 = '>>';
                                    pos += 2;
                                  } else {
                                    r0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('">>"');
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_existsAssignmentOp() {
              var cacheKey = 'existsAssignmentOp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 2) === '?=') {
                    r5 = '?=';
                    pos += 2;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpression();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpression();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentExpressionNoImplicitObjectCall() {
              var cacheKey = 'assignmentExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_assignmentOpNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_compoundAssignmentOpNoImplicitObjectCall();
                if (r0 === null) {
                  r0 = parse_existsAssignmentOpNoImplicitObjectCall();
                  if (r0 === null) {
                    r0 = parse_binaryExpressionNoImplicitObjectCall();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_assignmentOpNoImplicitObjectCall() {
              var cacheKey = 'assignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    reportFailures++;
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    reportFailures--;
                    if (r6 === null) {
                      r6 = '';
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpressionNoImplicitObjectCall();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.AssignOp(left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_compoundAssignmentOpNoImplicitObjectCall() {
              var cacheKey = 'compoundAssignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 63) {
                    r5 = '?';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  reportFailures--;
                  if (r5 === null) {
                    r5 = '';
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  if (r5 !== null) {
                    r6 = parse_CompoundAssignmentOperators();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 61) {
                        r7 = '=';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"="');
                        }
                      }
                      if (r7 !== null) {
                        r9 = pos;
                        r10 = pos;
                        r11 = parse_TERMINDENT();
                        if (r11 !== null) {
                          r12 = parse_secondaryExpressionNoImplicitObjectCall();
                          if (r12 !== null) {
                            r13 = parse_DEDENT();
                            if (r13 !== null) {
                              r8 = [
                                r11,
                                r12,
                                r13
                              ];
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                        if (r8 !== null) {
                          reportedPos = r9;
                          r8 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r8 === null) {
                          pos = r9;
                        }
                        if (r8 === null) {
                          r9 = pos;
                          r10 = pos;
                          r11 = parse_TERMINATOR();
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r12 = parse__();
                            if (r12 !== null) {
                              r13 = parse_secondaryExpressionNoImplicitObjectCall();
                              if (r13 !== null) {
                                r8 = [
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r10;
                              }
                            } else {
                              r8 = null;
                              pos = r10;
                            }
                          } else {
                            r8 = null;
                            pos = r10;
                          }
                          if (r8 !== null) {
                            reportedPos = r9;
                            r8 = function (e) {
                              return e;
                            }(r13);
                          }
                          if (r8 === null) {
                            pos = r9;
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, op, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
                }(r3, r6, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_existsAssignmentOpNoImplicitObjectCall() {
              var cacheKey = 'existsAssignmentOpNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 2) === '?=') {
                    r5 = '?=';
                    pos += 2;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = pos;
                      r10 = parse_TERMINDENT();
                      if (r10 !== null) {
                        r11 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r11 !== null) {
                          r12 = parse_DEDENT();
                          if (r12 !== null) {
                            r7 = [
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        reportedPos = r8;
                        r7 = function (e) {
                          return e;
                        }(r11);
                      }
                      if (r7 === null) {
                        pos = r8;
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_secondaryExpressionNoImplicitObjectCall();
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          reportedPos = r8;
                          r7 = function (e) {
                            return e;
                          }(r12);
                        }
                        if (r7 === null) {
                          pos = r8;
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, right) {
                  return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryExpression() {
              var cacheKey = 'binaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_prefixExpression();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = pos;
                r8 = parse__();
                if (r8 !== null) {
                  r9 = parse_binaryOperator();
                  if (r9 !== null) {
                    r10 = parse_TERMINATOR();
                    r10 = r10 !== null ? r10 : '';
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        r12 = parse_expressionworthy();
                        if (r12 === null) {
                          r12 = parse_prefixExpression();
                        }
                        if (r12 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (o, e) {
                    return [
                      o,
                      e
                    ];
                  }(r9, r12);
                }
                if (r5 === null) {
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = pos;
                  r8 = parse__();
                  if (r8 !== null) {
                    r9 = parse_binaryOperator();
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_expressionworthy();
                          if (r12 === null) {
                            r12 = parse_prefixExpression();
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (o, e) {
                      return [
                        o,
                        e
                      ];
                    }(r9, r12);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, rights) {
                  switch (rights.length) {
                  case 0:
                    return left;
                  case 1:
                    return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                  default:
                    return rp(foldBinaryExpr([].concat.apply([left], rights)));
                  }
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryOperator() {
              var cacheKey = 'binaryOperator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_CompoundAssignmentOperators();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                if (input.charCodeAt(pos) === 61) {
                  r4 = '=';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"="');
                  }
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                if (input.substr(pos, 2) === '<=') {
                  r0 = '<=';
                  pos += 2;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"<="');
                  }
                }
                if (r0 === null) {
                  if (input.substr(pos, 2) === '>=') {
                    r0 = '>=';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('">="');
                    }
                  }
                  if (r0 === null) {
                    if (input.charCodeAt(pos) === 60) {
                      r0 = '<';
                      pos++;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"<"');
                      }
                    }
                    if (r0 === null) {
                      if (input.charCodeAt(pos) === 62) {
                        r0 = '>';
                        pos++;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('">"');
                        }
                      }
                      if (r0 === null) {
                        if (input.substr(pos, 2) === '==') {
                          r0 = '==';
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"=="');
                          }
                        }
                        if (r0 === null) {
                          r0 = parse_IS();
                          if (r0 === null) {
                            if (input.substr(pos, 2) === '!=') {
                              r0 = '!=';
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed('"!="');
                              }
                            }
                            if (r0 === null) {
                              r0 = parse_ISNT();
                              if (r0 === null) {
                                r0 = parse_EXTENDS();
                                if (r0 === null) {
                                  r0 = parse_INSTANCEOF();
                                  if (r0 === null) {
                                    r0 = parse_IN();
                                    if (r0 === null) {
                                      r0 = parse_OF();
                                      if (r0 === null) {
                                        r1 = pos;
                                        r2 = pos;
                                        r3 = parse_NOT();
                                        if (r3 !== null) {
                                          r4 = parse__();
                                          if (r4 !== null) {
                                            r5 = parse_INSTANCEOF();
                                            if (r5 === null) {
                                              r5 = parse_IN();
                                              if (r5 === null) {
                                                r5 = parse_OF();
                                              }
                                            }
                                            if (r5 !== null) {
                                              r0 = [
                                                r3,
                                                r4,
                                                r5
                                              ];
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                        if (r0 !== null) {
                                          reportedPos = r1;
                                          r0 = function (op) {
                                            return 'not ' + op;
                                          }(r5);
                                        }
                                        if (r0 === null) {
                                          pos = r1;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_binaryExpressionNoImplicitObjectCall() {
              var cacheKey = 'binaryExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_prefixExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = pos;
                r8 = parse__();
                if (r8 !== null) {
                  r9 = parse_binaryOperator();
                  if (r9 !== null) {
                    r10 = parse_TERMINATOR();
                    r10 = r10 !== null ? r10 : '';
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        r12 = parse_expressionworthy();
                        if (r12 === null) {
                          r12 = parse_prefixExpressionNoImplicitObjectCall();
                        }
                        if (r12 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (o, e) {
                    return [
                      o,
                      e
                    ];
                  }(r9, r12);
                }
                if (r5 === null) {
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = pos;
                  r8 = parse__();
                  if (r8 !== null) {
                    r9 = parse_binaryOperator();
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_expressionworthy();
                          if (r12 === null) {
                            r12 = parse_prefixExpressionNoImplicitObjectCall();
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (o, e) {
                      return [
                        o,
                        e
                      ];
                    }(r9, r12);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, rights) {
                  switch (rights.length) {
                  case 0:
                    return left;
                  case 1:
                    return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                  default:
                    return rp(foldBinaryExpr([].concat.apply([left], rights)));
                  }
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_prefixExpression() {
              var cacheKey = 'prefixExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r0 = parse_postfixExpression();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_DO();
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_nfe();
                    if (r5 === null) {
                      r5 = parse_expressionworthy();
                      if (r5 === null) {
                        r5 = parse_prefixExpression();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.DoOp(e));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r5 = pos;
                  r6 = parse_PrefixOperators();
                  if (r6 !== null) {
                    r7 = parse__();
                    if (r7 !== null) {
                      r4 = [
                        r6,
                        r7
                      ];
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                  if (r4 !== null) {
                    r3 = [];
                    while (r4 !== null) {
                      r3.push(r4);
                      r5 = pos;
                      r6 = parse_PrefixOperators();
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r4 = [
                            r6,
                            r7
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    }
                  } else {
                    r3 = null;
                  }
                  if (r3 !== null) {
                    r4 = parse_expressionworthy();
                    if (r4 === null) {
                      r4 = parse_prefixExpression();
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (ops, e) {
                      return rp(foldr(function (e, op) {
                        return new prefixConstructorLookup[op[0]](e);
                      }, e, ops));
                    }(r3, r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_PrefixOperators() {
              var cacheKey = 'PrefixOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.substr(pos, 2) === '++') {
                r0 = '++';
                pos += 2;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"++"');
                }
              }
              if (r0 === null) {
                if (input.substr(pos, 2) === '--') {
                  r0 = '--';
                  pos += 2;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"--"');
                  }
                }
                if (r0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    r0 = '+';
                    pos++;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"+"');
                    }
                  }
                  if (r0 === null) {
                    if (input.charCodeAt(pos) === 45) {
                      r0 = '-';
                      pos++;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"-"');
                      }
                    }
                    if (r0 === null) {
                      if (input.charCodeAt(pos) === 33) {
                        r0 = '!';
                        pos++;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"!"');
                        }
                      }
                      if (r0 === null) {
                        r0 = parse_NOT();
                        if (r0 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            r0 = '~';
                            pos++;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed('"~"');
                            }
                          }
                          if (r0 === null) {
                            r0 = parse_DO();
                            if (r0 === null) {
                              r0 = parse_TYPEOF();
                              if (r0 === null) {
                                r0 = parse_DELETE();
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_nfe() {
              var cacheKey = 'nfe@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_unassignable();
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_Assignable();
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 61) {
                      r6 = '=';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"="');
                      }
                    }
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_functionLiteral();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, f) {
                  return rp(new CS.AssignOp(a, f));
                }(r4, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_prefixExpressionNoImplicitObjectCall() {
              var cacheKey = 'prefixExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r0 = parse_postfixExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_DO();
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_nfe();
                    if (r5 === null) {
                      r5 = parse_expressionworthy();
                      if (r5 === null) {
                        r5 = parse_prefixExpressionNoImplicitObjectCall();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.DoOp(e));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r5 = pos;
                  r6 = parse_PrefixOperators();
                  if (r6 !== null) {
                    r7 = parse__();
                    if (r7 !== null) {
                      r4 = [
                        r6,
                        r7
                      ];
                    } else {
                      r4 = null;
                      pos = r5;
                    }
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                  if (r4 !== null) {
                    r3 = [];
                    while (r4 !== null) {
                      r3.push(r4);
                      r5 = pos;
                      r6 = parse_PrefixOperators();
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r4 = [
                            r6,
                            r7
                          ];
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                    }
                  } else {
                    r3 = null;
                  }
                  if (r3 !== null) {
                    r4 = parse_expressionworthy();
                    if (r4 === null) {
                      r4 = parse_prefixExpressionNoImplicitObjectCall();
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (ops, e) {
                      return rp(foldr(function (e, op) {
                        return new prefixConstructorLookup[op[0]](e);
                      }, e, ops));
                    }(r3, r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixExpression() {
              var cacheKey = 'postfixExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_leftHandSideExpression();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_PostfixOperators();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_PostfixOperators();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, ops) {
                  return rp(foldl(function (e, op) {
                    return new postfixConstructorLookup[op](e);
                  }, e, ops));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_PostfixOperators() {
              var cacheKey = 'PostfixOperators@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 63) {
                r0 = '?';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"?"');
                }
              }
              if (r0 === null) {
                if (input.substr(pos, 4) === '[..]') {
                  r0 = '[..]';
                  pos += 4;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"[..]"');
                  }
                }
                if (r0 === null) {
                  if (input.substr(pos, 2) === '++') {
                    r0 = '++';
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"++"');
                    }
                  }
                  if (r0 === null) {
                    if (input.substr(pos, 2) === '--') {
                      r0 = '--';
                      pos += 2;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"--"');
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_postfixExpressionNoImplicitObjectCall() {
              var cacheKey = 'postfixExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_leftHandSideExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_PostfixOperators();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_PostfixOperators();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, ops) {
                  return rp(foldl(function (e, op) {
                    return new postfixConstructorLookup[op](e);
                  }, e, ops));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_leftHandSideExpression() {
              var cacheKey = 'leftHandSideExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_callExpression();
              if (r0 === null) {
                r0 = parse_newExpression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argumentList() {
              var cacheKey = 'argumentList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 63) {
                r3 = '?';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"?"');
                }
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 40) {
                  r4 = '(';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"("');
                  }
                }
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_argumentListContents();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        if (input.charCodeAt(pos) === 41) {
                          r8 = ')';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('")"');
                          }
                        }
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (soaked, a) {
                  return rp({
                    op: soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication,
                    operands: [a || []]
                  });
                }(r3, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argumentListContents() {
              var cacheKey = 'argumentListContents@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_argument();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 === null) {
                    r8 = parse_TERMINATOR();
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_argument();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 === null) {
                      r8 = parse_TERMINATOR();
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_argument();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r5 = ',';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r5 === null) {
                    r5 = parse_TERMINATOR();
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_argumentListContents();
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r6 = parse_TERMINATOR();
                      r6 = r6 !== null ? r6 : '';
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (a) {
                    return a;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_argument() {
              var cacheKey = 'argument@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_expression();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentList() {
              var cacheKey = 'secondaryArgumentList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r6 = pos;
                if (/^[+-\/]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[+-\\/]');
                  }
                }
                if (r7 !== null) {
                  r8 = parse___();
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r5 = parse_secondaryArgument();
                  if (r5 !== null) {
                    r6 = [];
                    r8 = pos;
                    r9 = parse__();
                    if (r9 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r10 = ',';
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_TERMINATOR();
                          r12 = r12 !== null ? r12 : '';
                          if (r12 !== null) {
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_secondaryArgument();
                              if (r14 !== null) {
                                r7 = [
                                  r9,
                                  r10,
                                  r11,
                                  r12,
                                  r13,
                                  r14
                                ];
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_TERMINATOR();
                            r12 = r12 !== null ? r12 : '';
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_secondaryArgument();
                                if (r14 !== null) {
                                  r7 = [
                                    r9,
                                    r10,
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r8;
                                }
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    }
                    if (r6 !== null) {
                      r8 = pos;
                      if (input.charCodeAt(pos) === 44) {
                        r9 = ',';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r10 = parse_TERMINDENT();
                        if (r10 !== null) {
                          r11 = parse_implicitObjectLiteral();
                          if (r11 !== null) {
                            r12 = parse_DEDENT();
                            if (r12 !== null) {
                              r7 = [
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es, obj) {
                  es = [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                  if (obj)
                    es.push(obj[2]);
                  return es;
                }(r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_implicitObjectLiteral();
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (o) {
                    return [o];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgument() {
              var cacheKey = 'secondaryArgument@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_singleLineImplicitObjectLiteral();
                if (r0 === null) {
                  r0 = parse_secondaryExpression();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_leftHandSideExpressionNoImplicitObjectCall() {
              var cacheKey = 'leftHandSideExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_callExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_newExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentListNoImplicitObjectCall() {
              var cacheKey = 'secondaryArgumentListNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r6 = pos;
                if (/^[+-\/]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[+-\\/]');
                  }
                }
                if (r7 !== null) {
                  r8 = parse___();
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r5 = parse_secondaryArgumentNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = [];
                    r8 = pos;
                    r9 = parse__();
                    if (r9 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r10 = ',';
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_TERMINATOR();
                          r12 = r12 !== null ? r12 : '';
                          if (r12 !== null) {
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_secondaryArgumentNoImplicitObjectCall();
                              if (r14 !== null) {
                                r7 = [
                                  r9,
                                  r10,
                                  r11,
                                  r12,
                                  r13,
                                  r14
                                ];
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_TERMINATOR();
                            r12 = r12 !== null ? r12 : '';
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_secondaryArgumentNoImplicitObjectCall();
                                if (r14 !== null) {
                                  r7 = [
                                    r9,
                                    r10,
                                    r11,
                                    r12,
                                    r13,
                                    r14
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r8;
                                }
                              } else {
                                r7 = null;
                                pos = r8;
                              }
                            } else {
                              r7 = null;
                              pos = r8;
                            }
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  es = [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                  return es;
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_secondaryArgumentNoImplicitObjectCall() {
              var cacheKey = 'secondaryArgumentNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_spreadNoImplicitObjectCall();
              if (r0 === null) {
                r0 = parse_secondaryExpressionNoImplicitObjectCall();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpression() {
              var cacheKey = 'callExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_memberExpression();
              if (r3 !== null) {
                r4 = parse_callExpressionAccesses();
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  if (input.charCodeAt(pos) === 63) {
                    r7 = '?';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse_secondaryArgumentList();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (fn, accesses, secondaryArgs) {
                  if (accesses)
                    fn = createMemberExpression(fn, accesses);
                  var soaked, secondaryCtor;
                  if (secondaryArgs) {
                    soaked = secondaryArgs[0];
                    secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                    fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
                  }
                  return fn;
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpressionAccesses() {
              var cacheKey = 'callExpressionAccesses@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_callExpressionAccesses();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (as) {
                  return as;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = parse_argumentList();
                if (r4 === null) {
                  r4 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r3 = [];
                  while (r4 !== null) {
                    r3.push(r4);
                    r4 = parse_argumentList();
                    if (r4 === null) {
                      r4 = parse_MemberAccessOps();
                    }
                  }
                } else {
                  r3 = null;
                }
                if (r3 !== null) {
                  r4 = parse_callExpressionAccesses();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (as, bs) {
                    return as.concat(bs || []);
                  }(r3, r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_callExpressionNoImplicitObjectCall() {
              var cacheKey = 'callExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_memberExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_argumentList();
                if (r5 === null) {
                  r5 = parse_MemberAccessOps();
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_argumentList();
                  if (r5 === null) {
                    r5 = parse_MemberAccessOps();
                  }
                }
                if (r4 !== null) {
                  r6 = pos;
                  if (input.charCodeAt(pos) === 63) {
                    r7 = '?';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?"');
                    }
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse_secondaryArgumentListNoImplicitObjectCall();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (fn, accesses, secondaryArgs) {
                  if (accesses)
                    fn = createMemberExpression(fn, accesses);
                  var soaked, secondaryCtor;
                  if (secondaryArgs) {
                    soaked = secondaryArgs[0];
                    secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                    fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
                  }
                  return fn;
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_newExpression() {
              var cacheKey = 'newExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_memberExpression();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_expressionworthy();
                    if (r5 === null) {
                      r5 = parse_newExpression();
                      if (r5 === null) {
                        r5 = parse_prefixExpression();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.NewOp(e, []));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_newExpressionNoImplicitObjectCall() {
              var cacheKey = 'newExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_memberExpressionNoImplicitObjectCall();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_expressionworthy();
                    if (r5 === null) {
                      r5 = parse_newExpressionNoImplicitObjectCall();
                      if (r5 === null) {
                        r5 = parse_prefixExpressionNoImplicitObjectCall();
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp(new CS.NewOp(e, []));
                  }(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberExpression() {
              var cacheKey = 'memberExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpression();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_MemberAccessOps();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  return createMemberExpression(e, accesses || []);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_memberExpression();
                    if (r5 !== null) {
                      r6 = parse_secondaryArgumentList();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e, args) {
                    return rp(new CS.NewOp(e, args));
                  }(r5, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberAccess() {
              var cacheKey = 'memberAccess@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpression();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r6 = pos;
                r7 = parse_argumentList();
                if (r7 !== null) {
                  r8 = parse_MemberAccessOps();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                if (r5 === null) {
                  r5 = parse_MemberAccessOps();
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    r7 = parse_argumentList();
                    if (r7 !== null) {
                      r8 = parse_MemberAccessOps();
                      if (r8 !== null) {
                        r5 = [
                          r7,
                          r8
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                    if (r5 === null) {
                      r5 = parse_MemberAccessOps();
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  var acc = foldl(function (memo, a) {
                      return memo.concat(a);
                    }, [], accesses);
                  return createMemberExpression(e, acc);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_MemberAccessOps() {
              var cacheKey = 'MemberAccessOps@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 46) {
                  r4 = '.';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_identifierName();
                    if (r6 !== null) {
                      r7 = [];
                      r8 = parse_MemberAccessOps();
                      while (r8 !== null) {
                        r7.push(r8);
                        r8 = parse_MemberAccessOps();
                      }
                      if (r7 !== null) {
                        r8 = parse_DEDENT();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp({
                    op: CS.MemberAccessOp,
                    operands: [e]
                  });
                }(r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINATOR();
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 46) {
                      r5 = '.';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"."');
                      }
                    }
                    if (r5 !== null) {
                      r6 = parse_TERMINATOR();
                      r6 = r6 !== null ? r6 : '';
                      if (r6 !== null) {
                        r7 = parse__();
                        if (r7 !== null) {
                          r8 = parse_identifierName();
                          if (r8 !== null) {
                            r0 = [
                              r3,
                              r4,
                              r5,
                              r6,
                              r7,
                              r8
                            ];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e) {
                    return rp({
                      op: CS.MemberAccessOp,
                      operands: [e]
                    });
                  }(r8);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '?.') {
                    r3 = '?.';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"?."');
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r5 = parse_identifierName();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (e) {
                      return rp({
                        op: CS.SoakedMemberAccessOp,
                        operands: [e]
                      });
                    }(r5);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.substr(pos, 2) === '*.') {
                      r3 = '*.';
                      pos += 2;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"*."');
                      }
                    }
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r5 = parse_identifierName();
                        if (r5 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (e) {
                        return rp({
                          op: CS.NativeMemberAccessOp,
                          operands: [e]
                        });
                      }(r5);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.charCodeAt(pos) === 91) {
                        r3 = '[';
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"["');
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_expression();
                          if (r5 !== null) {
                            r6 = parse__();
                            if (r6 !== null) {
                              if (input.charCodeAt(pos) === 93) {
                                r7 = ']';
                                pos++;
                              } else {
                                r7 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"]"');
                                }
                              }
                              if (r7 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5,
                                  r6,
                                  r7
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function (e) {
                          return rp({
                            op: CS.DynamicMemberAccessOp,
                            operands: [e]
                          });
                        }(r5);
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        r2 = pos;
                        if (input.substr(pos, 2) === '?[') {
                          r3 = '?[';
                          pos += 2;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('"?["');
                          }
                        }
                        if (r3 !== null) {
                          r4 = parse__();
                          if (r4 !== null) {
                            r5 = parse_expression();
                            if (r5 !== null) {
                              r6 = parse__();
                              if (r6 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                  r7 = ']';
                                  pos++;
                                } else {
                                  r7 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"]"');
                                  }
                                }
                                if (r7 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function (e) {
                            return rp({
                              op: CS.SoakedDynamicMemberAccessOp,
                              operands: [e]
                            });
                          }(r5);
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          r2 = pos;
                          if (input.substr(pos, 2) === '::') {
                            r3 = '::';
                            pos += 2;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('"::"');
                            }
                          }
                          if (r3 !== null) {
                            r4 = parse__();
                            if (r4 !== null) {
                              r5 = parse_identifierName();
                              if (r5 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function (e) {
                              return rp({
                                op: CS.ProtoMemberAccessOp,
                                operands: [e]
                              });
                            }(r5);
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            r2 = pos;
                            if (input.substr(pos, 3) === '::[') {
                              r3 = '::[';
                              pos += 3;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('"::["');
                              }
                            }
                            if (r3 !== null) {
                              r4 = parse__();
                              if (r4 !== null) {
                                r5 = parse_expression();
                                if (r5 !== null) {
                                  r6 = parse__();
                                  if (r6 !== null) {
                                    if (input.charCodeAt(pos) === 93) {
                                      r7 = ']';
                                      pos++;
                                    } else {
                                      r7 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"]"');
                                      }
                                    }
                                    if (r7 !== null) {
                                      r0 = [
                                        r3,
                                        r4,
                                        r5,
                                        r6,
                                        r7
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function (e) {
                                return rp({
                                  op: CS.DynamicProtoMemberAccessOp,
                                  operands: [e]
                                });
                              }(r5);
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              r2 = pos;
                              if (input.substr(pos, 3) === '?::') {
                                r3 = '?::';
                                pos += 3;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"?::"');
                                }
                              }
                              if (r3 !== null) {
                                r4 = parse__();
                                if (r4 !== null) {
                                  r5 = parse_identifierName();
                                  if (r5 !== null) {
                                    r0 = [
                                      r3,
                                      r4,
                                      r5
                                    ];
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                              if (r0 !== null) {
                                reportedPos = r1;
                                r0 = function (e) {
                                  return rp({
                                    op: CS.SoakedProtoMemberAccessOp,
                                    operands: [e]
                                  });
                                }(r5);
                              }
                              if (r0 === null) {
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                r2 = pos;
                                if (input.substr(pos, 4) === '?::[') {
                                  r3 = '?::[';
                                  pos += 4;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"?::["');
                                  }
                                }
                                if (r3 !== null) {
                                  r4 = parse__();
                                  if (r4 !== null) {
                                    r5 = parse_expression();
                                    if (r5 !== null) {
                                      r6 = parse__();
                                      if (r6 !== null) {
                                        if (input.charCodeAt(pos) === 93) {
                                          r7 = ']';
                                          pos++;
                                        } else {
                                          r7 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"]"');
                                          }
                                        }
                                        if (r7 !== null) {
                                          r0 = [
                                            r3,
                                            r4,
                                            r5,
                                            r6,
                                            r7
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                                if (r0 !== null) {
                                  reportedPos = r1;
                                  r0 = function (e) {
                                    return rp({
                                      op: CS.SoakedDynamicProtoMemberAccessOp,
                                      operands: [e]
                                    });
                                  }(r5);
                                }
                                if (r0 === null) {
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  r2 = pos;
                                  if (input.charCodeAt(pos) === 91) {
                                    r3 = '[';
                                    pos++;
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"["');
                                    }
                                  }
                                  if (r3 !== null) {
                                    r4 = parse__();
                                    if (r4 !== null) {
                                      r5 = parse_assignmentExpression();
                                      r5 = r5 !== null ? r5 : '';
                                      if (r5 !== null) {
                                        r6 = parse__();
                                        if (r6 !== null) {
                                          if (input.substr(pos, 2) === '..') {
                                            r7 = '..';
                                            pos += 2;
                                          } else {
                                            r7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('".."');
                                            }
                                          }
                                          if (r7 !== null) {
                                            if (input.charCodeAt(pos) === 46) {
                                              r8 = '.';
                                              pos++;
                                            } else {
                                              r8 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"."');
                                              }
                                            }
                                            r8 = r8 !== null ? r8 : '';
                                            if (r8 !== null) {
                                              r9 = parse__();
                                              if (r9 !== null) {
                                                r10 = parse_assignmentExpression();
                                                r10 = r10 !== null ? r10 : '';
                                                if (r10 !== null) {
                                                  r11 = parse__();
                                                  if (r11 !== null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      r12 = ']';
                                                      pos++;
                                                    } else {
                                                      r12 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed('"]"');
                                                      }
                                                    }
                                                    if (r12 !== null) {
                                                      r0 = [
                                                        r3,
                                                        r4,
                                                        r5,
                                                        r6,
                                                        r7,
                                                        r8,
                                                        r9,
                                                        r10,
                                                        r11,
                                                        r12
                                                      ];
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                  if (r0 !== null) {
                                    reportedPos = r1;
                                    r0 = function (left, exclusive, right) {
                                      return rp({
                                        op: CS.Slice,
                                        operands: [
                                          !exclusive,
                                          left || null,
                                          right || null
                                        ]
                                      });
                                    }(r5, r8, r10);
                                  }
                                  if (r0 === null) {
                                    pos = r1;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberExpressionNoImplicitObjectCall() {
              var cacheKey = 'memberExpressionNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_primaryExpression();
              if (r3 === null) {
                r4 = pos;
                r5 = pos;
                r6 = parse_NEW();
                if (r6 !== null) {
                  r7 = parse___();
                  if (r7 !== null) {
                    r8 = parse_memberExpressionNoImplicitObjectCall();
                    if (r8 !== null) {
                      r9 = parse_argumentList();
                      if (r9 !== null) {
                        r3 = [
                          r6,
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r3 = null;
                        pos = r5;
                      }
                    } else {
                      r3 = null;
                      pos = r5;
                    }
                  } else {
                    r3 = null;
                    pos = r5;
                  }
                } else {
                  r3 = null;
                  pos = r5;
                }
                if (r3 !== null) {
                  reportedPos = r4;
                  r3 = function (e, args) {
                    return rp(new CS.NewOp(e, args.operands[0]));
                  }(r8, r9);
                }
                if (r3 === null) {
                  pos = r4;
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_MemberAccessOps();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_MemberAccessOps();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, accesses) {
                  return createMemberExpression(e, accesses || []);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_NEW();
                if (r3 !== null) {
                  r4 = parse___();
                  if (r4 !== null) {
                    r5 = parse_memberExpressionNoImplicitObjectCall();
                    if (r5 !== null) {
                      r6 = parse_secondaryArgumentListNoImplicitObjectCall();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (e, args) {
                    return rp(new CS.NewOp(e, args));
                  }(r5, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_primaryExpression() {
              var cacheKey = 'primaryExpression@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r0 = parse_macro();
              if (r0 === null) {
                r0 = parse_Numbers();
                if (r0 === null) {
                  r0 = parse_bool();
                  if (r0 === null) {
                    r0 = parse_null();
                    if (r0 === null) {
                      r0 = parse_undefined();
                      if (r0 === null) {
                        r0 = parse_contextVar();
                        if (r0 === null) {
                          r1 = pos;
                          r0 = parse_SUPER();
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function () {
                              return rp(new CS.Super);
                            }();
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            r0 = parse_THIS();
                            if (r0 === null) {
                              if (input.charCodeAt(pos) === 64) {
                                r0 = '@';
                                pos++;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"@"');
                                }
                              }
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function () {
                                return rp(new CS.This);
                              }();
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r0 = parse_identifier();
                              if (r0 === null) {
                                r0 = parse_range();
                                if (r0 === null) {
                                  r0 = parse_arrayLiteral();
                                  if (r0 === null) {
                                    r0 = parse_objectLiteral();
                                    if (r0 === null) {
                                      r0 = parse_interpolation();
                                      if (r0 === null) {
                                        r0 = parse_JSLiteral();
                                        if (r0 === null) {
                                          r0 = parse_string();
                                          if (r0 === null) {
                                            r0 = parse_regexp();
                                            if (r0 === null) {
                                              r1 = pos;
                                              r2 = pos;
                                              if (input.charCodeAt(pos) === 40) {
                                                r3 = '(';
                                                pos++;
                                              } else {
                                                r3 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"("');
                                                }
                                              }
                                              if (r3 !== null) {
                                                r4 = parse_TERMINDENT();
                                                if (r4 !== null) {
                                                  r5 = parse_expression();
                                                  if (r5 !== null) {
                                                    r6 = parse_DEDENT();
                                                    if (r6 !== null) {
                                                      r7 = parse_TERMINATOR();
                                                      r7 = r7 !== null ? r7 : '';
                                                      if (r7 !== null) {
                                                        if (input.charCodeAt(pos) === 41) {
                                                          r8 = ')';
                                                          pos++;
                                                        } else {
                                                          r8 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed('")"');
                                                          }
                                                        }
                                                        if (r8 !== null) {
                                                          r0 = [
                                                            r3,
                                                            r4,
                                                            r5,
                                                            r6,
                                                            r7,
                                                            r8
                                                          ];
                                                        } else {
                                                          r0 = null;
                                                          pos = r2;
                                                        }
                                                      } else {
                                                        r0 = null;
                                                        pos = r2;
                                                      }
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                              if (r0 !== null) {
                                                reportedPos = r1;
                                                r0 = function (e) {
                                                  return r(e.clone());
                                                }(r5);
                                              }
                                              if (r0 === null) {
                                                pos = r1;
                                              }
                                              if (r0 === null) {
                                                r1 = pos;
                                                r2 = pos;
                                                if (input.charCodeAt(pos) === 40) {
                                                  r3 = '(';
                                                  pos++;
                                                } else {
                                                  r3 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"("');
                                                  }
                                                }
                                                if (r3 !== null) {
                                                  r4 = parse__();
                                                  if (r4 !== null) {
                                                    r5 = parse_expression();
                                                    if (r5 !== null) {
                                                      r6 = parse__();
                                                      if (r6 !== null) {
                                                        r7 = parse_TERMINATOR();
                                                        r7 = r7 !== null ? r7 : '';
                                                        if (r7 !== null) {
                                                          r8 = parse__();
                                                          if (r8 !== null) {
                                                            if (input.charCodeAt(pos) === 41) {
                                                              r9 = ')';
                                                              pos++;
                                                            } else {
                                                              r9 = null;
                                                              if (reportFailures === 0) {
                                                                matchFailed('")"');
                                                              }
                                                            }
                                                            if (r9 !== null) {
                                                              r0 = [
                                                                r3,
                                                                r4,
                                                                r5,
                                                                r6,
                                                                r7,
                                                                r8,
                                                                r9
                                                              ];
                                                            } else {
                                                              r0 = null;
                                                              pos = r2;
                                                            }
                                                          } else {
                                                            r0 = null;
                                                            pos = r2;
                                                          }
                                                        } else {
                                                          r0 = null;
                                                          pos = r2;
                                                        }
                                                      } else {
                                                        r0 = null;
                                                        pos = r2;
                                                      }
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                                if (r0 !== null) {
                                                  reportedPos = r1;
                                                  r0 = function (e) {
                                                    return r(e.clone());
                                                  }(r5);
                                                }
                                                if (r0 === null) {
                                                  pos = r1;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_contextVar() {
              var cacheKey = 'contextVar@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 64) {
                r3 = '@';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"@"');
                }
              }
              if (r3 !== null) {
                reportedPos = r4;
                r3 = function () {
                  return rp(new CS.This);
                }();
              }
              if (r3 === null) {
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, m) {
                  return rp(new CS.MemberAccessOp(a, m));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_JSLiteral() {
              var cacheKey = 'JSLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 96) {
                r3 = '`';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"`"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                r4 = [];
                if (/^[^`]/.test(input.charAt(pos))) {
                  r6 = input.charAt(pos);
                  pos++;
                } else {
                  r6 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^`]');
                  }
                }
                while (r6 !== null) {
                  r4.push(r6);
                  if (/^[^`]/.test(input.charAt(pos))) {
                    r6 = input.charAt(pos);
                    pos++;
                  } else {
                    r6 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^`]');
                    }
                  }
                }
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 96) {
                    r5 = '`';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"`"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return rp(new CS.JavaScript(d));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_spread() {
              var cacheKey = 'spread@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixExpression();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Spread(e));
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_spreadNoImplicitObjectCall() {
              var cacheKey = 'spreadNoImplicitObjectCall@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_postfixExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Spread(e));
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_conditional() {
              var cacheKey = 'conditional@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_IF();
              if (r3 === null) {
                r3 = parse_UNLESS();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r7 = parse_elseClause();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, cond, body, elseClause) {
                  var constructor = 'unless' === kw ? CS.NegatedConditional : CS.Conditional;
                  if ('unless' === kw)
                    cond = new CS.LogicalNotOp(cond).g();
                  return rp(new constructor(cond, body.block, elseClause || null));
                }(r3, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_conditionalBody() {
              var cacheKey = 'conditionalBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_block();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return { block: b };
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINATOR();
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_THEN();
                    if (r5 !== null) {
                      r6 = parse__();
                      if (r6 !== null) {
                        r7 = parse_statement();
                        if (r7 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (s) {
                    return { block: s };
                  }(r7);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse__();
                  if (r3 !== null) {
                    r4 = parse_THEN();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return { block: null };
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_elseClause() {
              var cacheKey = 'elseClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINATOR();
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    r6 = parse_ELSE();
                    if (r6 !== null) {
                      r7 = parse_functionBody();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return b;
                }(r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_while() {
              var cacheKey = 'while@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_WHILE();
              if (r3 === null) {
                r3 = parse_UNTIL();
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (kw, cond, body) {
                  var constructor = 'until' === kw ? CS.NegatedWhile : CS.While;
                  if ('until' === kw)
                    cond = new CS.LogicalNotOp(cond).g();
                  return rp(new constructor(cond, body.block));
                }(r3, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_loop() {
              var cacheKey = 'loop@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_LOOP();
              if (r3 !== null) {
                r4 = parse_conditionalBody();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body) {
                  return rp(new CS.Loop(body.block));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_try() {
              var cacheKey = 'try@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_TRY();
              if (r3 !== null) {
                r4 = parse_tryBody();
                if (r4 !== null) {
                  r5 = parse_catchClause();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_finallyClause();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body, c, f) {
                  return rp(new CS.Try(body.block, c ? c.assignee : null, c ? c.block : null, f ? f.block : null));
                }(r4, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_tryBody() {
              var cacheKey = 'tryBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_functionBody();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return { block: b };
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_catchClause() {
              var cacheKey = 'catchClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_CATCH();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_Assignable();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r8 = parse_conditionalBody();
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, body) {
                  return r({
                    block: body ? body.block : new CS.Block([]),
                    assignee: e || null
                  });
                }(r7, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_finallyClause() {
              var cacheKey = 'finallyClause@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_FINALLY();
                  if (r5 !== null) {
                    r6 = parse_tryBody();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (body) {
                  return r({ block: body ? body.block : null });
                }(r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixin() {
              var cacheKey = 'mixin@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_MIXIN();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_WITH();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_mixinList();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse__();
                    if (r8 !== null) {
                      r9 = parse_mixinBody();
                      if (r9 !== null) {
                        r6 = [
                          r8,
                          r9
                        ];
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, mixins, body) {
                  name = name ? name[1] : null;
                  if (mixins)
                    mixins = mixins[3];
                  body = body ? body[1] : null;
                  return rp(new CS.Mixin(name, body, mixins));
                }(r4, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixinList() {
              var cacheKey = 'mixinList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_secondaryExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r9 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r8 = [
                        r10,
                        r11
                      ];
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                  } else {
                    r8 = null;
                    pos = r9;
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_secondaryExpressionNoImplicitObjectCall();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r9 = pos;
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r8 = [
                          r10,
                          r11
                        ];
                      } else {
                        r8 = null;
                        pos = r9;
                      }
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_mixinBody() {
              var cacheKey = 'mixinBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_objectLiteral();
              if (r0 === null) {
                r0 = parse_implicitObjectLiteral();
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse_TERMINDENT();
                if (r3 !== null) {
                  r4 = parse_objectLiteral();
                  if (r4 === null) {
                    r4 = parse_implicitObjectLiteral();
                  }
                  if (r4 !== null) {
                    r5 = parse_DEDENT();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (t, body, d) {
                    return body;
                  }(r3, r4, r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_class() {
              var cacheKey = 'class@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_CLASS();
              if (r3 !== null) {
                r5 = pos;
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_EXTENDS();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse__();
                    if (r8 !== null) {
                      r9 = parse_WITH();
                      if (r9 !== null) {
                        r10 = parse__();
                        if (r10 !== null) {
                          r11 = parse_mixinList();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r8 = pos;
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_mixinBody();
                        if (r10 !== null) {
                          r7 = [
                            r9,
                            r10
                          ];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, parent, mixins, body) {
                  var ctor = null;
                  name = name ? name[1] : null;
                  parent = parent ? parent[3] : null;
                  var boundMembers = [];
                  body = body ? body[1] : null;
                  if (mixins)
                    mixins = mixins[3];
                  return rp(new CS.Class(name, parent, ctor, body, mixins, boundMembers));
                }(r4, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_forOf() {
              var cacheKey = 'forOf@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
              r1 = pos;
              r2 = pos;
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse_OWN();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_Assignable();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r9 = pos;
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ',';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('","');
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_Assignable();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r8 = [
                                  r10,
                                  r11,
                                  r12,
                                  r13
                                ];
                              } else {
                                r8 = null;
                                pos = r9;
                              }
                            } else {
                              r8 = null;
                              pos = r9;
                            }
                          } else {
                            r8 = null;
                            pos = r9;
                          }
                        } else {
                          r8 = null;
                          pos = r9;
                        }
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r9 = parse_OF();
                          if (r9 !== null) {
                            r10 = parse__();
                            if (r10 !== null) {
                              r11 = parse_assignmentExpressionNoImplicitObjectCall();
                              if (r11 !== null) {
                                r12 = parse__();
                                if (r12 !== null) {
                                  r14 = pos;
                                  r15 = parse_WHEN();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r17 = parse_assignmentExpressionNoImplicitObjectCall();
                                      if (r17 !== null) {
                                        r18 = parse__();
                                        if (r18 !== null) {
                                          r13 = [
                                            r15,
                                            r16,
                                            r17,
                                            r18
                                          ];
                                        } else {
                                          r13 = null;
                                          pos = r14;
                                        }
                                      } else {
                                        r13 = null;
                                        pos = r14;
                                      }
                                    } else {
                                      r13 = null;
                                      pos = r14;
                                    }
                                  } else {
                                    r13 = null;
                                    pos = r14;
                                  }
                                  r13 = r13 !== null ? r13 : '';
                                  if (r13 !== null) {
                                    r14 = parse_conditionalBody();
                                    if (r14 !== null) {
                                      r0 = [
                                        r3,
                                        r4,
                                        r5,
                                        r6,
                                        r7,
                                        r8,
                                        r9,
                                        r10,
                                        r11,
                                        r12,
                                        r13,
                                        r14
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (own, key, maybeVal, obj, maybeFilter, body) {
                  var val = maybeVal ? maybeVal[2] : null;
                  var filter = maybeFilter ? maybeFilter[2] : null;
                  return rp(new CS.ForOf(!!own, key, val, obj, filter, body.block));
                }(r5, r6, r8, r11, r13, r14);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_forIn() {
              var cacheKey = 'forIn@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
              r1 = pos;
              r2 = pos;
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse_Assignable();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r10 = pos;
                      if (input.charCodeAt(pos) === 44) {
                        r11 = ',';
                        pos++;
                      } else {
                        r11 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r11 !== null) {
                        r12 = parse__();
                        if (r12 !== null) {
                          r13 = parse_Assignable();
                          if (r13 !== null) {
                            r14 = parse__();
                            if (r14 !== null) {
                              r9 = [
                                r11,
                                r12,
                                r13,
                                r14
                              ];
                            } else {
                              r9 = null;
                              pos = r10;
                            }
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                        } else {
                          r9 = null;
                          pos = r10;
                        }
                      } else {
                        r9 = null;
                        pos = r10;
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_IN();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_assignmentExpressionNoImplicitObjectCall();
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r11 = pos;
                            r12 = parse_BY();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r14 = parse_assignmentExpressionNoImplicitObjectCall();
                                if (r14 !== null) {
                                  r15 = parse__();
                                  if (r15 !== null) {
                                    r10 = [
                                      r12,
                                      r13,
                                      r14,
                                      r15
                                    ];
                                  } else {
                                    r10 = null;
                                    pos = r11;
                                  }
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                              } else {
                                r10 = null;
                                pos = r11;
                              }
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            r10 = r10 !== null ? r10 : '';
                            if (r10 !== null) {
                              r12 = pos;
                              r13 = parse_WHEN();
                              if (r13 !== null) {
                                r14 = parse__();
                                if (r14 !== null) {
                                  r15 = parse_assignmentExpressionNoImplicitObjectCall();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r11 = [
                                        r13,
                                        r14,
                                        r15,
                                        r16
                                      ];
                                    } else {
                                      r11 = null;
                                      pos = r12;
                                    }
                                  } else {
                                    r11 = null;
                                    pos = r12;
                                  }
                                } else {
                                  r11 = null;
                                  pos = r12;
                                }
                              } else {
                                r11 = null;
                                pos = r12;
                              }
                              r11 = r11 !== null ? r11 : '';
                              if (r11 !== null) {
                                r12 = parse_conditionalBody();
                                if (r12 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (maybeVal, list, maybeStep, maybeFilter, body) {
                  var val = maybeVal ? maybeVal[0] : null;
                  var key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null;
                  var step = maybeStep ? maybeStep[2] : new CS.Int(1).r('1').g();
                  var filter = maybeFilter ? maybeFilter[2] : null;
                  return rp(new CS.ForIn(val, key, list, step, filter, body.block));
                }(r5, r8, r10, r11, r12);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switch() {
              var cacheKey = 'switch@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_SWITCH();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_expressionworthy();
                  if (r5 === null) {
                    r5 = parse_assignmentExpression();
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_switchBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, body) {
                  return rp(new CS.Switch(e || null, body.cases, body['else'] || null));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switchBody() {
              var cacheKey = 'switchBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_switchBlock();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return r({
                    cases: b.cases,
                    'else': b['else']
                  });
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_THEN();
                  if (r4 !== null) {
                    r5 = parse__();
                    if (r5 !== null) {
                      r6 = parse_case();
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (c) {
                    return r({ cases: [c] });
                  }(r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse__();
                  if (r3 !== null) {
                    r4 = parse_THEN();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return r({ cases: [] });
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_switchBlock() {
              var cacheKey = 'switchBlock@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_case();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_TERMINATOR();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_case();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_case();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_TERMINATOR();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_elseClause();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse_TERMINATOR();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (c, cs, elseClause) {
                  var cases = [c].concat(cs.map(function (w) {
                      return w[3];
                    }));
                  return r({
                    cases: cases,
                    'else': elseClause ? elseClause[3] : null
                  });
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_case() {
              var cacheKey = 'case@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse_WHEN();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_caseConditions();
                  if (r5 !== null) {
                    r6 = parse_conditionalBody();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (conditions, body) {
                  return rp(new CS.SwitchCase(conditions, body.block));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_caseConditions() {
              var cacheKey = 'caseConditions@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_assignmentExpressionNoImplicitObjectCall();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_assignmentExpressionNoImplicitObjectCall();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_assignmentExpressionNoImplicitObjectCall();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (c, cs) {
                  return [c].concat(cs.map(function (c) {
                    return c[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_functionLiteral() {
              var cacheKey = 'functionLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 40) {
                r5 = '(';
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed('"("');
                }
              }
              if (r5 !== null) {
                r6 = parse__();
                if (r6 !== null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINDENT();
                  if (r10 !== null) {
                    r11 = parse_parameterList();
                    if (r11 !== null) {
                      r12 = parse_DEDENT();
                      if (r12 !== null) {
                        r13 = parse_TERMINATOR();
                        if (r13 !== null) {
                          r7 = [
                            r10,
                            r11,
                            r12,
                            r13
                          ];
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = function (p) {
                      return p;
                    }(r11);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                  if (r7 === null) {
                    r7 = parse_parameterList();
                  }
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        r9 = ')';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('")"');
                        }
                      }
                      if (r9 !== null) {
                        r10 = parse__();
                        if (r10 !== null) {
                          r3 = [
                            r5,
                            r6,
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r3 = null;
                          pos = r4;
                        }
                      } else {
                        r3 = null;
                        pos = r4;
                      }
                    } else {
                      r3 = null;
                      pos = r4;
                    }
                  } else {
                    r3 = null;
                    pos = r4;
                  }
                } else {
                  r3 = null;
                  pos = r4;
                }
              } else {
                r3 = null;
                pos = r4;
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.substr(pos, 2) === '->') {
                  r4 = '->';
                  pos += 2;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"->"');
                  }
                }
                if (r4 === null) {
                  if (input.substr(pos, 2) === '=>') {
                    r4 = '=>';
                    pos += 2;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('"=>"');
                    }
                  }
                  if (r4 === null) {
                    if (input.substr(pos, 2) === '~>') {
                      r4 = '~>';
                      pos += 2;
                    } else {
                      r4 = null;
                      if (reportFailures === 0) {
                        matchFailed('"~>"');
                      }
                    }
                  }
                }
                if (r4 !== null) {
                  r5 = parse_functionBody();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (params, arrow, body) {
                  var constructor;
                  switch (arrow) {
                  case '->':
                    constructor = CS.Function;
                    break;
                  case '=>':
                    constructor = CS.BoundFunction;
                    break;
                  case '~>':
                    constructor = CS.ComputedProperty;
                    break;
                  default:
                    throw new Error('parsed function arrow ("' + arrow + '") not associated with a constructor');
                  }
                  return rp(new constructor(params && params[2] || [], body || null));
                }(r3, r4, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_functionBody() {
              var cacheKey = 'functionBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              r3 = parse__();
              if (r3 !== null) {
                r4 = parse_TERMINDENT();
                if (r4 !== null) {
                  r5 = parse_block();
                  if (r5 !== null) {
                    r6 = parse_DEDENT();
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (b) {
                  return b;
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_statement();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (s) {
                    return s;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_parameter() {
              var cacheKey = 'parameter@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    r5 = '=';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"="');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_secondaryExpression();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (param, default_) {
                  return rp(new CS.DefaultParam(param, default_));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r0 = parse_rest();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_rest() {
              var cacheKey = 'rest@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_Assignable();
              if (r3 !== null) {
                if (input.substr(pos, 3) === '...') {
                  r4 = '...';
                  pos += 3;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"..."');
                  }
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, rest) {
                  return rp(rest ? new CS.Rest(a) : a);
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_parameterList() {
              var cacheKey = 'parameterList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_parameter();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  r9 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r8 = [
                        r10,
                        r11
                      ];
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                  } else {
                    r8 = null;
                    pos = r9;
                  }
                  if (r8 === null) {
                    r8 = parse_TERMINATOR();
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_parameter();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    r9 = pos;
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r8 = [
                          r10,
                          r11
                        ];
                      } else {
                        r8 = null;
                        pos = r9;
                      }
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                    if (r8 === null) {
                      r8 = parse_TERMINATOR();
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_parameter();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_range() {
              var cacheKey = 'range@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.substr(pos, 2) === '..') {
                        r7 = '..';
                        pos += 2;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('".."');
                        }
                      }
                      if (r7 !== null) {
                        if (input.charCodeAt(pos) === 46) {
                          r8 = '.';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"."');
                          }
                        }
                        r8 = r8 !== null ? r8 : '';
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r10 = parse_secondaryExpression();
                            if (r10 !== null) {
                              r11 = parse__();
                              if (r11 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                  r12 = ']';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"]"');
                                  }
                                }
                                if (r12 !== null) {
                                  r0 = [
                                    r3,
                                    r4,
                                    r5,
                                    r6,
                                    r7,
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (left, exclusiveDot, right) {
                  var inclusive = !exclusiveDot;
                  return rp(new CS.Range(inclusive, left, right));
                }(r5, r8, r10);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteral() {
              var cacheKey = 'arrayLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse_arrayLiteralBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 93) {
                        r7 = ']';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"]"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ArrayInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralBody() {
              var cacheKey = 'arrayLiteralBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_arrayLiteralMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_arrayLiteralMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMemberList() {
              var cacheKey = 'arrayLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_arrayLiteralMember();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = [];
                  r7 = pos;
                  r8 = parse_arrayLiteralMemberSeparator();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_arrayLiteralMember();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10,
                            r11
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    r7 = pos;
                    r8 = parse_arrayLiteralMemberSeparator();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_arrayLiteralMember();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse_arrayLiteralMemberSeparator();
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[2];
                  }));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMember() {
              var cacheKey = 'arrayLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_spread();
              if (r0 === null) {
                r0 = parse_expression();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_TERMINDENT();
                  if (r3 !== null) {
                    r4 = parse_implicitObjectLiteral();
                    if (r4 !== null) {
                      r5 = parse_DEDENT();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (o) {
                      return o;
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_arrayLiteralMemberSeparator() {
              var cacheKey = 'arrayLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r5 = ',';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                if (r3 !== null) {
                  r4 = parse_TERMINATOR();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r5 = parse__();
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_annotation() {
              var cacheKey = 'annotation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 43) {
                r3 = '+';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"+"');
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.substr(pos, 8) === 'computed') {
                    r5 = 'computed';
                    pos += 8;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"computed"');
                    }
                  }
                  if (r5 === null) {
                    if (input.substr(pos, 8) === 'observer') {
                      r5 = 'observer';
                      pos += 8;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"observer"');
                      }
                    }
                    if (r5 === null) {
                      if (input.substr(pos, 8) === 'volatile') {
                        r5 = 'volatile';
                        pos += 8;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"volatile"');
                        }
                      }
                    }
                  }
                  if (r5 !== null) {
                    r7 = pos;
                    r8 = parse___();
                    if (r8 !== null) {
                      r9 = parse_annotationParameterList();
                      if (r9 !== null) {
                        r6 = [
                          r8,
                          r9
                        ];
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r7 = parse_TERMINATOR();
                      r7 = r7 !== null ? r7 : '';
                      if (r7 !== null) {
                        r8 = parse__();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (name, params) {
                  var constructor;
                  switch (name) {
                  case 'computed':
                    constructor = CS.Computed;
                    break;
                  case 'observer':
                    constructor = CS.Observes;
                    break;
                  case 'volatile':
                    constructor = CS.Volatile;
                    break;
                  default:
                    throw new Error('No such annotation: ' + name);
                  }
                  if (params)
                    params = params[1];
                  return rp(new constructor(params || []));
                }(r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_annotationParameterList() {
              var cacheKey = 'annotationParameterList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_propertyChain();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r8 = pos;
                r9 = parse__();
                if (r9 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ',';
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : '';
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r7 = [
                          r9,
                          r10,
                          r11,
                          r12
                        ];
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
                if (r7 === null) {
                  r7 = parse___();
                }
                if (r7 !== null) {
                  r8 = parse_propertyChain();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r8 = pos;
                  r9 = parse__();
                  if (r9 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r10 = ',';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r10 !== null) {
                      r11 = parse_TERMINATOR();
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r12 = parse__();
                        if (r12 !== null) {
                          r7 = [
                            r9,
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                  if (r7 === null) {
                    r7 = parse___();
                  }
                  if (r7 !== null) {
                    r8 = parse_propertyChain();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteral() {
              var cacheKey = 'objectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 123) {
                r3 = '{';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"{"');
                }
              }
              if (r3 !== null) {
                r4 = parse_objectLiteralBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        r7 = '}';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"}"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralBody() {
              var cacheKey = 'objectLiteralBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_objectLiteralMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_objectLiteralMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralMemberList() {
              var cacheKey = 'objectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              r3 = parse_objectLiteralMember();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = [];
                  r7 = pos;
                  r8 = parse_arrayLiteralMemberSeparator();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_objectLiteralMember();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10,
                            r11
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    r7 = pos;
                    r8 = parse_arrayLiteralMemberSeparator();
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_objectLiteralMember();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10,
                              r11
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r6 = ',';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    r6 = r6 !== null ? r6 : '';
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[2];
                  }));
                }(r3, r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_objectLiteralMember() {
              var cacheKey = 'objectLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r0 = parse_implicitObjectLiteralMember();
              if (r0 === null) {
                r1 = pos;
                r0 = parse_contextVar();
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (v) {
                    var key = p(new CS.String(v.memberName).g());
                    return rp(new CS.ObjectInitialiserMember(key, v));
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r0 = parse_ObjectInitialiserKeys();
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (v) {
                      return rp(new CS.ObjectInitialiserMember(v, v));
                    }(r0);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ObjectInitialiserKeys() {
              var cacheKey = 'ObjectInitialiserKeys@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_identifierName();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (i) {
                  return rp(new CS.Identifier(i));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r0 = parse_string();
                if (r0 === null) {
                  r0 = parse_Numbers();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteral() {
              var cacheKey = 'implicitObjectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_implicitObjectLiteralMemberList();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberList() {
              var cacheKey = 'implicitObjectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_implicitObjectLiteralMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_implicitObjectLiteralMemberSeparator();
                if (r7 !== null) {
                  r8 = parse_implicitObjectLiteralMember();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_implicitObjectLiteralMemberSeparator();
                  if (r7 !== null) {
                    r8 = parse_implicitObjectLiteralMember();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberSeparator() {
              var cacheKey = 'implicitObjectLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = parse_TERMINATOR();
              if (r2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                r3 = r3 !== null ? r3 : '';
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r0 = [
                      r2,
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = parse__();
                if (r2 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r3 = ',';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse_TERMINATOR();
                    r4 = r4 !== null ? r4 : '';
                    if (r4 !== null) {
                      r5 = parse__();
                      if (r5 !== null) {
                        r0 = [
                          r2,
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMember() {
              var cacheKey = 'implicitObjectLiteralMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = [];
              r4 = parse_annotation();
              while (r4 !== null) {
                r3.push(r4);
                r4 = parse_annotation();
              }
              if (r3 !== null) {
                r4 = parse_ObjectInitialiserKeys();
                if (r4 !== null) {
                  r5 = parse__();
                  if (r5 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      r6 = ':';
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('":"');
                      }
                    }
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r8 = parse_implicitObjectLiteralMemberValue();
                        if (r8 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5,
                            r6,
                            r7,
                            r8
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (annotations, key, val) {
                  return rp(new CS.ObjectInitialiserMember(key, val, annotations));
                }(r3, r4, r8);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_implicitObjectLiteralMemberValue() {
              var cacheKey = 'implicitObjectLiteralMemberValue@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r0 = parse_singleLineImplicitObjectLiteral();
              if (r0 === null) {
                r0 = parse_expression();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = parse_TERMINDENT();
                  if (r3 !== null) {
                    r4 = parse_expression();
                    if (r4 !== null) {
                      r5 = parse_DEDENT();
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (o) {
                      return o;
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteral() {
              var cacheKey = 'singleLineImplicitObjectLiteral@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_singleLineImplicitObjectLiteralMemberList();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteralMemberList() {
              var cacheKey = 'singleLineImplicitObjectLiteralMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_implicitObjectLiteralMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
                if (r7 !== null) {
                  r8 = parse_implicitObjectLiteralMember();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
                  if (r7 !== null) {
                    r8 = parse_implicitObjectLiteralMember();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[1];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineImplicitObjectLiteralMemberSeparator() {
              var cacheKey = 'singleLineImplicitObjectLiteralMemberSeparator@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = parse__();
              if (r2 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r3 = ',';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('","');
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r0 = [
                      r2,
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_macro() {
              var cacheKey = 'macro@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              if (input.substr(pos, 8) === '__LINE__') {
                r0 = '__LINE__';
                pos += 8;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"__LINE__"');
                }
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Int(line()));
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                if (input.substr(pos, 12) === '__FILENAME__') {
                  r0 = '__FILENAME__';
                  pos += 12;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"__FILENAME__"');
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return rp(new CS.String(options.inputSource || ''));
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.substr(pos, 8) === '__DATE__') {
                    r0 = '__DATE__';
                    pos += 8;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"__DATE__"');
                    }
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function () {
                      return rp(new CS.String(new Date().toDateString().slice(4)));
                    }();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.substr(pos, 8) === '__TIME__') {
                      r0 = '__TIME__';
                      pos += 8;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"__TIME__"');
                      }
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function () {
                        return rp(new CS.String(new Date().toTimeString().slice(0, 8)));
                      }();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.substr(pos, 14) === '__DATETIMEMS__') {
                        r0 = '__DATETIMEMS__';
                        pos += 14;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"__DATETIMEMS__"');
                        }
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function () {
                          return rp(new CS.Int(+new Date));
                        }();
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.substr(pos, 18) === '__COFFEE_VERSION__') {
                          r0 = '__COFFEE_VERSION__';
                          pos += 18;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"__COFFEE_VERSION__"');
                          }
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function () {
                            return rp(new CS.String(require('/package.json', module).version));
                          }();
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_bool() {
              var cacheKey = 'bool@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_TRUE();
              if (r0 === null) {
                r0 = parse_YES();
                if (r0 === null) {
                  r0 = parse_ON();
                }
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Bool(true));
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r0 = parse_FALSE();
                if (r0 === null) {
                  r0 = parse_NO();
                  if (r0 === null) {
                    r0 = parse_OFF();
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return rp(new CS.Bool(false));
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_Numbers() {
              var cacheKey = 'Numbers@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === '0b') {
                r3 = '0b';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"0b"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                r6 = parse_bit();
                if (r6 !== null) {
                  r4 = [];
                  while (r6 !== null) {
                    r4.push(r6);
                    r6 = parse_bit();
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (bs) {
                  return rp(new CS.Int(parseInt(bs, 2)));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 2) === '0o') {
                  r3 = '0o';
                  pos += 2;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"0o"');
                  }
                }
                if (r3 !== null) {
                  r5 = pos;
                  r6 = parse_octalDigit();
                  if (r6 !== null) {
                    r4 = [];
                    while (r6 !== null) {
                      r4.push(r6);
                      r6 = parse_octalDigit();
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    r4 = input.substring(pos, r5);
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (os) {
                    return rp(new CS.Int(parseInt(os, 8)));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '0x') {
                    r3 = '0x';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"0x"');
                    }
                  }
                  if (r3 !== null) {
                    r5 = pos;
                    r6 = parse_hexDigit();
                    if (r6 !== null) {
                      r4 = [];
                      while (r6 !== null) {
                        r4.push(r6);
                        r6 = parse_hexDigit();
                      }
                    } else {
                      r4 = null;
                    }
                    if (r4 !== null) {
                      r4 = input.substring(pos, r5);
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (hs) {
                      return rp(new CS.Int(parseInt(hs, 16)));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    r3 = parse_decimal();
                    if (r3 !== null) {
                      if (/^[eE]/.test(input.charAt(pos))) {
                        r4 = input.charAt(pos);
                        pos++;
                      } else {
                        r4 = null;
                        if (reportFailures === 0) {
                          matchFailed('[eE]');
                        }
                      }
                      if (r4 !== null) {
                        if (/^[+\-]/.test(input.charAt(pos))) {
                          r5 = input.charAt(pos);
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('[+\\-]');
                          }
                        }
                        r5 = r5 !== null ? r5 : '';
                        if (r5 !== null) {
                          r6 = parse_decimal();
                          if (r6 !== null) {
                            r0 = [
                              r3,
                              r4,
                              r5,
                              r6
                            ];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (base, e, sign, exponent) {
                        return rp(new CS.Float(parseFloat('' + base.data + e + sign + exponent.data, 10)));
                      }(r3, r4, r5, r6);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r0 = parse_decimal();
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_decimal() {
              var cacheKey = 'decimal@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
              r1 = pos;
              r2 = pos;
              r3 = parse_integer();
              if (r3 !== null) {
                r5 = pos;
                r6 = pos;
                if (input.charCodeAt(pos) === 46) {
                  r7 = '.';
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r7 !== null) {
                  r9 = parse_decimalDigit();
                  if (r9 !== null) {
                    r8 = [];
                    while (r9 !== null) {
                      r8.push(r9);
                      r9 = parse_decimalDigit();
                    }
                  } else {
                    r8 = null;
                  }
                  if (r8 !== null) {
                    r4 = [
                      r7,
                      r8
                    ];
                  } else {
                    r4 = null;
                    pos = r6;
                  }
                } else {
                  r4 = null;
                  pos = r6;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r4 = input.substring(pos, r5);
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (integral, fractional) {
                  return fractional ? rp(new CS.Float(parseFloat(integral + fractional, 10))) : rp(new CS.Int(+integral));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_integer() {
              var cacheKey = 'integer@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              if (input.charCodeAt(pos) === 48) {
                r0 = '0';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"0"');
                }
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (/^[1-9]/.test(input.charAt(pos))) {
                  r3 = input.charAt(pos);
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('[1-9]');
                  }
                }
                if (r3 !== null) {
                  r4 = [];
                  r5 = parse_decimalDigit();
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_decimalDigit();
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_decimalDigit() {
              var cacheKey = 'decimalDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-9]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_hexDigit() {
              var cacheKey = 'hexDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9a-fA-F]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_octalDigit() {
              var cacheKey = 'octalDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[0-7]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-7]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_bit() {
              var cacheKey = 'bit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[01]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[01]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_string() {
              var cacheKey = 'string@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '"""') {
                r3 = '"""';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\"\\"\\""');
                }
              }
              if (r3 !== null) {
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r5 = "'";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\'"');
                    }
                  }
                  if (r5 === null) {
                    r6 = pos;
                    r7 = pos;
                    if (input.charCodeAt(pos) === 34) {
                      r8 = '"';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r9 = '"';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r11 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        reportFailures--;
                        if (r10 === null) {
                          r10 = '';
                        } else {
                          r10 = null;
                          pos = r11;
                        }
                        if (r10 !== null) {
                          r5 = [
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                    if (r5 !== null) {
                      r5 = input.substring(pos, r6);
                    }
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_stringData();
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r5 = "'";
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r8 = '"';
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r8 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r9 = '"';
                            pos++;
                          } else {
                            r9 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r11 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r10 = '"';
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r10 === null) {
                              r10 = '';
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            if (r10 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          r5 = input.substring(pos, r6);
                        }
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '"""') {
                    r5 = '"""';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\"\\"\\""');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 3) === "'''") {
                  r3 = "'''";
                  pos += 3;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'''\"");
                  }
                }
                if (r3 !== null) {
                  r5 = parse_stringData();
                  if (r5 === null) {
                    if (input.charCodeAt(pos) === 34) {
                      r5 = '"';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 35) {
                        r5 = '#';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.charCodeAt(pos) === 39) {
                          r8 = "'";
                          pos++;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                        if (r8 !== null) {
                          if (input.charCodeAt(pos) === 39) {
                            r9 = "'";
                            pos++;
                          } else {
                            r9 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\'"');
                            }
                          }
                          r9 = r9 !== null ? r9 : '';
                          if (r9 !== null) {
                            r11 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 39) {
                              r10 = "'";
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                            reportFailures--;
                            if (r10 === null) {
                              r10 = '';
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                            if (r10 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          r5 = input.substring(pos, r6);
                        }
                      }
                    }
                  }
                  if (r5 !== null) {
                    r4 = [];
                    while (r5 !== null) {
                      r4.push(r5);
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 34) {
                          r5 = '"';
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 35) {
                            r5 = '#';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                          if (r5 === null) {
                            r6 = pos;
                            r7 = pos;
                            if (input.charCodeAt(pos) === 39) {
                              r8 = "'";
                              pos++;
                            } else {
                              r8 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                            if (r8 !== null) {
                              if (input.charCodeAt(pos) === 39) {
                                r9 = "'";
                                pos++;
                              } else {
                                r9 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\'"');
                                }
                              }
                              r9 = r9 !== null ? r9 : '';
                              if (r9 !== null) {
                                r11 = pos;
                                reportFailures++;
                                if (input.charCodeAt(pos) === 39) {
                                  r10 = "'";
                                  pos++;
                                } else {
                                  r10 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\'"');
                                  }
                                }
                                reportFailures--;
                                if (r10 === null) {
                                  r10 = '';
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                                if (r10 !== null) {
                                  r5 = [
                                    r8,
                                    r9,
                                    r10
                                  ];
                                } else {
                                  r5 = null;
                                  pos = r7;
                                }
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                            if (r5 !== null) {
                              r5 = input.substring(pos, r6);
                            }
                          }
                        }
                      }
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    if (input.substr(pos, 3) === "'''") {
                      r5 = "'''";
                      pos += 3;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'''\"");
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d) {
                    return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.charCodeAt(pos) === 34) {
                    r3 = '"';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\""');
                    }
                  }
                  if (r3 !== null) {
                    r4 = [];
                    r5 = parse_stringData();
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r5 = "'";
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                    }
                    while (r5 !== null) {
                      r4.push(r5);
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r5 = "'";
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                    }
                    if (r4 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r5 = '"';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (d) {
                      return rp(new CS.String(d.join('')));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.charCodeAt(pos) === 39) {
                      r3 = "'";
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\'"');
                      }
                    }
                    if (r3 !== null) {
                      r4 = [];
                      r5 = parse_stringData();
                      if (r5 === null) {
                        if (input.charCodeAt(pos) === 34) {
                          r5 = '"';
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 35) {
                            r5 = '#';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                        }
                      }
                      while (r5 !== null) {
                        r4.push(r5);
                        r5 = parse_stringData();
                        if (r5 === null) {
                          if (input.charCodeAt(pos) === 34) {
                            r5 = '"';
                            pos++;
                          } else {
                            r5 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          if (r5 === null) {
                            if (input.charCodeAt(pos) === 35) {
                              r5 = '#';
                              pos++;
                            } else {
                              r5 = null;
                              if (reportFailures === 0) {
                                matchFailed('"#"');
                              }
                            }
                          }
                        }
                      }
                      if (r4 !== null) {
                        if (input.charCodeAt(pos) === 39) {
                          r5 = "'";
                          pos++;
                        } else {
                          r5 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                        if (r5 !== null) {
                          r0 = [
                            r3,
                            r4,
                            r5
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (d) {
                        return rp(new CS.String(d.join('')));
                      }(r4);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_stringData() {
              var cacheKey = 'stringData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              if (/^[^"'\\#]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[^"\'\\\\#]');
                }
              }
              if (r0 === null) {
                r0 = parse_UnicodeEscapeSequence();
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === '\\x') {
                    r3 = '\\x';
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\\\x"');
                    }
                  }
                  if (r3 !== null) {
                    r5 = pos;
                    r6 = pos;
                    r7 = parse_hexDigit();
                    if (r7 !== null) {
                      r8 = parse_hexDigit();
                      if (r8 !== null) {
                        r4 = [
                          r7,
                          r8
                        ];
                      } else {
                        r4 = null;
                        pos = r6;
                      }
                    } else {
                      r4 = null;
                      pos = r6;
                    }
                    if (r4 !== null) {
                      r4 = input.substring(pos, r5);
                    }
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (h) {
                      return String.fromCharCode(parseInt(h, 16));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.substr(pos, 2) === '\\0') {
                      r3 = '\\0';
                      pos += 2;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\\\0"');
                      }
                    }
                    if (r3 !== null) {
                      r5 = pos;
                      reportFailures++;
                      r4 = parse_decimalDigit();
                      reportFailures--;
                      if (r4 === null) {
                        r4 = '';
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                      if (r4 !== null) {
                        r0 = [
                          r3,
                          r4
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function () {
                        return '\0';
                      }();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.substr(pos, 2) === '\\0') {
                        r3 = '\\0';
                        pos += 2;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\\\0"');
                        }
                      }
                      if (r3 !== null) {
                        r5 = pos;
                        reportFailures++;
                        r4 = parse_decimalDigit();
                        reportFailures--;
                        if (r4 !== null) {
                          r4 = '';
                          pos = r5;
                        } else {
                          r4 = null;
                        }
                        if (r4 !== null) {
                          r0 = [
                            r3,
                            r4
                          ];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function () {
                          throw new SyntaxError(['string data'], 'octal escape sequence', offset(), line(), column());
                        }();
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.substr(pos, 2) === '\\b') {
                          r0 = '\\b';
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\\\b"');
                          }
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = function () {
                            return '\b';
                          }();
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.substr(pos, 2) === '\\t') {
                            r0 = '\\t';
                            pos += 2;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\\\t"');
                            }
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = function () {
                              return '\t';
                            }();
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.substr(pos, 2) === '\\n') {
                              r0 = '\\n';
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\\\n"');
                              }
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = function () {
                                return '\n';
                              }();
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              if (input.substr(pos, 2) === '\\v') {
                                r0 = '\\v';
                                pos += 2;
                              } else {
                                r0 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\\\v"');
                                }
                              }
                              if (r0 !== null) {
                                reportedPos = r1;
                                r0 = function () {
                                  return '\x0B';
                                }();
                              }
                              if (r0 === null) {
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                if (input.substr(pos, 2) === '\\f') {
                                  r0 = '\\f';
                                  pos += 2;
                                } else {
                                  r0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\\\f"');
                                  }
                                }
                                if (r0 !== null) {
                                  reportedPos = r1;
                                  r0 = function () {
                                    return '\f';
                                  }();
                                }
                                if (r0 === null) {
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  if (input.substr(pos, 2) === '\\r') {
                                    r0 = '\\r';
                                    pos += 2;
                                  } else {
                                    r0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"\\\\r"');
                                    }
                                  }
                                  if (r0 !== null) {
                                    reportedPos = r1;
                                    r0 = function () {
                                      return '\r';
                                    }();
                                  }
                                  if (r0 === null) {
                                    pos = r1;
                                  }
                                  if (r0 === null) {
                                    r1 = pos;
                                    r2 = pos;
                                    if (input.charCodeAt(pos) === 92) {
                                      r3 = '\\';
                                      pos++;
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"\\\\"');
                                      }
                                    }
                                    if (r3 !== null) {
                                      if (input.length > pos) {
                                        r4 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        r4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('any character');
                                        }
                                      }
                                      if (r4 !== null) {
                                        r0 = [
                                          r3,
                                          r4
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                    if (r0 !== null) {
                                      reportedPos = r1;
                                      r0 = function (c) {
                                        return c;
                                      }(r4);
                                    }
                                    if (r0 === null) {
                                      pos = r1;
                                    }
                                    if (r0 === null) {
                                      r1 = pos;
                                      r2 = pos;
                                      if (input.charCodeAt(pos) === 35) {
                                        r3 = '#';
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"#"');
                                        }
                                      }
                                      if (r3 !== null) {
                                        r5 = pos;
                                        reportFailures++;
                                        if (input.charCodeAt(pos) === 123) {
                                          r4 = '{';
                                          pos++;
                                        } else {
                                          r4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"{"');
                                          }
                                        }
                                        reportFailures--;
                                        if (r4 === null) {
                                          r4 = '';
                                        } else {
                                          r4 = null;
                                          pos = r5;
                                        }
                                        if (r4 !== null) {
                                          r0 = [
                                            r3,
                                            r4
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                      if (r0 !== null) {
                                        reportedPos = r1;
                                        r0 = function (c) {
                                          return c;
                                        }(r3);
                                      }
                                      if (r0 === null) {
                                        pos = r1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_interpolation() {
              var cacheKey = 'interpolation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '"""') {
                r3 = '"""';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\"\\"\\""');
                }
              }
              if (r3 !== null) {
                r6 = pos;
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r7 = "'";
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\'"');
                    }
                  }
                  if (r7 === null) {
                    r8 = pos;
                    r9 = pos;
                    if (input.charCodeAt(pos) === 34) {
                      r10 = '"';
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r10 !== null) {
                      if (input.charCodeAt(pos) === 34) {
                        r11 = '"';
                        pos++;
                      } else {
                        r11 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\""');
                        }
                      }
                      r11 = r11 !== null ? r11 : '';
                      if (r11 !== null) {
                        r13 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 34) {
                          r12 = '"';
                          pos++;
                        } else {
                          r12 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        reportFailures--;
                        if (r12 === null) {
                          r12 = '';
                        } else {
                          r12 = null;
                          pos = r13;
                        }
                        if (r12 !== null) {
                          r7 = [
                            r10,
                            r11,
                            r12
                          ];
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                    if (r7 !== null) {
                      r7 = input.substring(pos, r8);
                    }
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r7 = "'";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r10 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r11 = '"';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r13 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r12 = '"';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r12 === null) {
                              r12 = '';
                            } else {
                              r12 = null;
                              pos = r13;
                            }
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          r7 = input.substring(pos, r8);
                        }
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (d) {
                    return rp(new CS.String(d.join('')));
                  }(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  r7 = pos;
                  if (input.substr(pos, 2) === '#{') {
                    r8 = '#{';
                    pos += 2;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('"#{"');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_expression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos) === 125) {
                            r12 = '}';
                            pos++;
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed('"}"');
                            }
                          }
                          if (r12 !== null) {
                            r5 = [
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (e) {
                      return e;
                    }(r10);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r7 = "'";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\'"');
                        }
                      }
                      if (r7 === null) {
                        r8 = pos;
                        r9 = pos;
                        if (input.charCodeAt(pos) === 34) {
                          r10 = '"';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\""');
                          }
                        }
                        if (r10 !== null) {
                          if (input.charCodeAt(pos) === 34) {
                            r11 = '"';
                            pos++;
                          } else {
                            r11 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\""');
                            }
                          }
                          r11 = r11 !== null ? r11 : '';
                          if (r11 !== null) {
                            r13 = pos;
                            reportFailures++;
                            if (input.charCodeAt(pos) === 34) {
                              r12 = '"';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            reportFailures--;
                            if (r12 === null) {
                              r12 = '';
                            } else {
                              r12 = null;
                              pos = r13;
                            }
                            if (r12 !== null) {
                              r7 = [
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                        if (r7 !== null) {
                          r7 = input.substring(pos, r8);
                        }
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        r7 = parse_stringData();
                        if (r7 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            r7 = "'";
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\'"');
                            }
                          }
                          if (r7 === null) {
                            r8 = pos;
                            r9 = pos;
                            if (input.charCodeAt(pos) === 34) {
                              r10 = '"';
                              pos++;
                            } else {
                              r10 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\""');
                              }
                            }
                            if (r10 !== null) {
                              if (input.charCodeAt(pos) === 34) {
                                r11 = '"';
                                pos++;
                              } else {
                                r11 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\""');
                                }
                              }
                              r11 = r11 !== null ? r11 : '';
                              if (r11 !== null) {
                                r13 = pos;
                                reportFailures++;
                                if (input.charCodeAt(pos) === 34) {
                                  r12 = '"';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\""');
                                  }
                                }
                                reportFailures--;
                                if (r12 === null) {
                                  r12 = '';
                                } else {
                                  r12 = null;
                                  pos = r13;
                                }
                                if (r12 !== null) {
                                  r7 = [
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r7 = null;
                                  pos = r9;
                                }
                              } else {
                                r7 = null;
                                pos = r9;
                              }
                            } else {
                              r7 = null;
                              pos = r9;
                            }
                            if (r7 !== null) {
                              r7 = input.substring(pos, r8);
                            }
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (d) {
                        return rp(new CS.String(d.join('')));
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                    if (r5 === null) {
                      r6 = pos;
                      r7 = pos;
                      if (input.substr(pos, 2) === '#{') {
                        r8 = '#{';
                        pos += 2;
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#{"');
                        }
                      }
                      if (r8 !== null) {
                        r9 = parse__();
                        if (r9 !== null) {
                          r10 = parse_expression();
                          if (r10 !== null) {
                            r11 = parse__();
                            if (r11 !== null) {
                              if (input.charCodeAt(pos) === 125) {
                                r12 = '}';
                                pos++;
                              } else {
                                r12 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"}"');
                                }
                              }
                              if (r12 !== null) {
                                r5 = [
                                  r8,
                                  r9,
                                  r10,
                                  r11,
                                  r12
                                ];
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (e) {
                          return e;
                        }(r10);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '"""') {
                    r5 = '"""';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\"\\"\\""');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (es) {
                  return rp(createInterpolation(stripLeadingWhitespaceInterpolation(es)));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 34) {
                  r3 = '"';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\""');
                  }
                }
                if (r3 !== null) {
                  r6 = pos;
                  r7 = parse_stringData();
                  if (r7 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      r7 = "'";
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\'"');
                      }
                    }
                  }
                  if (r7 !== null) {
                    r5 = [];
                    while (r7 !== null) {
                      r5.push(r7);
                      r7 = parse_stringData();
                      if (r7 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r7 = "'";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                    }
                  } else {
                    r5 = null;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (d) {
                      return rp(new CS.String(d.join('')));
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r6 = pos;
                    r7 = pos;
                    if (input.substr(pos, 2) === '#{') {
                      r8 = '#{';
                      pos += 2;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#{"');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_expression();
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            if (input.charCodeAt(pos) === 125) {
                              r12 = '}';
                              pos++;
                            } else {
                              r12 = null;
                              if (reportFailures === 0) {
                                matchFailed('"}"');
                              }
                            }
                            if (r12 !== null) {
                              r5 = [
                                r8,
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (e) {
                        return e;
                      }(r10);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                  if (r5 !== null) {
                    r4 = [];
                    while (r5 !== null) {
                      r4.push(r5);
                      r6 = pos;
                      r7 = parse_stringData();
                      if (r7 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          r7 = "'";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\'"');
                          }
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          r7 = parse_stringData();
                          if (r7 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              r7 = "'";
                              pos++;
                            } else {
                              r7 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\'"');
                              }
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (d) {
                          return rp(new CS.String(d.join('')));
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                      if (r5 === null) {
                        r6 = pos;
                        r7 = pos;
                        if (input.substr(pos, 2) === '#{') {
                          r8 = '#{';
                          pos += 2;
                        } else {
                          r8 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#{"');
                          }
                        }
                        if (r8 !== null) {
                          r9 = parse__();
                          if (r9 !== null) {
                            r10 = parse_expression();
                            if (r10 !== null) {
                              r11 = parse__();
                              if (r11 !== null) {
                                if (input.charCodeAt(pos) === 125) {
                                  r12 = '}';
                                  pos++;
                                } else {
                                  r12 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"}"');
                                  }
                                }
                                if (r12 !== null) {
                                  r5 = [
                                    r8,
                                    r9,
                                    r10,
                                    r11,
                                    r12
                                  ];
                                } else {
                                  r5 = null;
                                  pos = r7;
                                }
                              } else {
                                r5 = null;
                                pos = r7;
                              }
                            } else {
                              r5 = null;
                              pos = r7;
                            }
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                        if (r5 !== null) {
                          reportedPos = r6;
                          r5 = function (e) {
                            return e;
                          }(r10);
                        }
                        if (r5 === null) {
                          pos = r6;
                        }
                      }
                    }
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 34) {
                      r5 = '"';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\""');
                      }
                    }
                    if (r5 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (es) {
                    return rp(createInterpolation(es));
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_regexp() {
              var cacheKey = 'regexp@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '///') {
                r3 = '///';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"///"');
                }
              }
              if (r3 !== null) {
                r6 = pos;
                if (/^[ \r\n]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('[ \\r\\n]');
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[ \r\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[ \\r\\n]');
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function () {
                    return [rp(new CS.String('').g())];
                  }();
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                    r7 = input.charAt(pos);
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\/#[ \\r\\n]');
                    }
                  }
                  if (r7 !== null) {
                    r5 = [];
                    while (r7 !== null) {
                      r5.push(r7);
                      if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\\\\\/#[ \\r\\n]');
                        }
                      }
                    }
                  } else {
                    r5 = null;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (s) {
                      return [rp(new CS.String(s.join('')).g())];
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r5 = parse_hereregexpData();
                  }
                }
                if (r5 !== null) {
                  r4 = [];
                  while (r5 !== null) {
                    r4.push(r5);
                    r6 = pos;
                    if (/^[ \r\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[ \\r\\n]');
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        if (/^[ \r\n]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[ \\r\\n]');
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function () {
                        return [rp(new CS.String('').g())];
                      }();
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                    if (r5 === null) {
                      r6 = pos;
                      if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\\\\\/#[ \\r\\n]');
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                            r7 = input.charAt(pos);
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('[^\\\\\\/#[ \\r\\n]');
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (s) {
                          return [rp(new CS.String(s.join('')).g())];
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                      if (r5 === null) {
                        r5 = parse_hereregexpData();
                      }
                    }
                  }
                } else {
                  r4 = null;
                }
                if (r4 !== null) {
                  if (input.substr(pos, 3) === '///') {
                    r5 = '///';
                    pos += 3;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"///"');
                    }
                  }
                  if (r5 !== null) {
                    r6 = [];
                    if (/^[gimy]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[gimy]');
                      }
                    }
                    while (r7 !== null) {
                      r6.push(r7);
                      if (/^[gimy]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[gimy]');
                        }
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (es, flags) {
                  if (!isValidRegExpFlags(flags))
                    throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
                  if (!flags)
                    flags = [];
                  var interp = createInterpolation(foldl(function (memo, e) {
                      return memo.concat(e);
                    }, [], es));
                  if (interp instanceof CS.String)
                    return p(new CS.RegExp(interp.data, flags));
                  return rp(new CS.HeregExp(interp, flags));
                }(r4, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 47) {
                  r3 = '/';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"/"');
                  }
                }
                if (r3 !== null) {
                  r4 = [];
                  r5 = parse_regexpData();
                  if (r5 === null) {
                    r6 = pos;
                    if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^\\/\\\\[\\n]');
                      }
                    }
                    if (r7 !== null) {
                      r5 = [];
                      while (r7 !== null) {
                        r5.push(r7);
                        if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[^\\/\\\\[\\n]');
                          }
                        }
                      }
                    } else {
                      r5 = null;
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (d) {
                        return d.join('');
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                  while (r5 !== null) {
                    r4.push(r5);
                    r5 = parse_regexpData();
                    if (r5 === null) {
                      r6 = pos;
                      if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[^\\/\\\\[\\n]');
                        }
                      }
                      if (r7 !== null) {
                        r5 = [];
                        while (r7 !== null) {
                          r5.push(r7);
                          if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                            r7 = input.charAt(pos);
                            pos++;
                          } else {
                            r7 = null;
                            if (reportFailures === 0) {
                              matchFailed('[^\\/\\\\[\\n]');
                            }
                          }
                        }
                      } else {
                        r5 = null;
                      }
                      if (r5 !== null) {
                        reportedPos = r6;
                        r5 = function (d) {
                          return d.join('');
                        }(r5);
                      }
                      if (r5 === null) {
                        pos = r6;
                      }
                    }
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 47) {
                      r5 = '/';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"/"');
                      }
                    }
                    if (r5 !== null) {
                      r6 = [];
                      if (/^[gimy]/.test(input.charAt(pos))) {
                        r7 = input.charAt(pos);
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('[gimy]');
                        }
                      }
                      while (r7 !== null) {
                        r6.push(r7);
                        if (/^[gimy]/.test(input.charAt(pos))) {
                          r7 = input.charAt(pos);
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed('[gimy]');
                          }
                        }
                      }
                      if (r6 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d, flags) {
                    if (!isValidRegExpFlags(flags))
                      throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
                    return rp(new CS.RegExp(d.join(''), flags));
                  }(r4, r6);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_regexpData() {
              var cacheKey = 'regexpData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = [];
                if (/^[^\\\]\n]/.test(input.charAt(pos))) {
                  r5 = input.charAt(pos);
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^\\\\\\]\\n]');
                  }
                }
                if (r5 === null) {
                  r5 = parse_regexpData();
                }
                while (r5 !== null) {
                  r4.push(r5);
                  if (/^[^\\\]\n]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\]\\n]');
                    }
                  }
                  if (r5 === null) {
                    r5 = parse_regexpData();
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 93) {
                    r5 = ']';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"]"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return '[' + d.join('') + ']';
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.charCodeAt(pos) === 92) {
                  r3 = '\\';
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\\\"');
                  }
                }
                if (r3 !== null) {
                  if (input.length > pos) {
                    r4 = input.charAt(pos);
                    pos++;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r1);
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_hereregexpData() {
              var cacheKey = 'hereregexpData@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r5 = parse_hereregexpData();
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = function (h) {
                    return h[0];
                  }(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  if (/^[^\\\/\]]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^\\\\\\/\\]]');
                    }
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (s) {
                      return p(new CS.String(s));
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r5 = parse_hereregexpData();
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = function (h) {
                      return h[0];
                    }(r5);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                  if (r5 === null) {
                    r6 = pos;
                    if (/^[^\\\/\]]/.test(input.charAt(pos))) {
                      r5 = input.charAt(pos);
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^\\\\\\/\\]]');
                      }
                    }
                    if (r5 !== null) {
                      reportedPos = r6;
                      r5 = function (s) {
                        return p(new CS.String(s));
                      }(r5);
                    }
                    if (r5 === null) {
                      pos = r6;
                    }
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 93) {
                    r5 = ']';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('"]"');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (d) {
                  return [p(new CS.String('['))].concat(d || []).concat([p(new CS.String(']'))]);
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = pos;
                if (input.charCodeAt(pos) === 92) {
                  r4 = '\\';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\\\"');
                  }
                }
                if (r4 !== null) {
                  if (input.length > pos) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r5 !== null) {
                    r0 = [
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r3;
                  }
                } else {
                  r0 = null;
                  pos = r3;
                }
                if (r0 !== null) {
                  r0 = input.substring(pos, r2);
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (d) {
                    return [rp(new CS.String(d))];
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r3 = pos;
                  if (input.charCodeAt(pos) === 47) {
                    r4 = '/';
                    pos++;
                  } else {
                    r4 = null;
                    if (reportFailures === 0) {
                      matchFailed('"/"');
                    }
                  }
                  if (r4 !== null) {
                    if (input.charCodeAt(pos) === 47) {
                      r5 = '/';
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed('"/"');
                      }
                    }
                    r5 = r5 !== null ? r5 : '';
                    if (r5 !== null) {
                      r7 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 47) {
                        r6 = '/';
                        pos++;
                      } else {
                        r6 = null;
                        if (reportFailures === 0) {
                          matchFailed('"/"');
                        }
                      }
                      reportFailures--;
                      if (r6 === null) {
                        r6 = '';
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                      if (r6 !== null) {
                        r0 = [
                          r4,
                          r5,
                          r6
                        ];
                      } else {
                        r0 = null;
                        pos = r3;
                      }
                    } else {
                      r0 = null;
                      pos = r3;
                    }
                  } else {
                    r0 = null;
                    pos = r3;
                  }
                  if (r0 !== null) {
                    r0 = input.substring(pos, r2);
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (s) {
                      return [rp(new CS.String(s))];
                    }(r0);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.charCodeAt(pos) === 35) {
                      r3 = '#';
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#"');
                      }
                    }
                    if (r3 !== null) {
                      r5 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 123) {
                        r4 = '{';
                        pos++;
                      } else {
                        r4 = null;
                        if (reportFailures === 0) {
                          matchFailed('"{"');
                        }
                      }
                      reportFailures--;
                      if (r4 === null) {
                        r4 = '';
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                      if (r4 !== null) {
                        r0 = [
                          r3,
                          r4
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = function (c) {
                        return [rp(new CS.String(c))];
                      }(r3);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.substr(pos, 2) === '#{') {
                        r3 = '#{';
                        pos += 2;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#{"');
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_expression();
                          if (r5 !== null) {
                            r6 = parse__();
                            if (r6 !== null) {
                              if (input.charCodeAt(pos) === 125) {
                                r7 = '}';
                                pos++;
                              } else {
                                r7 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"}"');
                                }
                              }
                              if (r7 !== null) {
                                r0 = [
                                  r3,
                                  r4,
                                  r5,
                                  r6,
                                  r7
                                ];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = function (e) {
                          return [e];
                        }(r5);
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_throw() {
              var cacheKey = 'throw@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_THROW();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Throw(e));
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_return() {
              var cacheKey = 'return@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_RETURN();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_secondaryExpression();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e) {
                  return rp(new CS.Return(e || null));
                }(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_continue() {
              var cacheKey = 'continue@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_CONTINUE();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Continue);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_break() {
              var cacheKey = 'break@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_BREAK();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Break);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_debugger() {
              var cacheKey = 'debugger@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_DEBUGGER();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Debugger);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_undefined() {
              var cacheKey = 'undefined@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_UNDEFINED();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Undefined);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_null() {
              var cacheKey = 'null@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_NULL();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function () {
                  return rp(new CS.Null);
                }();
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_memberAssign() {
              var cacheKey = 'memberAssign@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_memberAccess();
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (access) {
                  access.isAssignment = true;
                  return access;
                }(r0);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_contextAssign() {
              var cacheKey = 'contextAssign@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              if (input.charCodeAt(pos) === 64) {
                r3 = '@';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"@"');
                }
              }
              if (r3 !== null) {
                reportedPos = r4;
                r3 = function () {
                  return rp(new CS.This);
                }();
              }
              if (r3 === null) {
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (a, m) {
                  return rp(new CS.NativeMemberAccessOp(a, m));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_unassignable() {
              var cacheKey = 'unassignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 9) === 'arguments') {
                r2 = 'arguments';
                pos += 9;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"arguments"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === 'eval') {
                  r2 = 'eval';
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"eval"');
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CompoundAssignable() {
              var cacheKey = 'CompoundAssignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r0 = parse_memberAssign();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = pos;
                reportFailures++;
                r3 = parse_unassignable();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r4 = parse_identifier();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (i) {
                    return i;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r0 = parse_contextAssign();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_Assignable() {
              var cacheKey = 'Assignable@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r0 = parse_memberAssign();
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r4 = pos;
                reportFailures++;
                r3 = parse_unassignable();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r4 = parse_identifier();
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (i) {
                    return i;
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r0 = parse_contextAssign();
                  if (r0 === null) {
                    r0 = parse_positionalDestructuring();
                    if (r0 === null) {
                      r0 = parse_namedDestructuring();
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuring() {
              var cacheKey = 'positionalDestructuring@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = '[';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"["');
                }
              }
              if (r3 !== null) {
                r4 = parse_positionalDestructuringBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 93) {
                        r7 = ']';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"]"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ArrayInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringBody() {
              var cacheKey = 'positionalDestructuringBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_positionalDestructuringMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_positionalDestructuringMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringMemberList() {
              var cacheKey = 'positionalDestructuringMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
              r1 = pos;
              r2 = pos;
              r3 = parse_positionalDestructuringMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r8 = ',';
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('","');
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_positionalDestructuringMember();
                      if (r10 !== null) {
                        r5 = [
                          r7,
                          r8,
                          r9,
                          r10
                        ];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse__();
                  if (r7 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r8 = ',';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r8 !== null) {
                      r9 = parse__();
                      if (r9 !== null) {
                        r10 = parse_positionalDestructuringMember();
                        if (r10 !== null) {
                          r5 = [
                            r7,
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[3];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_positionalDestructuringMember() {
              var cacheKey = 'positionalDestructuringMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_rest();
              if (r0 === null) {
                r0 = parse_Assignable();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuring() {
              var cacheKey = 'namedDestructuring@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 123) {
                r3 = '{';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"{"');
                }
              }
              if (r3 !== null) {
                r4 = parse_namedDestructuringBody();
                if (r4 !== null) {
                  r5 = parse_TERMINATOR();
                  r5 = r5 !== null ? r5 : '';
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        r7 = '}';
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed('"}"');
                        }
                      }
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return rp(new CS.ObjectInitialiser(members));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringBody() {
              var cacheKey = 'namedDestructuringBody@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINDENT();
              if (r3 !== null) {
                r4 = parse_namedDestructuringMemberList();
                if (r4 !== null) {
                  r5 = parse_DEDENT();
                  if (r5 !== null) {
                    r0 = [
                      r3,
                      r4,
                      r5
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (members) {
                  return members;
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                r3 = parse__();
                if (r3 !== null) {
                  r4 = parse_namedDestructuringMemberList();
                  r4 = r4 !== null ? r4 : '';
                  if (r4 !== null) {
                    r0 = [
                      r3,
                      r4
                    ];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (members) {
                    return members || [];
                  }(r4);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringMemberList() {
              var cacheKey = 'namedDestructuringMemberList@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
              r1 = pos;
              r2 = pos;
              r3 = parse_namedDestructuringMember();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r7 = parse_TERMINATOR();
                r7 = r7 !== null ? r7 : '';
                if (r7 !== null) {
                  r8 = parse__();
                  if (r8 !== null) {
                    if (input.charCodeAt(pos) === 44) {
                      r9 = ',';
                      pos++;
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed('","');
                      }
                    }
                    if (r9 === null) {
                      r9 = parse_TERMINATOR();
                    }
                    if (r9 !== null) {
                      r10 = parse_TERMINATOR();
                      r10 = r10 !== null ? r10 : '';
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_namedDestructuringMember();
                          if (r12 !== null) {
                            r5 = [
                              r7,
                              r8,
                              r9,
                              r10,
                              r11,
                              r12
                            ];
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r7 = parse_TERMINATOR();
                  r7 = r7 !== null ? r7 : '';
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 44) {
                        r9 = ',';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('","');
                        }
                      }
                      if (r9 === null) {
                        r9 = parse_TERMINATOR();
                      }
                      if (r9 !== null) {
                        r10 = parse_TERMINATOR();
                        r10 = r10 !== null ? r10 : '';
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_namedDestructuringMember();
                            if (r12 !== null) {
                              r5 = [
                                r7,
                                r8,
                                r9,
                                r10,
                                r11,
                                r12
                              ];
                            } else {
                              r5 = null;
                              pos = r6;
                            }
                          } else {
                            r5 = null;
                            pos = r6;
                          }
                        } else {
                          r5 = null;
                          pos = r6;
                        }
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (e, es) {
                  return [e].concat(es.map(function (e) {
                    return e[5];
                  }));
                }(r3, r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_namedDestructuringMember() {
              var cacheKey = 'namedDestructuringMember@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r3 = parse_ObjectInitialiserKeys();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    r5 = ':';
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed('":"');
                    }
                  }
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      r7 = parse_Assignable();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (key, val) {
                  return rp(new CS.ObjectInitialiserMember(key, val));
                }(r3, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r0 = parse_contextVar();
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function (v) {
                    var key = rp(new CS.String(v.memberName));
                    return rp(new CS.ObjectInitialiserMember(key, v));
                  }(r0);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  r4 = pos;
                  reportFailures++;
                  r3 = parse_unassignable();
                  reportFailures--;
                  if (r3 === null) {
                    r3 = '';
                  } else {
                    r3 = null;
                    pos = r4;
                  }
                  if (r3 !== null) {
                    r4 = parse_identifier();
                    if (r4 !== null) {
                      r0 = [
                        r3,
                        r4
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = function (i) {
                      return rp(new CS.ObjectInitialiserMember(i, i));
                    }(r4);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifier() {
              var cacheKey = 'identifier@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              reportFailures++;
              r3 = parse_reserved();
              reportFailures--;
              if (r3 === null) {
                r3 = '';
              } else {
                r3 = null;
                pos = r4;
              }
              if (r3 !== null) {
                r4 = parse_identifierName();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (i) {
                  return rp(new CS.Identifier(i));
                }(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierName() {
              var cacheKey = 'identifierName@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              r3 = parse_identifierStart();
              if (r3 !== null) {
                r4 = [];
                r5 = parse_identifierPart();
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_identifierPart();
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierStart() {
              var cacheKey = 'identifierStart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_UnicodeLetter();
              if (r0 === null) {
                if (/^[$_]/.test(input.charAt(pos))) {
                  r0 = input.charAt(pos);
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('[$_]');
                  }
                }
                if (r0 === null) {
                  r0 = parse_UnicodeEscapeSequence();
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_identifierPart() {
              var cacheKey = 'identifierPart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_identifierStart();
              if (r0 === null) {
                r0 = parse_UnicodeCombiningMark();
                if (r0 === null) {
                  r0 = parse_UnicodeDigit();
                  if (r0 === null) {
                    r0 = parse_UnicodeConnectorPunctuation();
                    if (r0 === null) {
                      r0 = parse_ZWNJ();
                      if (r0 === null) {
                        r0 = parse_ZWJ();
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_propertyChain() {
              var cacheKey = 'propertyChain@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r3 = parse_propertyChainPart();
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                if (input.charCodeAt(pos) === 46) {
                  r7 = '.';
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed('"."');
                  }
                }
                if (r7 !== null) {
                  r8 = parse_propertyChainPart();
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  if (input.charCodeAt(pos) === 46) {
                    r7 = '.';
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed('"."');
                    }
                  }
                  if (r7 !== null) {
                    r8 = parse_propertyChainPart();
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_propertyChainPart() {
              var cacheKey = 'propertyChainPart@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_Numbers();
              if (r0 === null) {
                r0 = parse_identifierName();
                if (r0 === null) {
                  if (input.substr(pos, 5) === '@each') {
                    r0 = '@each';
                    pos += 5;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed('"@each"');
                    }
                  }
                  if (r0 === null) {
                    if (input.substr(pos, 4) === 'this') {
                      r0 = 'this';
                      pos += 4;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed('"this"');
                      }
                    }
                    if (r0 === null) {
                      if (input.substr(pos, 2) === '[]') {
                        r0 = '[]';
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed('"[]"');
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse___() {
              var cacheKey = '__@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              r4 = parse_whitespace();
              if (r4 !== null) {
                r3 = [];
                while (r4 !== null) {
                  r3.push(r4);
                  r4 = parse_whitespace();
                }
              } else {
                r3 = null;
              }
              if (r3 !== null) {
                r5 = pos;
                r6 = parse_blockComment();
                if (r6 !== null) {
                  r8 = parse_whitespace();
                  if (r8 !== null) {
                    r7 = [];
                    while (r8 !== null) {
                      r7.push(r8);
                      r8 = parse_whitespace();
                    }
                  } else {
                    r7 = null;
                  }
                  if (r7 !== null) {
                    r4 = [
                      r6,
                      r7
                    ];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
                r4 = r4 !== null ? r4 : '';
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse__() {
              var cacheKey = '_@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse___();
              r0 = r0 !== null ? r0 : '';
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_comment() {
              var cacheKey = 'comment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              r0 = parse_blockComment();
              if (r0 === null) {
                r0 = parse_singleLineComment();
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_singleLineComment() {
              var cacheKey = 'singleLineComment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 35) {
                r3 = '#';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"#"');
                }
              }
              if (r3 !== null) {
                r4 = [];
                r6 = pos;
                r8 = pos;
                reportFailures++;
                r7 = parse_TERM();
                reportFailures--;
                if (r7 === null) {
                  r7 = '';
                } else {
                  r7 = null;
                  pos = r8;
                }
                if (r7 !== null) {
                  if (input.length > pos) {
                    r8 = input.charAt(pos);
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed('any character');
                    }
                  }
                  if (r8 !== null) {
                    r5 = [
                      r7,
                      r8
                    ];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r6 = pos;
                  r8 = pos;
                  reportFailures++;
                  r7 = parse_TERM();
                  reportFailures--;
                  if (r7 === null) {
                    r7 = '';
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                  if (r7 !== null) {
                    if (input.length > pos) {
                      r8 = input.charAt(pos);
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('any character');
                      }
                    }
                    if (r8 !== null) {
                      r5 = [
                        r7,
                        r8
                      ];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_blockComment() {
              var cacheKey = 'blockComment@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === '###') {
                r3 = '###';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"###"');
                }
              }
              if (r3 !== null) {
                if (/^[^#]/.test(input.charAt(pos))) {
                  r4 = input.charAt(pos);
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('[^#]');
                  }
                }
                if (r4 !== null) {
                  r5 = [];
                  if (/^[^#]/.test(input.charAt(pos))) {
                    r6 = input.charAt(pos);
                    pos++;
                  } else {
                    r6 = null;
                    if (reportFailures === 0) {
                      matchFailed('[^#]');
                    }
                  }
                  if (r6 === null) {
                    r7 = pos;
                    if (input.charCodeAt(pos) === 35) {
                      r8 = '#';
                      pos++;
                    } else {
                      r8 = null;
                      if (reportFailures === 0) {
                        matchFailed('"#"');
                      }
                    }
                    if (r8 !== null) {
                      if (input.charCodeAt(pos) === 35) {
                        r9 = '#';
                        pos++;
                      } else {
                        r9 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      r9 = r9 !== null ? r9 : '';
                      if (r9 !== null) {
                        r11 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 35) {
                          r10 = '#';
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#"');
                          }
                        }
                        reportFailures--;
                        if (r10 === null) {
                          r10 = '';
                        } else {
                          r10 = null;
                          pos = r11;
                        }
                        if (r10 !== null) {
                          r6 = [
                            r8,
                            r9,
                            r10
                          ];
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  }
                  while (r6 !== null) {
                    r5.push(r6);
                    if (/^[^#]/.test(input.charAt(pos))) {
                      r6 = input.charAt(pos);
                      pos++;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('[^#]');
                      }
                    }
                    if (r6 === null) {
                      r7 = pos;
                      if (input.charCodeAt(pos) === 35) {
                        r8 = '#';
                        pos++;
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed('"#"');
                        }
                      }
                      if (r8 !== null) {
                        if (input.charCodeAt(pos) === 35) {
                          r9 = '#';
                          pos++;
                        } else {
                          r9 = null;
                          if (reportFailures === 0) {
                            matchFailed('"#"');
                          }
                        }
                        r9 = r9 !== null ? r9 : '';
                        if (r9 !== null) {
                          r11 = pos;
                          reportFailures++;
                          if (input.charCodeAt(pos) === 35) {
                            r10 = '#';
                            pos++;
                          } else {
                            r10 = null;
                            if (reportFailures === 0) {
                              matchFailed('"#"');
                            }
                          }
                          reportFailures--;
                          if (r10 === null) {
                            r10 = '';
                          } else {
                            r10 = null;
                            pos = r11;
                          }
                          if (r10 !== null) {
                            r6 = [
                              r8,
                              r9,
                              r10
                            ];
                          } else {
                            r6 = null;
                            pos = r7;
                          }
                        } else {
                          r6 = null;
                          pos = r7;
                        }
                      } else {
                        r6 = null;
                        pos = r7;
                      }
                    }
                  }
                  if (r5 !== null) {
                    if (input.substr(pos, 3) === '###') {
                      r6 = '###';
                      pos += 3;
                    } else {
                      r6 = null;
                      if (reportFailures === 0) {
                        matchFailed('"###"');
                      }
                    }
                    if (r6 !== null) {
                      r0 = [
                        r3,
                        r4,
                        r5,
                        r6
                      ];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_whitespace() {
              var cacheKey = 'whitespace@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              if (/^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]');
                }
              }
              if (r0 === null) {
                if (input.charCodeAt(pos) === 13) {
                  r0 = '\r';
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\r"');
                  }
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.charCodeAt(pos) === 92) {
                    r3 = '\\';
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\\\"');
                    }
                  }
                  if (r3 !== null) {
                    if (input.charCodeAt(pos) === 13) {
                      r4 = '\r';
                      pos++;
                    } else {
                      r4 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\r"');
                      }
                    }
                    r4 = r4 !== null ? r4 : '';
                    if (r4 !== null) {
                      if (input.charCodeAt(pos) === 10) {
                        r5 = '\n';
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\n"');
                        }
                      }
                      if (r5 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    r0 = input.substring(pos, r1);
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_INDENT() {
              var cacheKey = 'INDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse___();
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 61423) {
                  r4 = '\uEFEF';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFEF"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (ws) {
                  return ws;
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DEDENT() {
              var cacheKey = 'DEDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              r4 = pos;
              r5 = pos;
              r6 = parse_TERMINATOR();
              r6 = r6 !== null ? r6 : '';
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r3 = [
                    r6,
                    r7
                  ];
                } else {
                  r3 = null;
                  pos = r5;
                }
              } else {
                r3 = null;
                pos = r5;
              }
              if (r3 !== null) {
                r3 = input.substring(pos, r4);
              }
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 61438) {
                  r4 = '\uEFFE';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFFE"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (ws) {
                  return ws;
                }(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERM() {
              var cacheKey = 'TERM@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 13) {
                r3 = '\r';
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\r"');
                }
              }
              r3 = r3 !== null ? r3 : '';
              if (r3 !== null) {
                if (input.charCodeAt(pos) === 10) {
                  r4 = '\n';
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\n"');
                  }
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 61439) {
                  r0 = '\uEFFF';
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uEFFF"');
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = function () {
                    return '';
                  }();
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERMINATOR() {
              var cacheKey = 'TERMINATOR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r3 = pos;
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_comment();
                r5 = r5 !== null ? r5 : '';
                if (r5 !== null) {
                  r6 = parse_TERM();
                  if (r6 !== null) {
                    r7 = parse_blockComment();
                    r7 = r7 !== null ? r7 : '';
                    if (r7 !== null) {
                      r2 = [
                        r4,
                        r5,
                        r6,
                        r7
                      ];
                    } else {
                      r2 = null;
                      pos = r3;
                    }
                  } else {
                    r2 = null;
                    pos = r3;
                  }
                } else {
                  r2 = null;
                  pos = r3;
                }
              } else {
                r2 = null;
                pos = r3;
              }
              if (r2 !== null) {
                r0 = [];
                while (r2 !== null) {
                  r0.push(r2);
                  r3 = pos;
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_comment();
                    r5 = r5 !== null ? r5 : '';
                    if (r5 !== null) {
                      r6 = parse_TERM();
                      if (r6 !== null) {
                        r7 = parse_blockComment();
                        r7 = r7 !== null ? r7 : '';
                        if (r7 !== null) {
                          r2 = [
                            r4,
                            r5,
                            r6,
                            r7
                          ];
                        } else {
                          r2 = null;
                          pos = r3;
                        }
                      } else {
                        r2 = null;
                        pos = r3;
                      }
                    } else {
                      r2 = null;
                      pos = r3;
                    }
                  } else {
                    r2 = null;
                    pos = r3;
                  }
                }
              } else {
                r0 = null;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TERMINDENT() {
              var cacheKey = 'TERMINDENT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              r2 = pos;
              r3 = parse_TERMINATOR();
              if (r3 !== null) {
                r4 = parse_INDENT();
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_AND() {
              var cacheKey = 'AND@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'and') {
                r3 = 'and';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"and"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_BREAK() {
              var cacheKey = 'BREAK@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'break') {
                r3 = 'break';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"break"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_BY() {
              var cacheKey = 'BY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'by') {
                r3 = 'by';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"by"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CATCH() {
              var cacheKey = 'CATCH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'catch') {
                r3 = 'catch';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"catch"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CONTINUE() {
              var cacheKey = 'CONTINUE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 8) === 'continue') {
                r3 = 'continue';
                pos += 8;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"continue"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CLASS() {
              var cacheKey = 'CLASS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'class') {
                r3 = 'class';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"class"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DELETE() {
              var cacheKey = 'DELETE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'delete') {
                r3 = 'delete';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"delete"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DEBUGGER() {
              var cacheKey = 'DEBUGGER@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 8) === 'debugger') {
                r3 = 'debugger';
                pos += 8;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"debugger"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_DO() {
              var cacheKey = 'DO@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'do') {
                r3 = 'do';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"do"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ELSE() {
              var cacheKey = 'ELSE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'else') {
                r3 = 'else';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"else"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_EXTENDS() {
              var cacheKey = 'EXTENDS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 7) === 'extends') {
                r3 = 'extends';
                pos += 7;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"extends"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FALSE() {
              var cacheKey = 'FALSE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'false') {
                r3 = 'false';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"false"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FINALLY() {
              var cacheKey = 'FINALLY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 7) === 'finally') {
                r3 = 'finally';
                pos += 7;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"finally"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_FOR() {
              var cacheKey = 'FOR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'for') {
                r3 = 'for';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"for"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IF() {
              var cacheKey = 'IF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'if') {
                r3 = 'if';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"if"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IN() {
              var cacheKey = 'IN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'in') {
                r3 = 'in';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"in"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_INSTANCEOF() {
              var cacheKey = 'INSTANCEOF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 10) === 'instanceof') {
                r3 = 'instanceof';
                pos += 10;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"instanceof"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_IS() {
              var cacheKey = 'IS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'is') {
                r3 = 'is';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"is"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ISNT() {
              var cacheKey = 'ISNT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'isnt') {
                r3 = 'isnt';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"isnt"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_LOOP() {
              var cacheKey = 'LOOP@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'loop') {
                r3 = 'loop';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"loop"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_MIXIN() {
              var cacheKey = 'MIXIN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'mixin') {
                r3 = 'mixin';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"mixin"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NEW() {
              var cacheKey = 'NEW@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'new') {
                r3 = 'new';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"new"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NO() {
              var cacheKey = 'NO@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'no') {
                r3 = 'no';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"no"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NOT() {
              var cacheKey = 'NOT@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'not') {
                r3 = 'not';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"not"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_NULL() {
              var cacheKey = 'NULL@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'null') {
                r3 = 'null';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"null"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OF() {
              var cacheKey = 'OF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'of') {
                r3 = 'of';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"of"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OFF() {
              var cacheKey = 'OFF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'off') {
                r3 = 'off';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"off"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ON() {
              var cacheKey = 'ON@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'on') {
                r3 = 'on';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"on"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OR() {
              var cacheKey = 'OR@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === 'or') {
                r3 = 'or';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"or"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_OWN() {
              var cacheKey = 'OWN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'own') {
                r3 = 'own';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"own"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_RETURN() {
              var cacheKey = 'RETURN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'return') {
                r3 = 'return';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"return"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SWITCH() {
              var cacheKey = 'SWITCH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'switch') {
                r3 = 'switch';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"switch"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SUPER() {
              var cacheKey = 'SUPER@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'super') {
                r3 = 'super';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"super"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THEN() {
              var cacheKey = 'THEN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'then') {
                r3 = 'then';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"then"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THIS() {
              var cacheKey = 'THIS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'this') {
                r3 = 'this';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"this"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_THROW() {
              var cacheKey = 'THROW@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'throw') {
                r3 = 'throw';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"throw"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TRUE() {
              var cacheKey = 'TRUE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'true') {
                r3 = 'true';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"true"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TRY() {
              var cacheKey = 'TRY@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'try') {
                r3 = 'try';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"try"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_TYPEOF() {
              var cacheKey = 'TYPEOF@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'typeof') {
                r3 = 'typeof';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"typeof"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNDEFINED() {
              var cacheKey = 'UNDEFINED@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 9) === 'undefined') {
                r3 = 'undefined';
                pos += 9;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"undefined"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNLESS() {
              var cacheKey = 'UNLESS@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 6) === 'unless') {
                r3 = 'unless';
                pos += 6;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"unless"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UNTIL() {
              var cacheKey = 'UNTIL@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'until') {
                r3 = 'until';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"until"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WHEN() {
              var cacheKey = 'WHEN@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'when') {
                r3 = 'when';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"when"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WHILE() {
              var cacheKey = 'WHILE@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 5) === 'while') {
                r3 = 'while';
                pos += 5;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"while"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_WITH() {
              var cacheKey = 'WITH@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 4) === 'with') {
                r3 = 'with';
                pos += 4;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"with"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_YES() {
              var cacheKey = 'YES@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 3) === 'yes') {
                r3 = 'yes';
                pos += 3;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"yes"');
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_identifierPart();
                reportFailures--;
                if (r4 === null) {
                  r4 = '';
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [
                    r3,
                    r4
                  ];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_SharedKeywords() {
              var cacheKey = 'SharedKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 4) === 'true') {
                r2 = 'true';
                pos += 4;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"true"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 5) === 'false') {
                  r2 = 'false';
                  pos += 5;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"false"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 4) === 'null') {
                    r2 = 'null';
                    pos += 4;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"null"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 4) === 'this') {
                      r2 = 'this';
                      pos += 4;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"this"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 3) === 'new') {
                        r2 = 'new';
                        pos += 3;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"new"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 6) === 'delete') {
                          r2 = 'delete';
                          pos += 6;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"delete"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 6) === 'typeof') {
                            r2 = 'typeof';
                            pos += 6;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"typeof"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 10) === 'instanceof') {
                              r2 = 'instanceof';
                              pos += 10;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"instanceof"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 2) === 'in') {
                                r2 = 'in';
                                pos += 2;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"in"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 6) === 'return') {
                                  r2 = 'return';
                                  pos += 6;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"return"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 5) === 'throw') {
                                    r2 = 'throw';
                                    pos += 5;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"throw"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 5) === 'break') {
                                      r2 = 'break';
                                      pos += 5;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"break"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 8) === 'continue') {
                                        r2 = 'continue';
                                        pos += 8;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"continue"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 8) === 'debugger') {
                                          r2 = 'debugger';
                                          pos += 8;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"debugger"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 2) === 'if') {
                                            r2 = 'if';
                                            pos += 2;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"if"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 4) === 'else') {
                                              r2 = 'else';
                                              pos += 4;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"else"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 6) === 'switch') {
                                                r2 = 'switch';
                                                pos += 6;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"switch"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 3) === 'for') {
                                                  r2 = 'for';
                                                  pos += 3;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"for"');
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos, 5) === 'while') {
                                                    r2 = 'while';
                                                    pos += 5;
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('"while"');
                                                    }
                                                  }
                                                  if (r2 === null) {
                                                    if (input.substr(pos, 2) === 'do') {
                                                      r2 = 'do';
                                                      pos += 2;
                                                    } else {
                                                      r2 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed('"do"');
                                                      }
                                                    }
                                                    if (r2 === null) {
                                                      if (input.substr(pos, 3) === 'try') {
                                                        r2 = 'try';
                                                        pos += 3;
                                                      } else {
                                                        r2 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed('"try"');
                                                        }
                                                      }
                                                      if (r2 === null) {
                                                        if (input.substr(pos, 5) === 'catch') {
                                                          r2 = 'catch';
                                                          pos += 5;
                                                        } else {
                                                          r2 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed('"catch"');
                                                          }
                                                        }
                                                        if (r2 === null) {
                                                          if (input.substr(pos, 7) === 'finally') {
                                                            r2 = 'finally';
                                                            pos += 7;
                                                          } else {
                                                            r2 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed('"finally"');
                                                            }
                                                          }
                                                          if (r2 === null) {
                                                            if (input.substr(pos, 5) === 'class') {
                                                              r2 = 'class';
                                                              pos += 5;
                                                            } else {
                                                              r2 = null;
                                                              if (reportFailures === 0) {
                                                                matchFailed('"class"');
                                                              }
                                                            }
                                                            if (r2 === null) {
                                                              if (input.substr(pos, 7) === 'extends') {
                                                                r2 = 'extends';
                                                                pos += 7;
                                                              } else {
                                                                r2 = null;
                                                                if (reportFailures === 0) {
                                                                  matchFailed('"extends"');
                                                                }
                                                              }
                                                              if (r2 === null) {
                                                                if (input.substr(pos, 5) === 'super') {
                                                                  r2 = 'super';
                                                                  pos += 5;
                                                                } else {
                                                                  r2 = null;
                                                                  if (reportFailures === 0) {
                                                                    matchFailed('"super"');
                                                                  }
                                                                }
                                                                if (r2 === null) {
                                                                  if (input.substr(pos, 4) === 'with') {
                                                                    r2 = 'with';
                                                                    pos += 4;
                                                                  } else {
                                                                    r2 = null;
                                                                    if (reportFailures === 0) {
                                                                      matchFailed('"with"');
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_JSKeywords() {
              var cacheKey = 'JSKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 4) === 'case') {
                r2 = 'case';
                pos += 4;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"case"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 7) === 'default') {
                  r2 = 'default';
                  pos += 7;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"default"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 8) === 'function') {
                    r2 = 'function';
                    pos += 8;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"function"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 3) === 'var') {
                      r2 = 'var';
                      pos += 3;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"var"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 4) === 'void') {
                        r2 = 'void';
                        pos += 4;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"void"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 5) === 'const') {
                          r2 = 'const';
                          pos += 5;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"const"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 3) === 'let') {
                            r2 = 'let';
                            pos += 3;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"let"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 4) === 'enum') {
                              r2 = 'enum';
                              pos += 4;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"enum"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 6) === 'export') {
                                r2 = 'export';
                                pos += 6;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"export"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 6) === 'import') {
                                  r2 = 'import';
                                  pos += 6;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"import"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 6) === 'native') {
                                    r2 = 'native';
                                    pos += 6;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"native"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 10) === 'implements') {
                                      r2 = 'implements';
                                      pos += 10;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"implements"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 9) === 'interface') {
                                        r2 = 'interface';
                                        pos += 9;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"interface"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 7) === 'package') {
                                          r2 = 'package';
                                          pos += 7;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"package"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 7) === 'private') {
                                            r2 = 'private';
                                            pos += 7;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"private"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 9) === 'protected') {
                                              r2 = 'protected';
                                              pos += 9;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"protected"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 6) === 'public') {
                                                r2 = 'public';
                                                pos += 6;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"public"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 6) === 'static') {
                                                  r2 = 'static';
                                                  pos += 6;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"static"');
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos, 5) === 'yield') {
                                                    r2 = 'yield';
                                                    pos += 5;
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('"yield"');
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_CSKeywords() {
              var cacheKey = 'CSKeywords@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4;
              r1 = pos;
              if (input.substr(pos, 9) === 'undefined') {
                r2 = 'undefined';
                pos += 9;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed('"undefined"');
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === 'then') {
                  r2 = 'then';
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"then"');
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 6) === 'unless') {
                    r2 = 'unless';
                    pos += 6;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"unless"');
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 5) === 'until') {
                      r2 = 'until';
                      pos += 5;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"until"');
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 4) === 'loop') {
                        r2 = 'loop';
                        pos += 4;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"loop"');
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 3) === 'off') {
                          r2 = 'off';
                          pos += 3;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"off"');
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 2) === 'by') {
                            r2 = 'by';
                            pos += 2;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"by"');
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 4) === 'when') {
                              r2 = 'when';
                              pos += 4;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"when"');
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 3) === 'and') {
                                r2 = 'and';
                                pos += 3;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"and"');
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 2) === 'or') {
                                  r2 = 'or';
                                  pos += 2;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"or"');
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 4) === 'isnt') {
                                    r2 = 'isnt';
                                    pos += 4;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"isnt"');
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 2) === 'is') {
                                      r2 = 'is';
                                      pos += 2;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"is"');
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 3) === 'not') {
                                        r2 = 'not';
                                        pos += 3;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"not"');
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 3) === 'yes') {
                                          r2 = 'yes';
                                          pos += 3;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"yes"');
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 2) === 'no') {
                                            r2 = 'no';
                                            pos += 2;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"no"');
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 2) === 'on') {
                                              r2 = 'on';
                                              pos += 2;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"on"');
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 2) === 'of') {
                                                r2 = 'of';
                                                pos += 2;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"of"');
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 5) === 'mixin') {
                                                  r2 = 'mixin';
                                                  pos += 5;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"mixin"');
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (r2 !== null) {
                r4 = pos;
                reportFailures++;
                r3 = parse_identifierPart();
                reportFailures--;
                if (r3 === null) {
                  r3 = '';
                } else {
                  r3 = null;
                  pos = r4;
                }
                if (r3 !== null) {
                  r0 = [
                    r2,
                    r3
                  ];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_reserved() {
              var cacheKey = 'reserved@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1;
              r1 = pos;
              r0 = parse_macro();
              if (r0 !== null) {
                r0 = input.substring(pos, r1);
              }
              if (r0 === null) {
                r0 = parse_SharedKeywords();
                if (r0 === null) {
                  r0 = parse_CSKeywords();
                  if (r0 === null) {
                    r0 = parse_JSKeywords();
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeEscapeSequence() {
              var cacheKey = 'UnicodeEscapeSequence@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3, r4, r5, r6, r7;
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === '\\u') {
                r3 = '\\u';
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\\\u"');
                }
              }
              if (r3 !== null) {
                r4 = parse_hexDigit();
                if (r4 !== null) {
                  r5 = parse_hexDigit();
                  if (r5 !== null) {
                    r6 = parse_hexDigit();
                    if (r6 !== null) {
                      r7 = parse_hexDigit();
                      if (r7 !== null) {
                        r0 = [
                          r3,
                          r4,
                          r5,
                          r6,
                          r7
                        ];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = function (h0, h1, h2, h3) {
                  return String.fromCharCode(parseInt(h0 + h1 + h2 + h3, 16));
                }(r4, r5, r6, r7);
              }
              if (r0 === null) {
                pos = r1;
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeLetter() {
              var cacheKey = 'UnicodeLetter@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uFF21-\uFF3Aa-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D62-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7C\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2D00-\u2D25\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA9CF\uAA70\uAADD\uFF70\uFF9E\uFF9F\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u2135-\u2138\u2D30-\u2D65\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FCB\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA2D\uFA30-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55340) {
                  r2 = '\uD82C';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uD82C"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDC00\uDC01]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDC00\\uDC01]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55304) {
                    r2 = '\uD808';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD808"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC00-\uDF6E]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDC00-\\uDF6E]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55401) {
                      r2 = '\uD869';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD869"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDED6\uDF00]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDED6\\uDF00]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.charCodeAt(pos) === 55305) {
                        r2 = '\uD809';
                        pos++;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\uD809"');
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDC00-\uDC62]/.test(input.charAt(pos))) {
                          r3 = input.charAt(pos);
                          pos++;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('[\\uDC00-\\uDC62]');
                          }
                        }
                        if (r3 !== null) {
                          r0 = [
                            r2,
                            r3
                          ];
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.charCodeAt(pos) === 55349) {
                          r2 = '\uD835';
                          pos++;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\uD835"');
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/.test(input.charAt(pos))) {
                            r3 = input.charAt(pos);
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]');
                            }
                          }
                          if (r3 !== null) {
                            r0 = [
                              r2,
                              r3
                            ];
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.charCodeAt(pos) === 55300) {
                            r2 = '\uD804';
                            pos++;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed('"\\uD804"');
                            }
                          }
                          if (r2 !== null) {
                            if (/^[\uDC03-\uDC37\uDC83-\uDCAF]/.test(input.charAt(pos))) {
                              r3 = input.charAt(pos);
                              pos++;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed('[\\uDC03-\\uDC37\\uDC83-\\uDCAF]');
                              }
                            }
                            if (r3 !== null) {
                              r0 = [
                                r2,
                                r3
                              ];
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.charCodeAt(pos) === 55296) {
                              r2 = '\uD800';
                              pos++;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed('"\\uD800"');
                              }
                            }
                            if (r2 !== null) {
                              if (/^[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF40\uDF42-\uDF49\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]/.test(input.charAt(pos))) {
                                r3 = input.charAt(pos);
                                pos++;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed('[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]');
                                }
                              }
                              if (r3 !== null) {
                                r0 = [
                                  r2,
                                  r3
                                ];
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              if (input.charCodeAt(pos) === 55308) {
                                r2 = '\uD80C';
                                pos++;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed('"\\uD80C"');
                                }
                              }
                              if (r2 !== null) {
                                if (/^[\uDC00-\uDFFF]/.test(input.charAt(pos))) {
                                  r3 = input.charAt(pos);
                                  pos++;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('[\\uDC00-\\uDFFF]');
                                  }
                                }
                                if (r3 !== null) {
                                  r0 = [
                                    r2,
                                    r3
                                  ];
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                if (input.charCodeAt(pos) === 55297) {
                                  r2 = '\uD801';
                                  pos++;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed('"\\uD801"');
                                  }
                                }
                                if (r2 !== null) {
                                  if (/^[\uDC00-\uDC9D]/.test(input.charAt(pos))) {
                                    r3 = input.charAt(pos);
                                    pos++;
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('[\\uDC00-\\uDC9D]');
                                    }
                                  }
                                  if (r3 !== null) {
                                    r0 = [
                                      r2,
                                      r3
                                    ];
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  if (input.charCodeAt(pos) === 55406) {
                                    r2 = '\uD86E';
                                    pos++;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed('"\\uD86E"');
                                    }
                                  }
                                  if (r2 !== null) {
                                    if (/^[\uDC1D]/.test(input.charAt(pos))) {
                                      r3 = input.charAt(pos);
                                      pos++;
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('[\\uDC1D]');
                                      }
                                    }
                                    if (r3 !== null) {
                                      r0 = [
                                        r2,
                                        r3
                                      ];
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                  if (r0 === null) {
                                    r1 = pos;
                                    if (input.charCodeAt(pos) === 55299) {
                                      r2 = '\uD803';
                                      pos++;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed('"\\uD803"');
                                      }
                                    }
                                    if (r2 !== null) {
                                      if (/^[\uDC00-\uDC48]/.test(input.charAt(pos))) {
                                        r3 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('[\\uDC00-\\uDC48]');
                                        }
                                      }
                                      if (r3 !== null) {
                                        r0 = [
                                          r2,
                                          r3
                                        ];
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                    if (r0 === null) {
                                      r1 = pos;
                                      if (input.charCodeAt(pos) === 55360) {
                                        r2 = '\uD840';
                                        pos++;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed('"\\uD840"');
                                        }
                                      }
                                      if (r2 !== null) {
                                        if (/^[\uDC00]/.test(input.charAt(pos))) {
                                          r3 = input.charAt(pos);
                                          pos++;
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('[\\uDC00]');
                                          }
                                        }
                                        if (r3 !== null) {
                                          r0 = [
                                            r2,
                                            r3
                                          ];
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                      if (r0 === null) {
                                        r1 = pos;
                                        if (input.charCodeAt(pos) === 55422) {
                                          r2 = '\uD87E';
                                          pos++;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed('"\\uD87E"');
                                          }
                                        }
                                        if (r2 !== null) {
                                          if (/^[\uDC00-\uDE1D]/.test(input.charAt(pos))) {
                                            r3 = input.charAt(pos);
                                            pos++;
                                          } else {
                                            r3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('[\\uDC00-\\uDE1D]');
                                            }
                                          }
                                          if (r3 !== null) {
                                            r0 = [
                                              r2,
                                              r3
                                            ];
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                        if (r0 === null) {
                                          r1 = pos;
                                          if (input.charCodeAt(pos) === 55405) {
                                            r2 = '\uD86D';
                                            pos++;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed('"\\uD86D"');
                                            }
                                          }
                                          if (r2 !== null) {
                                            if (/^[\uDF34\uDF40]/.test(input.charAt(pos))) {
                                              r3 = input.charAt(pos);
                                              pos++;
                                            } else {
                                              r3 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('[\\uDF34\\uDF40]');
                                              }
                                            }
                                            if (r3 !== null) {
                                              r0 = [
                                                r2,
                                                r3
                                              ];
                                            } else {
                                              r0 = null;
                                              pos = r1;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                          if (r0 === null) {
                                            r1 = pos;
                                            if (input.charCodeAt(pos) === 55322) {
                                              r2 = '\uD81A';
                                              pos++;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed('"\\uD81A"');
                                              }
                                            }
                                            if (r2 !== null) {
                                              if (/^[\uDC00-\uDE38]/.test(input.charAt(pos))) {
                                                r3 = input.charAt(pos);
                                                pos++;
                                              } else {
                                                r3 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('[\\uDC00-\\uDE38]');
                                                }
                                              }
                                              if (r3 !== null) {
                                                r0 = [
                                                  r2,
                                                  r3
                                                ];
                                              } else {
                                                r0 = null;
                                                pos = r1;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r1;
                                            }
                                            if (r0 === null) {
                                              r1 = pos;
                                              if (input.charCodeAt(pos) === 55298) {
                                                r2 = '\uD802';
                                                pos++;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed('"\\uD802"');
                                                }
                                              }
                                              if (r2 !== null) {
                                                if (/^[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72]/.test(input.charAt(pos))) {
                                                  r3 = input.charAt(pos);
                                                  pos++;
                                                } else {
                                                  r3 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]');
                                                  }
                                                }
                                                if (r3 !== null) {
                                                  r0 = [
                                                    r2,
                                                    r3
                                                  ];
                                                } else {
                                                  r0 = null;
                                                  pos = r1;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r1;
                                              }
                                              if (r0 === null) {
                                                r1 = pos;
                                                if (input.charCodeAt(pos) === 55309) {
                                                  r2 = '\uD80D';
                                                  pos++;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed('"\\uD80D"');
                                                  }
                                                }
                                                if (r2 !== null) {
                                                  if (/^[\uDC00-\uDC2E]/.test(input.charAt(pos))) {
                                                    r3 = input.charAt(pos);
                                                    pos++;
                                                  } else {
                                                    r3 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed('[\\uDC00-\\uDC2E]');
                                                    }
                                                  }
                                                  if (r3 !== null) {
                                                    r0 = [
                                                      r2,
                                                      r3
                                                    ];
                                                  } else {
                                                    r0 = null;
                                                    pos = r1;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r1;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeCombiningMark() {
              var cacheKey = 'UnicodeCombiningMark@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u19B0-\u19C0\u19C8\u19C9\u1A19-\u1A1B\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 56128) {
                  r2 = '\uDB40';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uDB40"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDD00-\uDDEF]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDD00-\\uDDEF]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55348) {
                    r2 = '\uD834';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD834"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDD65\uDD66\uDD6D-\uDD72]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55300) {
                      r2 = '\uD804';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD804"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDC01\uDC38-\uDC46\uDC80\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.charCodeAt(pos) === 55296) {
                        r2 = '\uD800';
                        pos++;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed('"\\uD800"');
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDDFD]/.test(input.charAt(pos))) {
                          r3 = input.charAt(pos);
                          pos++;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed('[\\uDDFD]');
                          }
                        }
                        if (r3 !== null) {
                          r0 = [
                            r2,
                            r3
                          ];
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.charCodeAt(pos) === 55298) {
                          r2 = '\uD802';
                          pos++;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed('"\\uD802"');
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F]/.test(input.charAt(pos))) {
                            r3 = input.charAt(pos);
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed('[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]');
                            }
                          }
                          if (r3 !== null) {
                            r0 = [
                              r2,
                              r3
                            ];
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      }
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeDigit() {
              var cacheKey = 'UnicodeDigit@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0, r1, r2, r3;
              if (/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]');
                }
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55349) {
                  r2 = '\uD835';
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed('"\\uD835"');
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDFCE-\uDFFF]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed('[\\uDFCE-\\uDFFF]');
                    }
                  }
                  if (r3 !== null) {
                    r0 = [
                      r2,
                      r3
                    ];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55300) {
                    r2 = '\uD804';
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed('"\\uD804"');
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC66-\uDC6F]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed('[\\uDC66-\\uDC6F]');
                      }
                    }
                    if (r3 !== null) {
                      r0 = [
                        r2,
                        r3
                      ];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55297) {
                      r2 = '\uD801';
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed('"\\uD801"');
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDCA0-\uDCA9]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed('[\\uDCA0-\\uDCA9]');
                        }
                      }
                      if (r3 !== null) {
                        r0 = [
                          r2,
                          r3
                        ];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  }
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_UnicodeConnectorPunctuation() {
              var cacheKey = 'UnicodeConnectorPunctuation@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (/^[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/.test(input.charAt(pos))) {
                r0 = input.charAt(pos);
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ZWNJ() {
              var cacheKey = 'ZWNJ@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 8204) {
                r0 = '\u200C';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\u200C"');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function parse_ZWJ() {
              var cacheKey = 'ZWJ@' + pos;
              var cachedResult = cache[cacheKey];
              if (cachedResult) {
                pos = cachedResult.nextPos;
                return cachedResult.result;
              }
              var r0;
              if (input.charCodeAt(pos) === 8205) {
                r0 = '\u200D';
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed('"\\u200D"');
                }
              }
              cache[cacheKey] = {
                nextPos: pos,
                result: r0
              };
              return r0;
            }
            function cleanupExpected(expected) {
              expected.sort();
              var lastExpected = null;
              var cleanExpected = [];
              for (var i = 0; i < expected.length; i++) {
                if (expected[i] !== lastExpected) {
                  cleanExpected.push(expected[i]);
                  lastExpected = expected[i];
                }
              }
              return cleanExpected;
            }
            var CS = require('/lib/nodes.js', module), constructorLookup = {
                '||': CS.LogicalOrOp,
                or: CS.LogicalOrOp,
                '&&': CS.LogicalAndOp,
                and: CS.LogicalAndOp,
                '|': CS.BitOrOp,
                '^': CS.BitXorOp,
                '&': CS.BitAndOp,
                '?': CS.ExistsOp,
                '==': CS.EQOp,
                is: CS.EQOp,
                '!=': CS.NEQOp,
                isnt: CS.NEQOp,
                '<=': CS.LTEOp,
                '>=': CS.GTEOp,
                '<': CS.LTOp,
                '>': CS.GTOp,
                'extends': CS.ExtendsOp,
                'instanceof': CS.InstanceofOp,
                'in': CS.InOp,
                'of': CS.OfOp,
                '<<': CS.LeftShiftOp,
                '>>': CS.SignedRightShiftOp,
                '>>>': CS.UnsignedRightShiftOp,
                '+': CS.PlusOp,
                '-': CS.SubtractOp,
                '*': CS.MultiplyOp,
                '/': CS.DivideOp,
                '%': CS.RemOp,
                '**': CS.ExpOp
              }, negatableOps = [
                'instanceof',
                'in',
                'of'
              ], chainableComparisonOps = [
                '<=',
                '>=',
                '<',
                '>',
                '==',
                'is',
                '!=',
                'isnt'
              ], rightAssocOps = [
                ';',
                '=',
                '?',
                '**'
              ], precedenceHierarchy = [
                [
                  'or',
                  '||'
                ],
                [
                  'and',
                  '&&'
                ],
                ['|'],
                ['^'],
                ['&'],
                ['?'],
                [
                  'is',
                  '==',
                  'isnt',
                  '!='
                ],
                [
                  'instanceof',
                  'in',
                  'of',
                  '<=',
                  '>=',
                  '<',
                  '>'
                ],
                [
                  '<<',
                  '>>',
                  '>>>'
                ],
                [
                  '+',
                  '-'
                ],
                [
                  '*',
                  '/',
                  '%'
                ],
                ['**']
              ], precedenceTable = function () {
                var table = {}, ops, op;
                for (var level = 0, l = precedenceHierarchy.length; level < l; ++level) {
                  ops = precedenceHierarchy[level];
                  for (var o = 0, k = ops.length; o < k; ++o) {
                    op = ops[o];
                    table[op] = level;
                  }
                }
                return table;
              }(), RIGHT_ASSOCIATIVE = {}, LEFT_ASSOCIATIVE = {}, associativities = function () {
                var result = {};
                for (var op in precedenceTable) {
                  if (!{}.hasOwnProperty.call(precedenceTable, op))
                    continue;
                  result[op] = LEFT_ASSOCIATIVE;
                }
                for (var i = 0, l = rightAssocOps.length; i < l; ++i) {
                  result[rightAssocOps[i]] = RIGHT_ASSOCIATIVE;
                }
                return result;
              }();
            for (var i = 0, l = negatableOps.length; i < l; ++i) {
              (function (op) {
                var fn = function (a, b) {
                  return new CS.LogicalNotOp(new constructorLookup[op](a, b));
                };
                fn.prototype = constructorLookup[op].prototype;
                var negatedOp = 'not ' + op;
                constructorLookup[negatedOp] = fn;
                precedenceTable[negatedOp] = precedenceTable[op];
                associativities[negatedOp] = associativities[op];
              }(negatableOps[i]));
            }
            var prefixConstructorLookup = {
                '++': CS.PreIncrementOp,
                '--': CS.PreDecrementOp,
                '+': CS.UnaryPlusOp,
                '-': CS.UnaryNegateOp,
                '!': CS.LogicalNotOp,
                'not': CS.LogicalNotOp,
                '~': CS.BitNotOp,
                'do': CS.DoOp,
                'typeof': CS.TypeofOp,
                'delete': CS.DeleteOp
              }, postfixConstructorLookup = {
                '?': CS.UnaryExistsOp,
                '[..]': CS.ShallowCopyArray,
                '++': CS.PostIncrementOp,
                '--': CS.PostDecrementOp
              }, foldl = function (fn, memo, list) {
                for (var i = 0, l = list.length; i < l; ++i)
                  memo = fn(memo, list[i]);
                return memo;
              }, foldr = function (fn, memo, list) {
                for (var i = list.length; i--;)
                  memo = fn(memo, list[i]);
                return memo;
              }, foldBinaryExpr = function (parts, ignoreChains) {
                var stack, chainStack, nextPrec, nextOp, className, ctor, prec, rightOperand, leftOperand, operator, i, expr;
                if (parts.length < 3)
                  return parts[0];
                stack = [].slice.call(parts, 0, 3);
                parts = [].slice.call(parts, 3);
                while (parts.length > 0) {
                  nextOp = parts[0];
                  if (!ignoreChains && stack.length > 2) {
                    operator = stack[stack.length - 2];
                    if (chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0) {
                      chainStack = stack.slice(-3);
                      stack = stack.slice(0, stack.length - 3);
                      do {
                        operator = nextOp;
                        chainStack.push(parts.shift(), parts.shift());
                        nextOp = parts[0];
                        if (nextOp) {
                          nextPrec = precedenceTable[nextOp];
                          prec = precedenceTable[operator];
                        }
                      } while (nextOp != null && (nextPrec > prec || chainableComparisonOps.indexOf(nextOp) >= 0));
                      stack.push(new CS.ChainedComparisonOp(foldBinaryExpr(chainStack, true)));
                      continue;
                    }
                  }
                  while (stack.length > 2 && (operator = stack[stack.length - 2], prec = precedenceTable[operator], nextPrec = precedenceTable[nextOp], nextPrec < prec || chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0 || nextPrec == prec && associativities[operator] === LEFT_ASSOCIATIVE)) {
                    rightOperand = stack.pop();
                    stack.pop();
                    leftOperand = stack.pop();
                    stack.push(new constructorLookup[operator](leftOperand, rightOperand));
                  }
                  stack.push(parts.shift());
                  stack.push(parts.shift());
                }
                expr = stack.pop();
                while (stack.length > 0)
                  expr = new constructorLookup[(stack.pop())](stack.pop(), expr);
                return expr;
              }, createInterpolation = function (es) {
                var init = new CS.String('').g();
                return foldl(function (memo, s) {
                  if (s instanceof CS.String) {
                    var left = memo;
                    while (left)
                      if (left instanceof CS.String) {
                        if (left === init) {
                          c(left, s);
                          delete left.generated;
                        }
                        left.data = left.data + s.data;
                        return memo;
                      } else if (left instanceof CS.ConcatOp) {
                        left = left.right;
                      } else {
                        break;
                      }
                  }
                  return new CS.ConcatOp(memo, s);
                }, init, es);
              }, createMemberExpression = function (e, accesses) {
                return foldl(function (left, access) {
                  var F = function () {
                  };
                  F.prototype = access.op.prototype;
                  var o = new F;
                  access.op.apply(o, [left].concat(access.operands));
                  return c(o.r(left.raw + access.raw), e);
                }, e, accesses);
              }, isValidRegExpFlags = function (flags) {
                if (!flags)
                  return true;
                if (flags.length > 4)
                  return false;
                flags.sort();
                var flag = null;
                for (var i = 0, l = flags.length; i < l; ++i)
                  if (flag == flags[i])
                    return false;
                  else
                    flag = flags[i];
                return true;
              }, stripLeadingWhitespace = function (str) {
                str = str.replace(/\s+$/, '');
                var attempt, match, matchStr = str, indent = null;
                while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
                  attempt = match[1];
                  matchStr = matchStr.slice(match.index + match[0].length);
                  if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                    indent = attempt;
                }
                if (indent)
                  str = str.replace(new RegExp('\\n' + indent, 'g'), '\n');
                str = str.replace(/^\n/, '');
                return str;
              }, stripLeadingWhitespaceInterpolation = function (pieces) {
                var indent = null, piece, match, i, l, attempt, matchStr;
                for (i = 0, l = pieces.length; i < l; ++i) {
                  piece = pieces[i];
                  if (piece instanceof CS.String) {
                    if (i == l - 1)
                      piece.data = piece.data.replace(/\s+$/, '');
                    matchStr = piece.data;
                    while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
                      attempt = match[1];
                      matchStr = matchStr.slice(match.index + match[0].length);
                      if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                        indent = attempt;
                    }
                  }
                }
                if (indent) {
                  for (i = 0, l = pieces.length; i < l; ++i) {
                    piece = pieces[i];
                    if (piece instanceof CS.String) {
                      piece.data = piece.data.replace(new RegExp('\\n' + indent, 'g'), '\n');
                      if (i === l - 1)
                        piece.data = piece.data.replace(/(\n\s*)+$/, '');
                      if (i === 0)
                        piece.data = piece.data.replace(/^\n/, '');
                    }
                  }
                }
                return pieces;
              }, id = function (x) {
                return x;
              }, r = options.raw ? function (node) {
                node.raw = text().replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
                return node;
              } : id, p = options.raw ? function (node) {
                node.line = line();
                node.column = column();
                node.offset = offset();
                return node;
              } : id, rp = options.raw ? function (node) {
                return r(p(node));
              } : id, c = options.raw ? function (to, from) {
                to.line = from.line;
                to.column = from.column;
                to.offset = from.offset;
                return to;
              } : id;
            function computeReportedPosDetails() {
              function advanceCachedReportedPos() {
                var ch;
                for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
                  ch = input.charAt(cachedReportedPos);
                  if (ch === '\n') {
                    if (!cachedReportedPosDetails.seenCR) {
                      cachedReportedPosDetails.line++;
                    }
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = false;
                  } else if (ch === '\r' || ch === '\u2028' || ch === '\u2029') {
                    cachedReportedPosDetails.line++;
                    cachedReportedPosDetails.column = 1;
                    cachedReportedPosDetails.seenCR = true;
                  } else if (!/[\uEFEF\uEFFE\uEFFF]/.test(ch)) {
                    cachedReportedPosDetails.column++;
                    cachedReportedPosDetails.seenCR = false;
                  }
                }
              }
              if (cachedReportedPos !== reportedPos) {
                if (cachedReportedPos > reportedPos) {
                  cachedReportedPos = 0;
                  cachedReportedPosDetails = {
                    line: 1,
                    column: 1,
                    seenCR: false
                  };
                }
                advanceCachedReportedPos();
              }
              return cachedReportedPosDetails;
            }
            var result = parseFunctions[startRule]();
            if (result === null || pos !== input.length) {
              reportedPos = Math.max(pos, rightmostFailuresPos);
              var found = reportedPos < input.length ? input.charAt(reportedPos) : null;
              var reportedPosDetails = computeReportedPosDetails();
              throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, reportedPos, reportedPosDetails.line, reportedPosDetails.column);
            }
            return result;
          }
        };
      result.SyntaxError = function (expected, found, offset, line, column) {
        function buildMessage(expected, found) {
          var expectedHumanized, foundHumanized;
          switch (expected.length) {
          case 0:
            expectedHumanized = 'end of input';
            break;
          case 1:
            expectedHumanized = expected[0];
            break;
          default:
            expectedHumanized = expected.slice(0, expected.length - 1).join(', ') + ' or ' + expected[expected.length - 1];
          }
          foundHumanized = found ? quote(found) : 'end of input';
          return 'Expected ' + expectedHumanized + ' but ' + foundHumanized + ' found.';
        }
        this.name = 'SyntaxError';
        this.expected = expected;
        this.found = found;
        this.message = buildMessage(expected, found);
        this.offset = offset;
        this.line = line;
        this.column = column;
      };
      subclass(result.SyntaxError, Error);
      return result;
    }();
  });
  require.define('/lib/nodes.js', function (module, exports, __dirname, __filename) {
    var Annotations, ArrayInitialiser, AssignOp, Block, Bool, Class, CompoundAssignOp, ComputedProperty, concat, concatMap, Conditional, createNodes, difference, enumerableMethods, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, MemberAccessOp, Mixin, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, ObjectInitialiserMember, PostDecrementOp, PostIncrementOp, Primitives, Range, RegExp, RegExps, Slice, SoakedMemberAccessOp, StaticMemberAccessOps, Super, Switch, SwitchCase, This, union, While;
    cache$ = require('/lib/functional-helpers.js', module);
    map = cache$.map;
    concat = cache$.concat;
    concatMap = cache$.concatMap;
    difference = cache$.difference;
    nub = cache$.nub;
    union = cache$.union;
    exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
    if (!('undefined' !== typeof Ember && null != Ember))
      require('/lib/ember-runtime.js', module);
    createNodes = function (subclasses, superclasses) {
      var className, specs;
      if (null == superclasses)
        superclasses = [];
      for (className in subclasses) {
        if (!isOwn$(subclasses, className))
          continue;
        specs = subclasses[className];
        (function (className) {
          var externalCtor$, isCategory, klass, params, superclass;
          superclass = null != superclasses[0] ? superclasses[0] : function () {
          };
          isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
          params = 'undefined' !== typeof specs && null != specs ? function () {
            switch (specs.length) {
            case 0:
              return [];
            case 1:
            case 2:
              return specs[0];
            }
          }.call(this) : null;
          if (null != params)
            params;
          else
            params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
          klass = function (super$) {
            extends$(class$, super$);
            externalCtor$ = isCategory ? function () {
            } : function () {
              var i, param;
              for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
                param = params[i$];
                i = i$;
                this[param] = arguments[i];
              }
              if (null != this.initialise)
                this.initialise.apply(this, arguments);
              return this;
            };
            function class$() {
              return externalCtor$.apply(this, arguments);
            }
            class$.prototype.className = className;
            class$.superclasses = superclasses;
            return class$;
          }(superclass);
          if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
            klass.prototype.childNodes = specs[0];
          if (isCategory)
            createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
          return exports[className] = klass;
        }(className));
      }
    };
    createNodes({
      Nodes: [
        [],
        {
          BinOps: [
            [
              'left',
              'right'
            ],
            {
              AssignOps: [
                [
                  'assignee',
                  'expression'
                ],
                {
                  AssignOp: null,
                  ClassProtoAssignOp: null,
                  CompoundAssignOp: [[
                      'op',
                      'assignee',
                      'expression'
                    ]]
                }
              ],
              BitOps: [
                null,
                {
                  BitAndOp: null,
                  BitOrOp: null,
                  BitXorOp: null,
                  LeftShiftOp: null,
                  SignedRightShiftOp: null,
                  UnsignedRightShiftOp: null
                }
              ],
              ComparisonOps: [
                null,
                {
                  EQOp: null,
                  GTEOp: null,
                  GTOp: null,
                  LTEOp: null,
                  LTOp: null,
                  NEQOp: null
                }
              ],
              ConcatOp: null,
              ExistsOp: null,
              ExtendsOp: null,
              InOp: null,
              InstanceofOp: null,
              LogicalOps: [
                null,
                {
                  LogicalAndOp: null,
                  LogicalOrOp: null
                }
              ],
              MathsOps: [
                null,
                {
                  ExpOp: null,
                  DivideOp: null,
                  MultiplyOp: null,
                  RemOp: null,
                  SubtractOp: null
                }
              ],
              OfOp: null,
              PlusOp: null,
              Range: [[
                  'isInclusive',
                  'left',
                  'right'
                ]],
              SeqOp: null
            }
          ],
          Statements: [
            [],
            {
              Break: null,
              Continue: null,
              Debugger: null,
              Return: [['expression']],
              Throw: [['expression']]
            }
          ],
          UnaryOps: [
            ['expression'],
            {
              BitNotOp: null,
              DeleteOp: null,
              DoOp: null,
              LogicalNotOp: null,
              NewOp: [[
                  'ctor',
                  'arguments'
                ]],
              PreDecrementOp: null,
              PreIncrementOp: null,
              PostDecrementOp: null,
              PostIncrementOp: null,
              TypeofOp: null,
              UnaryExistsOp: null,
              UnaryNegateOp: null,
              UnaryPlusOp: null
            }
          ],
          MemberAccessOps: [
            null,
            {
              StaticMemberAccessOps: [
                [
                  'expression',
                  'memberName'
                ],
                {
                  MemberAccessOp: null,
                  NativeMemberAccessOp: null,
                  ProtoMemberAccessOp: null,
                  SoakedMemberAccessOp: null,
                  SoakedProtoMemberAccessOp: null
                }
              ],
              DynamicMemberAccessOps: [
                [
                  'expression',
                  'indexingExpr'
                ],
                {
                  DynamicMemberAccessOp: null,
                  DynamicProtoMemberAccessOp: null,
                  SoakedDynamicMemberAccessOp: null,
                  SoakedDynamicProtoMemberAccessOp: null
                }
              ]
            }
          ],
          ChainedComparisonOp: [['expression']],
          FunctionApplications: [
            [
              'function',
              'arguments'
            ],
            {
              FunctionApplication: null,
              SoakedFunctionApplication: null
            }
          ],
          Super: null,
          Program: [['body']],
          Block: [['statements']],
          Conditional: [[
              'condition',
              'consequent',
              'alternate'
            ]],
          ForIn: [[
              'valAssignee',
              'keyAssignee',
              'target',
              'step',
              'filter',
              'body'
            ]],
          ForOf: [[
              'isOwn',
              'keyAssignee',
              'valAssignee',
              'target',
              'filter',
              'body'
            ]],
          Switch: [[
              'expression',
              'cases',
              'alternate'
            ]],
          SwitchCase: [[
              'conditions',
              'consequent'
            ]],
          Try: [[
              'body',
              'catchAssignee',
              'catchBody',
              'finallyBody'
            ]],
          While: [[
              'condition',
              'body'
            ]],
          ArrayInitialiser: [['members']],
          ObjectInitialiser: [['members']],
          ObjectInitialiserMember: [[
              'key',
              'expression',
              'annotations'
            ]],
          Mixin: [[
              'nameAssignee',
              'body',
              'mixins'
            ]],
          Class: [[
              'nameAssignee',
              'parent',
              'ctor',
              'body',
              'mixins',
              'boundMembers'
            ]],
          Constructor: [['expression']],
          Functions: [
            [
              'parameters',
              'body'
            ],
            {
              Function: null,
              BoundFunction: null,
              ComputedProperty: null
            }
          ],
          DefaultParam: [[
              'param',
              'default'
            ]],
          Annotations: [
            ['parameters'],
            {
              Volatile: null,
              Computed: null,
              Observes: null
            }
          ],
          Identifiers: [
            ['data'],
            {
              Identifier: null,
              GenSym: null
            }
          ],
          Null: null,
          Primitives: [
            ['data'],
            {
              Bool: null,
              JavaScript: null,
              Numbers: [
                null,
                {
                  Int: null,
                  Float: null
                }
              ],
              String: null
            }
          ],
          RegExps: [
            null,
            {
              RegExp: [[
                  'data',
                  'flags'
                ]],
              HeregExp: [[
                  'expression',
                  'flags'
                ]]
            }
          ],
          This: null,
          Undefined: null,
          Slice: [[
              'expression',
              'isInclusive',
              'left',
              'right'
            ]],
          Rest: [['expression']],
          Spread: [['expression']]
        }
      ]
    });
    cache$1 = exports;
    Nodes = cache$1.Nodes;
    Primitives = cache$1.Primitives;
    CompoundAssignOp = cache$1.CompoundAssignOp;
    StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
    Range = cache$1.Range;
    ArrayInitialiser = cache$1.ArrayInitialiser;
    ObjectInitialiser = cache$1.ObjectInitialiser;
    NegatedConditional = cache$1.NegatedConditional;
    Conditional = cache$1.Conditional;
    Identifier = cache$1.Identifier;
    ForOf = cache$1.ForOf;
    Functions = cache$1.Functions;
    While = cache$1.While;
    Mixin = cache$1.Mixin;
    Class = cache$1.Class;
    Block = cache$1.Block;
    NewOp = cache$1.NewOp;
    Bool = cache$1.Bool;
    FunctionApplications = cache$1.FunctionApplications;
    RegExps = cache$1.RegExps;
    RegExp = cache$1.RegExp;
    HeregExp = cache$1.HeregExp;
    Super = cache$1.Super;
    Slice = cache$1.Slice;
    Switch = cache$1.Switch;
    Identifiers = cache$1.Identifiers;
    SwitchCase = cache$1.SwitchCase;
    GenSym = cache$1.GenSym;
    ComputedProperty = cache$1.ComputedProperty;
    ObjectInitialiserMember = cache$1.ObjectInitialiserMember;
    Annotations = cache$1.Annotations;
    PostIncrementOp = cache$1.PostIncrementOp;
    PostDecrementOp = cache$1.PostDecrementOp;
    MemberAccessOp = cache$1.MemberAccessOp;
    This = cache$1.This;
    AssignOp = cache$1.AssignOp;
    SoakedMemberAccessOp = cache$1.SoakedMemberAccessOp;
    Nodes.fromBasicObject = function (obj) {
      return exports[obj.type].fromBasicObject(obj);
    };
    Nodes.prototype.listMembers = [];
    Nodes.prototype.toBasicObject = function () {
      var child, obj, p;
      obj = { type: this.className };
      if (null != this.line)
        obj.line = this.line;
      if (null != this.column)
        obj.column = this.column;
      if (null != this.raw) {
        obj.raw = this.raw;
        if (null != this.offset)
          obj.range = [
            this.offset,
            this.offset + this.raw.length
          ];
      }
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          obj[child] = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.toBasicObject());
            }
            return accum$;
          }.call(this, []);
        } else {
          obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
        }
      }
      return obj;
    };
    Nodes.prototype.fold = function (memo, fn) {
      var child, p;
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        child = this.childNodes[i$];
        if (in$(child, this.listMembers)) {
          memo = function (accum$) {
            for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
              p = this[child][i$1];
              accum$.push(p.fold(memo, fn));
            }
            return accum$;
          }.call(this, []);
        } else {
          memo = this[child].fold(memo, fn);
        }
      }
      return fn(memo, this);
    };
    Nodes.prototype.clone = function () {
      var ctor, k, n, v;
      ctor = function () {
      };
      ctor.prototype = this.constructor.prototype;
      n = new ctor;
      for (k in this) {
        if (!isOwn$(this, k))
          continue;
        v = this[k];
        n[k] = v;
      }
      return n;
    };
    Nodes.prototype['instanceof'] = function () {
      var ctor, ctors, superclasses;
      ctors = arguments.length > 0 ? [].slice.call(arguments, 0) : [];
      superclasses = map(this.constructor.superclasses, function (c) {
        return c.prototype.className;
      });
      for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
        ctor = ctors[i$];
        if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
          continue;
        return true;
      }
      return false;
    };
    Nodes.prototype.r = function (param$) {
      this.raw = param$;
      return this;
    };
    Nodes.prototype.p = function (param$, param$1, param$2) {
      this.line = param$;
      this.column = param$1;
      this.offset = param$2;
      return this;
    };
    Nodes.prototype.generated = false;
    Nodes.prototype.g = function () {
      this.generated = true;
      return this;
    };
    handlePrimitives = function (ctor) {
      var primitives;
      primitives = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
      return ctor.prototype.toBasicObject = function () {
        var obj, primitive;
        obj = Nodes.prototype.toBasicObject.call(this);
        for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
          primitive = primitives[i$];
          obj[primitive] = this[primitive];
        }
        return obj;
      };
    };
    handlePrimitives(Class, 'boundMembers');
    handlePrimitives(CompoundAssignOp, 'op');
    handlePrimitives(ForOf, 'isOwn');
    handlePrimitives(HeregExp, 'flags');
    handlePrimitives(Identifiers, 'data');
    handlePrimitives(Primitives, 'data');
    handlePrimitives(Range, 'isInclusive');
    handlePrimitives(RegExp, 'data', 'flags');
    handlePrimitives(Slice, 'isInclusive');
    handlePrimitives(StaticMemberAccessOps, 'memberName');
    handlePrimitives(ComputedProperty, 'chains');
    handlePrimitives(ObjectInitialiserMember, 'annotations');
    handlePrimitives(Annotations, 'parameters');
    handleLists = function (ctor) {
      var listProps;
      listProps = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
      return ctor.prototype.listMembers = listProps;
    };
    handleLists(ArrayInitialiser, 'members');
    handleLists(Block, 'statements');
    handleLists(Functions, 'parameters');
    handleLists(FunctionApplications, 'arguments');
    handleLists(NewOp, 'arguments');
    handleLists(ObjectInitialiser, 'members');
    handleLists(Super, 'arguments');
    handleLists(Switch, 'cases');
    handleLists(SwitchCase, 'conditions');
    handleLists(Class, 'mixins');
    handleLists(Mixin, 'mixins');
    Block.wrap = function (s) {
      return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
    };
    Class.prototype.initialise = function () {
      if (null != this.boundMembers)
        this.boundMembers;
      else
        this.boundMembers = [];
      this.name = new GenSym('class');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Class.prototype.childNodes.push('name');
    Mixin.prototype.initialise = function () {
      this.name = new GenSym('mixin');
      if (null != this.nameAssignee)
        return this.name = function () {
          switch (false) {
          case !this.nameAssignee['instanceof'](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
          }
        }.call(this);
    };
    Mixin.prototype.childNodes.push('name');
    ObjectInitialiser.prototype.keys = function () {
      return map(this.members, function (m) {
        return m.key;
      });
    };
    ObjectInitialiser.prototype.vals = function () {
      return map(this.members, function (m) {
        return m.expression;
      });
    };
    RegExps.prototype.initialise = function (_, flags) {
      var flag;
      this.flags = {};
      for (var cache$2 = [
            'g',
            'i',
            'm',
            'y'
          ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
        flag = cache$2[i$];
        this.flags[flag] = in$(flag, flags);
      }
    };
    PostIncrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    PostDecrementOp.prototype.initialise = function () {
      return this.expression.isAssignment = true;
    };
    Nodes.prototype.dependentKeys = function (scope) {
      var chains, child, childName, member;
      if (null == scope)
        scope = {};
      chains = [];
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            chains = chains.concat(member.dependentKeys(scope));
          }
        } else {
          child = this[childName];
          chains = chains.concat(child.dependentKeys(scope));
        }
      }
      return chains;
    };
    This.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return [[]];
    };
    MemberAccessOp.prototype.dependentKeys = function (scope) {
      var memberName;
      if (null == scope)
        scope = {};
      memberName = this.memberName;
      return this.expression.dependentKeys(scope).map(function (c) {
        if (!(memberName === 'constructor'))
          c.push(memberName);
        return c;
      });
    };
    SoakedMemberAccessOp.prototype.dependentKeys = MemberAccessOp.prototype.dependentKeys;
    enumerableMethods = Ember.Set.create();
    enumerableMethods.addObjects(Ember.Enumerable.keys());
    enumerableMethods.addObjects(Ember.Array.keys());
    enumerableMethods.addObjects(Ember.MutableArray.keys());
    enumerableMethods.addObjects(Ember.MutableEnumerable.keys());
    FunctionApplications.prototype.dependentKeys = function (scope) {
      var argument, res;
      if (null == scope)
        scope = {};
      res = this['function'].dependentKeys(scope);
      if (this['function']['instanceof'](MemberAccessOp) || this['function']['instanceof'](SoakedMemberAccessOp)) {
        res = res.map(function (c) {
          c.pop();
          return c;
        });
        if (enumerableMethods.contains(this['function'].memberName))
          res = res.map(function (c) {
            c.push('@each');
            return c;
          });
      }
      for (var i$ = 0, length$ = this['arguments'].length; i$ < length$; ++i$) {
        argument = this['arguments'][i$];
        argument.dependentKeys(scope).map(function (c) {
          return res.push(c);
        });
      }
      return res;
    };
    Block.prototype.dependentKeys = function (scope) {
      var key, newScope, res;
      if (null == scope)
        scope = {};
      res = [];
      newScope = Ember.copy(scope);
      for (var i$ = 0, length$ = newScope.length; i$ < length$; ++i$) {
        key = newScope[i$];
        newScope[key] = Ember.copy(newScope[key]);
      }
      this.statements.forEach(function (s) {
        return res = res.concat(s.dependentKeys(scope));
      });
      for (var i$1 = 0, length$1 = scope.length; i$1 < length$1; ++i$1) {
        key = scope[i$1];
        scope[key] = scope[key].concat(newScope[key]);
      }
      return res;
    };
    AssignOp.prototype.dependentKeys = function (scope) {
      var res;
      if (null == scope)
        scope = {};
      res = this.expression.dependentKeys(scope);
      if (this.assignee['instanceof'](Identifier))
        scope[this.assignee.data] = (scope[this.assignee.data] || []).concat(res);
      return res;
    };
    Identifier.prototype.dependentKeys = function (scope) {
      if (null == scope)
        scope = {};
      return Ember.copy(scope[this.data]) || [];
    };
    exports.NegatedConditional = function (super$) {
      extends$(NegatedConditional, super$);
      function NegatedConditional() {
        Conditional.apply(this, arguments);
      }
      return NegatedConditional;
    }(Conditional);
    exports.NegatedWhile = function (super$1) {
      extends$(NegatedWhile, super$1);
      function NegatedWhile() {
        While.apply(this, arguments);
      }
      return NegatedWhile;
    }(While);
    exports.Loop = function (super$2) {
      extends$(Loop, super$2);
      function Loop(body) {
        While.call(this, new Bool(true).g(), body);
      }
      return Loop;
    }(While);
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
  });
  require.define('/lib/ember-runtime.js', function (module, exports, __dirname, __filename) {
    (function () {
      if ('undefined' === typeof Ember) {
        Ember = {};
        if ('undefined' !== typeof window) {
          window.Em = window.Ember = Em = Ember;
        }
      }
      Ember.ENV = 'undefined' === typeof ENV ? {} : ENV;
      if (!('MANDATORY_SETTER' in Ember.ENV)) {
        Ember.ENV.MANDATORY_SETTER = true;
      }
      Ember.assert = function (desc, test) {
        if (!test)
          throw new Error('assertion failed: ' + desc);
      };
      Ember.warn = function (message, test) {
        if (!test) {
          Ember.Logger.warn('WARNING: ' + message);
          if ('trace' in Ember.Logger)
            Ember.Logger.trace();
        }
      };
      Ember.debug = function (message) {
        Ember.Logger.debug('DEBUG: ' + message);
      };
      Ember.deprecate = function (message, test) {
        if (Ember && Ember.TESTING_DEPRECATION) {
          return;
        }
        if (arguments.length === 1) {
          test = false;
        }
        if (test) {
          return;
        }
        if (Ember && Ember.ENV.RAISE_ON_DEPRECATION) {
          throw new Error(message);
        }
        var error;
        try {
          __fail__.fail();
        } catch (e) {
          error = e;
        }
        if (Ember.LOG_STACKTRACE_ON_DEPRECATION && error.stack) {
          var stack, stackStr = '';
          if (error['arguments']) {
            stack = error.stack.replace(/^\s+at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm, '{anonymous}($1)$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}($1)').split('\n');
            stack.shift();
          } else {
            stack = error.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/gm, '{anonymous}(').split('\n');
          }
          stackStr = '\n    ' + stack.slice(2).join('\n    ');
          message = message + stackStr;
        }
        Ember.Logger.warn('DEPRECATION: ' + message);
      };
      Ember.deprecateFunc = function (message, func) {
        return function () {
          Ember.deprecate(message);
          return func.apply(this, arguments);
        };
      };
    }());
    (function () {
      var define, requireModule;
      (function () {
        var registry = {}, seen = {};
        define = function (name, deps, callback) {
          registry[name] = {
            deps: deps,
            callback: callback
          };
        };
        requireModule = function (name) {
          if (seen[name]) {
            return seen[name];
          }
          seen[name] = {};
          var mod = registry[name], deps = mod.deps, callback = mod.callback, reified = [], exports;
          for (var i = 0, l = deps.length; i < l; i++) {
            if (deps[i] === 'exports') {
              reified.push(exports = {});
            } else {
              reified.push(requireModule(deps[i]));
            }
          }
          var value = callback.apply(this, reified);
          return seen[name] = exports || value;
        };
      }());
      (function () {
        if ('undefined' === typeof Ember) {
          Ember = {};
        }
        var imports = Ember.imports = Ember.imports || this;
        var exports = Ember.exports = Ember.exports || this;
        var lookup = Ember.lookup = Ember.lookup || this;
        exports.Em = exports.Ember = Em = Ember;
        Ember.isNamespace = true;
        Ember.toString = function () {
          return 'Ember';
        };
        Ember.VERSION = '1.0.0-rc.2';
        Ember.ENV = Ember.ENV || ('undefined' === typeof ENV ? {} : ENV);
        Ember.config = Ember.config || {};
        Ember.EXTEND_PROTOTYPES = Ember.ENV.EXTEND_PROTOTYPES;
        if (typeof Ember.EXTEND_PROTOTYPES === 'undefined') {
          Ember.EXTEND_PROTOTYPES = true;
        }
        Ember.LOG_STACKTRACE_ON_DEPRECATION = Ember.ENV.LOG_STACKTRACE_ON_DEPRECATION !== false;
        Ember.SHIM_ES5 = Ember.ENV.SHIM_ES5 === false ? false : Ember.EXTEND_PROTOTYPES;
        Ember.LOG_VERSION = Ember.ENV.LOG_VERSION === false ? false : true;
        Ember.K = function () {
          return this;
        };
        if ('undefined' === typeof Ember.assert) {
          Ember.assert = Ember.K;
        }
        if ('undefined' === typeof Ember.warn) {
          Ember.warn = Ember.K;
        }
        if ('undefined' === typeof Ember.debug) {
          Ember.debug = Ember.K;
        }
        if ('undefined' === typeof Ember.deprecate) {
          Ember.deprecate = Ember.K;
        }
        if ('undefined' === typeof Ember.deprecateFunc) {
          Ember.deprecateFunc = function (_, func) {
            return func;
          };
        }
        Ember.uuid = 0;
        function consoleMethod(name) {
          if (imports.console && imports.console[name]) {
            if (imports.console[name].apply) {
              return function () {
                imports.console[name].apply(imports.console, arguments);
              };
            } else {
              return function () {
                var message = Array.prototype.join.call(arguments, ', ');
                imports.console[name](message);
              };
            }
          }
        }
        Ember.Logger = {
          log: consoleMethod('log') || Ember.K,
          warn: consoleMethod('warn') || Ember.K,
          error: consoleMethod('error') || Ember.K,
          info: consoleMethod('info') || Ember.K,
          debug: consoleMethod('debug') || consoleMethod('info') || Ember.K
        };
        Ember.onerror = null;
        Ember.handleErrors = function (func, context) {
          if ('function' === typeof Ember.onerror) {
            try {
              return func.call(context || this);
            } catch (error) {
              Ember.onerror(error);
            }
          } else {
            return func.call(context || this);
          }
        };
        Ember.merge = function (original, updates) {
          for (var prop in updates) {
            if (!updates.hasOwnProperty(prop)) {
              continue;
            }
            original[prop] = updates[prop];
          }
          return original;
        };
        Ember.isNone = function (obj) {
          return obj === null || obj === undefined;
        };
        Ember.none = Ember.deprecateFunc('Ember.none is deprecated. Please use Ember.isNone instead.', Ember.isNone);
        Ember.isEmpty = function (obj) {
          return obj === null || obj === undefined || obj.length === 0 && typeof obj !== 'function' || typeof obj === 'object' && Ember.get(obj, 'length') === 0;
        };
        Ember.empty = Ember.deprecateFunc('Ember.empty is deprecated. Please use Ember.isEmpty instead.', Ember.isEmpty);
      }());
      (function () {
        var platform = Ember.platform = {};
        Ember.create = Object.create;
        if (!Ember.create || Ember.ENV.STUB_OBJECT_CREATE) {
          var K = function () {
          };
          Ember.create = function (obj, props) {
            K.prototype = obj;
            obj = new K;
            if (props) {
              K.prototype = obj;
              for (var prop in props) {
                K.prototype[prop] = props[prop].value;
              }
              obj = new K;
            }
            K.prototype = null;
            return obj;
          };
          Ember.create.isSimulated = true;
        }
        var defineProperty = Object.defineProperty;
        var canRedefineProperties, canDefinePropertyOnDOM;
        if (defineProperty) {
          try {
            defineProperty({}, 'a', {
              get: function () {
              }
            });
          } catch (e) {
            defineProperty = null;
          }
        }
        if (defineProperty) {
          canRedefineProperties = function () {
            var obj = {};
            defineProperty(obj, 'a', {
              configurable: true,
              enumerable: true,
              get: function () {
              },
              set: function () {
              }
            });
            defineProperty(obj, 'a', {
              configurable: true,
              enumerable: true,
              writable: true,
              value: true
            });
            return obj.a === true;
          }();
          canDefinePropertyOnDOM = function () {
            try {
              defineProperty(document.createElement('div'), 'definePropertyOnDOM', {});
              return true;
            } catch (e) {
            }
            return false;
          }();
          if (!canRedefineProperties) {
            defineProperty = null;
          } else if (!canDefinePropertyOnDOM) {
            defineProperty = function (obj, keyName, desc) {
              var isNode;
              if (typeof Node === 'object') {
                isNode = obj instanceof Node;
              } else {
                isNode = typeof obj === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
              }
              if (isNode) {
                return obj[keyName] = desc.value;
              } else {
                return Object.defineProperty(obj, keyName, desc);
              }
            };
          }
        }
        platform.defineProperty = defineProperty;
        platform.hasPropertyAccessors = true;
        if (!platform.defineProperty) {
          platform.hasPropertyAccessors = false;
          platform.defineProperty = function (obj, keyName, desc) {
            if (!desc.get) {
              obj[keyName] = desc.value;
            }
          };
          platform.defineProperty.isSimulated = true;
        }
        if (Ember.ENV.MANDATORY_SETTER && !platform.hasPropertyAccessors) {
          Ember.ENV.MANDATORY_SETTER = false;
        }
      }());
      (function () {
        var o_defineProperty = Ember.platform.defineProperty, o_create = Ember.create, GUID_KEY = '__ember' + +new Date, uuid = 0, numberCache = [], stringCache = {};
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        Ember.GUID_KEY = GUID_KEY;
        var GUID_DESC = {
            writable: false,
            configurable: false,
            enumerable: false,
            value: null
          };
        Ember.generateGuid = function generateGuid(obj, prefix) {
          if (!prefix)
            prefix = 'ember';
          var ret = prefix + uuid++;
          if (obj) {
            GUID_DESC.value = ret;
            o_defineProperty(obj, GUID_KEY, GUID_DESC);
          }
          return ret;
        };
        Ember.guidFor = function guidFor(obj) {
          if (obj === undefined)
            return '(undefined)';
          if (obj === null)
            return '(null)';
          var cache, ret;
          var type = typeof obj;
          switch (type) {
          case 'number':
            ret = numberCache[obj];
            if (!ret)
              ret = numberCache[obj] = 'nu' + obj;
            return ret;
          case 'string':
            ret = stringCache[obj];
            if (!ret)
              ret = stringCache[obj] = 'st' + uuid++;
            return ret;
          case 'boolean':
            return obj ? '(true)' : '(false)';
          default:
            if (obj[GUID_KEY])
              return obj[GUID_KEY];
            if (obj === Object)
              return '(Object)';
            if (obj === Array)
              return '(Array)';
            ret = 'ember' + uuid++;
            GUID_DESC.value = ret;
            o_defineProperty(obj, GUID_KEY, GUID_DESC);
            return ret;
          }
        };
        var META_DESC = {
            writable: true,
            configurable: false,
            enumerable: false,
            value: null
          };
        var META_KEY = Ember.GUID_KEY + '_meta';
        Ember.META_KEY = META_KEY;
        var EMPTY_META = {
            descs: {},
            watching: {}
          };
        if (MANDATORY_SETTER) {
          EMPTY_META.values = {};
        }
        Ember.EMPTY_META = EMPTY_META;
        if (Object.freeze)
          Object.freeze(EMPTY_META);
        var isDefinePropertySimulated = Ember.platform.defineProperty.isSimulated;
        function Meta(obj) {
          this.descs = {};
          this.watching = {};
          this.cache = {};
          this.source = obj;
        }
        if (isDefinePropertySimulated) {
          Meta.prototype.__preventPlainObject__ = true;
          Meta.prototype.toJSON = function () {
          };
        }
        Ember.meta = function meta(obj, writable) {
          var ret = obj[META_KEY];
          if (writable === false)
            return ret || EMPTY_META;
          if (!ret) {
            if (!isDefinePropertySimulated)
              o_defineProperty(obj, META_KEY, META_DESC);
            ret = new Meta(obj);
            if (MANDATORY_SETTER) {
              ret.values = {};
            }
            obj[META_KEY] = ret;
            ret.descs.constructor = null;
          } else if (ret.source !== obj) {
            if (!isDefinePropertySimulated)
              o_defineProperty(obj, META_KEY, META_DESC);
            ret = o_create(ret);
            ret.descs = o_create(ret.descs);
            ret.watching = o_create(ret.watching);
            ret.cache = {};
            ret.source = obj;
            if (MANDATORY_SETTER) {
              ret.values = o_create(ret.values);
            }
            obj[META_KEY] = ret;
          }
          return ret;
        };
        Ember.getMeta = function getMeta(obj, property) {
          var meta = Ember.meta(obj, false);
          return meta[property];
        };
        Ember.setMeta = function setMeta(obj, property, value) {
          var meta = Ember.meta(obj, true);
          meta[property] = value;
          return value;
        };
        Ember.metaPath = function metaPath(obj, path, writable) {
          var meta = Ember.meta(obj, writable), keyName, value;
          for (var i = 0, l = path.length; i < l; i++) {
            keyName = path[i];
            value = meta[keyName];
            if (!value) {
              if (!writable) {
                return undefined;
              }
              value = meta[keyName] = { __ember_source__: obj };
            } else if (value.__ember_source__ !== obj) {
              if (!writable) {
                return undefined;
              }
              value = meta[keyName] = o_create(value);
              value.__ember_source__ = obj;
            }
            meta = value;
          }
          return value;
        };
        Ember.wrap = function (func, superFunc) {
          function K() {
          }
          function superWrapper() {
            var ret, sup = this._super;
            this._super = superFunc || K;
            ret = func.apply(this, arguments);
            this._super = sup;
            return ret;
          }
          superWrapper.wrappedFunction = func;
          superWrapper.__ember_observes__ = func.__ember_observes__;
          superWrapper.__ember_observesBefore__ = func.__ember_observesBefore__;
          return superWrapper;
        };
        Ember.isArray = function (obj) {
          if (!obj || obj.setInterval) {
            return false;
          }
          if (Array.isArray && Array.isArray(obj)) {
            return true;
          }
          if (Ember.Array && Ember.Array.detect(obj)) {
            return true;
          }
          if (obj.length !== undefined && 'object' === typeof obj) {
            return true;
          }
          return false;
        };
        Ember.makeArray = function (obj) {
          if (obj === null || obj === undefined) {
            return [];
          }
          return Ember.isArray(obj) ? obj : [obj];
        };
        function canInvoke(obj, methodName) {
          return !!(obj && typeof obj[methodName] === 'function');
        }
        Ember.canInvoke = canInvoke;
        Ember.tryInvoke = function (obj, methodName, args) {
          if (canInvoke(obj, methodName)) {
            return obj[methodName].apply(obj, args || []);
          }
        };
        var needsFinallyFix = function () {
            var count = 0;
            try {
              try {
              } finally {
                count++;
                throw new Error('needsFinallyFixTest');
              }
            } catch (e) {
            }
            return count !== 1;
          }();
        if (needsFinallyFix) {
          Ember.tryFinally = function (tryable, finalizer, binding) {
            var result, finalResult, finalError;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } finally {
              try {
                finalResult = finalizer.call(binding);
              } catch (e) {
                finalError = e;
              }
            }
            if (finalError) {
              throw finalError;
            }
            return finalResult === undefined ? result : finalResult;
          };
        } else {
          Ember.tryFinally = function (tryable, finalizer, binding) {
            var result, finalResult;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } finally {
              finalResult = finalizer.call(binding);
            }
            return finalResult === undefined ? result : finalResult;
          };
        }
        if (needsFinallyFix) {
          Ember.tryCatchFinally = function (tryable, catchable, finalizer, binding) {
            var result, finalResult, finalError, finalReturn;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } catch (error) {
              result = catchable.call(binding, error);
            } finally {
              try {
                finalResult = finalizer.call(binding);
              } catch (e) {
                finalError = e;
              }
            }
            if (finalError) {
              throw finalError;
            }
            return finalResult === undefined ? result : finalResult;
          };
        } else {
          Ember.tryCatchFinally = function (tryable, catchable, finalizer, binding) {
            var result, finalResult;
            binding = binding || this;
            try {
              result = tryable.call(binding);
            } catch (error) {
              result = catchable.call(binding, error);
            } finally {
              finalResult = finalizer.call(binding);
            }
            return finalResult === undefined ? result : finalResult;
          };
        }
      }());
      (function () {
        Ember.Instrumentation = {};
        var subscribers = [], cache = {};
        var populateListeners = function (name) {
          var listeners = [], subscriber;
          for (var i = 0, l = subscribers.length; i < l; i++) {
            subscriber = subscribers[i];
            if (subscriber.regex.test(name)) {
              listeners.push(subscriber.object);
            }
          }
          cache[name] = listeners;
          return listeners;
        };
        var time = function () {
            var perf = 'undefined' !== typeof window ? window.performance || {} : {};
            var fn = perf.now || perf.mozNow || perf.webkitNow || perf.msNow || perf.oNow;
            return fn ? fn.bind(perf) : function () {
              return +new Date;
            };
          }();
        Ember.Instrumentation.instrument = function (name, payload, callback, binding) {
          var listeners = cache[name], timeName, ret;
          if (Ember.STRUCTURED_PROFILE) {
            timeName = name + ': ' + payload.object;
            console.time(timeName);
          }
          if (!listeners) {
            listeners = populateListeners(name);
          }
          if (listeners.length === 0) {
            ret = callback.call(binding);
            if (Ember.STRUCTURED_PROFILE) {
              console.timeEnd(timeName);
            }
            return ret;
          }
          var beforeValues = [], listener, i, l;
          function tryable() {
            for (i = 0, l = listeners.length; i < l; i++) {
              listener = listeners[i];
              beforeValues[i] = listener.before(name, time(), payload);
            }
            return callback.call(binding);
          }
          function catchable(e) {
            payload = payload || {};
            payload.exception = e;
          }
          function finalizer() {
            for (i = 0, l = listeners.length; i < l; i++) {
              listener = listeners[i];
              listener.after(name, time(), payload, beforeValues[i]);
            }
            if (Ember.STRUCTURED_PROFILE) {
              console.timeEnd(timeName);
            }
          }
          return Ember.tryCatchFinally(tryable, catchable, finalizer);
        };
        Ember.Instrumentation.subscribe = function (pattern, object) {
          var paths = pattern.split('.'), path, regex = [];
          for (var i = 0, l = paths.length; i < l; i++) {
            path = paths[i];
            if (path === '*') {
              regex.push('[^\\.]*');
            } else {
              regex.push(path);
            }
          }
          regex = regex.join('\\.');
          regex = regex + '(\\..*)?';
          var subscriber = {
              pattern: pattern,
              regex: new RegExp('^' + regex + '$'),
              object: object
            };
          subscribers.push(subscriber);
          cache = {};
          return subscriber;
        };
        Ember.Instrumentation.unsubscribe = function (subscriber) {
          var index;
          for (var i = 0, l = subscribers.length; i < l; i++) {
            if (subscribers[i] === subscriber) {
              index = i;
            }
          }
          subscribers.splice(index, 1);
          cache = {};
        };
        Ember.Instrumentation.reset = function () {
          subscribers = [];
          cache = {};
        };
        Ember.instrument = Ember.Instrumentation.instrument;
        Ember.subscribe = Ember.Instrumentation.subscribe;
      }());
      (function () {
        var utils = Ember.EnumerableUtils = {
            map: function (obj, callback, thisArg) {
              return obj.map ? obj.map.call(obj, callback, thisArg) : Array.prototype.map.call(obj, callback, thisArg);
            },
            forEach: function (obj, callback, thisArg) {
              return obj.forEach ? obj.forEach.call(obj, callback, thisArg) : Array.prototype.forEach.call(obj, callback, thisArg);
            },
            indexOf: function (obj, element, index) {
              return obj.indexOf ? obj.indexOf.call(obj, element, index) : Array.prototype.indexOf.call(obj, element, index);
            },
            indexesOf: function (obj, elements) {
              return elements === undefined ? [] : utils.map(elements, function (item) {
                return utils.indexOf(obj, item);
              });
            },
            addObject: function (array, item) {
              var index = utils.indexOf(array, item);
              if (index === -1) {
                array.push(item);
              }
            },
            removeObject: function (array, item) {
              var index = utils.indexOf(array, item);
              if (index !== -1) {
                array.splice(index, 1);
              }
            },
            replace: function (array, idx, amt, objects) {
              if (array.replace) {
                return array.replace(idx, amt, objects);
              } else {
                var args = Array.prototype.concat.apply([
                    idx,
                    amt
                  ], objects);
                return array.splice.apply(array, args);
              }
            },
            intersection: function (array1, array2) {
              var intersection = [];
              array1.forEach(function (element) {
                if (array2.indexOf(element) >= 0) {
                  intersection.push(element);
                }
              });
              return intersection;
            }
          };
      }());
      (function () {
        var isNativeFunc = function (func) {
          return func && Function.prototype.toString.call(func).indexOf('[native code]') > -1;
        };
        var arrayMap = isNativeFunc(Array.prototype.map) ? Array.prototype.map : function (fun) {
            if (this === void 0 || this === null) {
              throw new TypeError;
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError;
            }
            var res = new Array(len);
            var thisp = arguments[1];
            for (var i = 0; i < len; i++) {
              if (i in t) {
                res[i] = fun.call(thisp, t[i], i, t);
              }
            }
            return res;
          };
        var arrayForEach = isNativeFunc(Array.prototype.forEach) ? Array.prototype.forEach : function (fun) {
            if (this === void 0 || this === null) {
              throw new TypeError;
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError;
            }
            var thisp = arguments[1];
            for (var i = 0; i < len; i++) {
              if (i in t) {
                fun.call(thisp, t[i], i, t);
              }
            }
          };
        var arrayIndexOf = isNativeFunc(Array.prototype.indexOf) ? Array.prototype.indexOf : function (obj, fromIndex) {
            if (fromIndex === null || fromIndex === undefined) {
              fromIndex = 0;
            } else if (fromIndex < 0) {
              fromIndex = Math.max(0, this.length + fromIndex);
            }
            for (var i = fromIndex, j = this.length; i < j; i++) {
              if (this[i] === obj) {
                return i;
              }
            }
            return -1;
          };
        Ember.ArrayPolyfills = {
          map: arrayMap,
          forEach: arrayForEach,
          indexOf: arrayIndexOf
        };
        if (Ember.SHIM_ES5) {
          if (!Array.prototype.map) {
            Array.prototype.map = arrayMap;
          }
          if (!Array.prototype.forEach) {
            Array.prototype.forEach = arrayForEach;
          }
          if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = arrayIndexOf;
          }
        }
      }());
      (function () {
        var guidFor = Ember.guidFor, indexOf = Ember.ArrayPolyfills.indexOf;
        var copy = function (obj) {
          var output = {};
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              output[prop] = obj[prop];
            }
          }
          return output;
        };
        var copyMap = function (original, newObject) {
          var keys = original.keys.copy(), values = copy(original.values);
          newObject.keys = keys;
          newObject.values = values;
          return newObject;
        };
        var OrderedSet = Ember.OrderedSet = function () {
            this.clear();
          };
        OrderedSet.create = function () {
          return new OrderedSet;
        };
        OrderedSet.prototype = {
          clear: function () {
            this.presenceSet = {};
            this.list = [];
          },
          add: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
            if (guid in presenceSet) {
              return;
            }
            presenceSet[guid] = true;
            list.push(obj);
          },
          remove: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet, list = this.list;
            delete presenceSet[guid];
            var index = indexOf.call(list, obj);
            if (index > -1) {
              list.splice(index, 1);
            }
          },
          isEmpty: function () {
            return this.list.length === 0;
          },
          has: function (obj) {
            var guid = guidFor(obj), presenceSet = this.presenceSet;
            return guid in presenceSet;
          },
          forEach: function (fn, self) {
            var list = this.list.slice();
            for (var i = 0, j = list.length; i < j; i++) {
              fn.call(self, list[i]);
            }
          },
          toArray: function () {
            return this.list.slice();
          },
          copy: function () {
            var set = new OrderedSet;
            set.presenceSet = copy(this.presenceSet);
            set.list = this.list.slice();
            return set;
          }
        };
        var Map = Ember.Map = function () {
            this.keys = Ember.OrderedSet.create();
            this.values = {};
          };
        Map.create = function () {
          return new Map;
        };
        Map.prototype = {
          get: function (key) {
            var values = this.values, guid = guidFor(key);
            return values[guid];
          },
          set: function (key, value) {
            var keys = this.keys, values = this.values, guid = guidFor(key);
            keys.add(key);
            values[guid] = value;
          },
          remove: function (key) {
            var keys = this.keys, values = this.values, guid = guidFor(key), value;
            if (values.hasOwnProperty(guid)) {
              keys.remove(key);
              value = values[guid];
              delete values[guid];
              return true;
            } else {
              return false;
            }
          },
          has: function (key) {
            var values = this.values, guid = guidFor(key);
            return values.hasOwnProperty(guid);
          },
          forEach: function (callback, self) {
            var keys = this.keys, values = this.values;
            keys.forEach(function (key) {
              var guid = guidFor(key);
              callback.call(self, key, values[guid]);
            });
          },
          copy: function () {
            return copyMap(this, new Map);
          }
        };
        var MapWithDefault = Ember.MapWithDefault = function (options) {
            Map.call(this);
            this.defaultValue = options.defaultValue;
          };
        MapWithDefault.create = function (options) {
          if (options) {
            return new MapWithDefault(options);
          } else {
            return new Map;
          }
        };
        MapWithDefault.prototype = Ember.create(Map.prototype);
        MapWithDefault.prototype.get = function (key) {
          var hasValue = this.has(key);
          if (hasValue) {
            return Map.prototype.get.call(this, key);
          } else {
            var defaultValue = this.defaultValue(key);
            this.set(key, defaultValue);
            return defaultValue;
          }
        };
        MapWithDefault.prototype.copy = function () {
          return copyMap(this, new MapWithDefault({ defaultValue: this.defaultValue }));
        };
      }());
      (function () {
        var META_KEY = Ember.META_KEY, get;
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        var IS_GLOBAL_PATH = /^([A-Z$]|([0-9][A-Z$])).*[\.\*]/;
        var HAS_THIS = /^this[\.\*]/;
        var FIRST_KEY = /^([^\.\*]+)/;
        get = function get(obj, keyName) {
          if (keyName === '') {
            return obj;
          }
          if (!keyName && 'string' === typeof obj) {
            keyName = obj;
            obj = null;
          }
          if (!obj || keyName.indexOf('.') !== -1) {
            Ember.assert("Cannot call get with '" + keyName + "' on an undefined object.", obj !== undefined);
            return getPath(obj, keyName);
          }
          Ember.assert('You need to provide an object and key to `get`.', !!obj && keyName);
          var meta = obj[META_KEY], desc = meta && meta.descs[keyName], ret;
          if (desc) {
            return desc.get(obj, keyName);
          } else {
            if (MANDATORY_SETTER && meta && meta.watching[keyName] > 0) {
              ret = meta.values[keyName];
            } else {
              ret = obj[keyName];
            }
            if (ret === undefined && 'object' === typeof obj && !(keyName in obj) && 'function' === typeof obj.unknownProperty) {
              return obj.unknownProperty(keyName);
            }
            return ret;
          }
        };
        if (Ember.config.overrideAccessors) {
          Ember.get = get;
          Ember.config.overrideAccessors();
          get = Ember.get;
        }
        function firstKey(path) {
          return path.match(FIRST_KEY)[0];
        }
        function normalizeTuple(target, path) {
          var hasThis = HAS_THIS.test(path), isGlobal = !hasThis && IS_GLOBAL_PATH.test(path), key;
          if (!target || isGlobal)
            target = Ember.lookup;
          if (hasThis)
            path = path.slice(5);
          if (target === Ember.lookup) {
            key = firstKey(path);
            target = get(target, key);
            path = path.slice(key.length + 1);
          }
          if (!path || path.length === 0)
            throw new Error('Invalid Path');
          return [
            target,
            path
          ];
        }
        var getPath = Ember._getPath = function (root, path) {
            var hasThis, parts, tuple, idx, len;
            if (root === null && path.indexOf('.') === -1) {
              return get(Ember.lookup, path);
            }
            hasThis = HAS_THIS.test(path);
            if (!root || hasThis) {
              tuple = normalizeTuple(root, path);
              root = tuple[0];
              path = tuple[1];
              tuple.length = 0;
            }
            parts = path.split('.');
            len = parts.length;
            for (idx = 0; root && idx < len; idx++) {
              root = get(root, parts[idx], true);
              if (root && root.isDestroyed) {
                return undefined;
              }
            }
            return root;
          };
        Ember.normalizeTuple = function (target, path) {
          return normalizeTuple(target, path);
        };
        Ember.getWithDefault = function (root, key, defaultValue) {
          var value = get(root, key);
          if (value === undefined) {
            return defaultValue;
          }
          return value;
        };
        Ember.get = get;
        Ember.getPath = Ember.deprecateFunc('getPath is deprecated since get now supports paths', Ember.get);
      }());
      (function () {
        var o_create = Ember.create, metaFor = Ember.meta, META_KEY = Ember.META_KEY;
        function indexOf(array, target, method) {
          var index = -1;
          for (var i = 0, l = array.length; i < l; i++) {
            if (target === array[i][0] && method === array[i][1]) {
              index = i;
              break;
            }
          }
          return index;
        }
        function actionsFor(obj, eventName) {
          var meta = metaFor(obj, true), actions;
          if (!meta.listeners) {
            meta.listeners = {};
          }
          if (!meta.hasOwnProperty('listeners')) {
            meta.listeners = o_create(meta.listeners);
          }
          actions = meta.listeners[eventName];
          if (actions && !meta.listeners.hasOwnProperty(eventName)) {
            actions = meta.listeners[eventName] = meta.listeners[eventName].slice();
          } else if (!actions) {
            actions = meta.listeners[eventName] = [];
          }
          return actions;
        }
        function actionsUnion(obj, eventName, otherActions) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            var target = actions[i][0], method = actions[i][1], once = actions[i][2], suspended = actions[i][3], actionIndex = indexOf(otherActions, target, method);
            if (actionIndex === -1) {
              otherActions.push([
                target,
                method,
                once,
                suspended
              ]);
            }
          }
        }
        function actionsDiff(obj, eventName, otherActions) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName], diffActions = [];
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            var target = actions[i][0], method = actions[i][1], once = actions[i][2], suspended = actions[i][3], actionIndex = indexOf(otherActions, target, method);
            if (actionIndex !== -1) {
              continue;
            }
            otherActions.push([
              target,
              method,
              once,
              suspended
            ]);
            diffActions.push([
              target,
              method,
              once,
              suspended
            ]);
          }
          return diffActions;
        }
        function addListener(obj, eventName, target, method, once) {
          Ember.assert('You must pass at least an object and event name to Ember.addListener', !!obj && !!eventName);
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
          if (actionIndex !== -1) {
            return;
          }
          actions.push([
            target,
            method,
            once,
            undefined
          ]);
          if ('function' === typeof obj.didAddListener) {
            obj.didAddListener(eventName, target, method);
          }
        }
        function removeListener(obj, eventName, target, method) {
          Ember.assert('You must pass at least an object and event name to Ember.removeListener', !!obj && !!eventName);
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          function _removeListener(target, method, once) {
            var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method);
            if (actionIndex === -1) {
              return;
            }
            actions.splice(actionIndex, 1);
            if ('function' === typeof obj.didRemoveListener) {
              obj.didRemoveListener(eventName, target, method);
            }
          }
          if (method) {
            _removeListener(target, method);
          } else {
            var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
            if (!actions) {
              return;
            }
            for (var i = actions.length - 1; i >= 0; i--) {
              _removeListener(actions[i][0], actions[i][1]);
            }
          }
        }
        function suspendListener(obj, eventName, target, method, callback) {
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var actions = actionsFor(obj, eventName), actionIndex = indexOf(actions, target, method), action;
          if (actionIndex !== -1) {
            action = actions[actionIndex].slice();
            action[3] = true;
            actions[actionIndex] = action;
          }
          function tryable() {
            return callback.call(target);
          }
          function finalizer() {
            if (action) {
              action[3] = undefined;
            }
          }
          return Ember.tryFinally(tryable, finalizer);
        }
        function suspendListeners(obj, eventNames, target, method, callback) {
          if (!method && 'function' === typeof target) {
            method = target;
            target = null;
          }
          var suspendedActions = [], eventName, actions, action, i, l;
          for (i = 0, l = eventNames.length; i < l; i++) {
            eventName = eventNames[i];
            actions = actionsFor(obj, eventName);
            var actionIndex = indexOf(actions, target, method);
            if (actionIndex !== -1) {
              action = actions[actionIndex].slice();
              action[3] = true;
              actions[actionIndex] = action;
              suspendedActions.push(action);
            }
          }
          function tryable() {
            return callback.call(target);
          }
          function finalizer() {
            for (i = 0, l = suspendedActions.length; i < l; i++) {
              suspendedActions[i][3] = undefined;
            }
          }
          return Ember.tryFinally(tryable, finalizer);
        }
        function watchedEvents(obj) {
          var listeners = obj[META_KEY].listeners, ret = [];
          if (listeners) {
            for (var eventName in listeners) {
              if (listeners[eventName]) {
                ret.push(eventName);
              }
            }
          }
          return ret;
        }
        function sendEvent(obj, eventName, params, actions) {
          if (obj !== Ember && 'function' === typeof obj.sendEvent) {
            obj.sendEvent(eventName, params);
          }
          if (!actions) {
            var meta = obj[META_KEY];
            actions = meta && meta.listeners && meta.listeners[eventName];
          }
          if (!actions) {
            return;
          }
          for (var i = actions.length - 1; i >= 0; i--) {
            if (!actions[i] || actions[i][3] === true) {
              continue;
            }
            var target = actions[i][0], method = actions[i][1], once = actions[i][2];
            if (once) {
              removeListener(obj, eventName, target, method);
            }
            if (!target) {
              target = obj;
            }
            if ('string' === typeof method) {
              method = target[method];
            }
            if (params) {
              method.apply(target, params);
            } else {
              method.call(target);
            }
          }
          return true;
        }
        function hasListeners(obj, eventName) {
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          return !!(actions && actions.length);
        }
        function listenersFor(obj, eventName) {
          var ret = [];
          var meta = obj[META_KEY], actions = meta && meta.listeners && meta.listeners[eventName];
          if (!actions) {
            return ret;
          }
          for (var i = 0, l = actions.length; i < l; i++) {
            var target = actions[i][0], method = actions[i][1];
            ret.push([
              target,
              method
            ]);
          }
          return ret;
        }
        Ember.addListener = addListener;
        Ember.removeListener = removeListener;
        Ember._suspendListener = suspendListener;
        Ember._suspendListeners = suspendListeners;
        Ember.sendEvent = sendEvent;
        Ember.hasListeners = hasListeners;
        Ember.watchedEvents = watchedEvents;
        Ember.listenersFor = listenersFor;
        Ember.listenersDiff = actionsDiff;
        Ember.listenersUnion = actionsUnion;
      }());
      (function () {
        var guidFor = Ember.guidFor, sendEvent = Ember.sendEvent;
        var ObserverSet = Ember._ObserverSet = function () {
            this.clear();
          };
        ObserverSet.prototype.add = function (sender, keyName, eventName) {
          var observerSet = this.observerSet, observers = this.observers, senderGuid = guidFor(sender), keySet = observerSet[senderGuid], index;
          if (!keySet) {
            observerSet[senderGuid] = keySet = {};
          }
          index = keySet[keyName];
          if (index === undefined) {
            index = observers.push({
              sender: sender,
              keyName: keyName,
              eventName: eventName,
              listeners: []
            }) - 1;
            keySet[keyName] = index;
          }
          return observers[index].listeners;
        };
        ObserverSet.prototype.flush = function () {
          var observers = this.observers, i, len, observer, sender;
          this.clear();
          for (i = 0, len = observers.length; i < len; ++i) {
            observer = observers[i];
            sender = observer.sender;
            if (sender.isDestroying || sender.isDestroyed) {
              continue;
            }
            sendEvent(sender, observer.eventName, [
              sender,
              observer.keyName
            ], observer.listeners);
          }
        };
        ObserverSet.prototype.clear = function () {
          this.observerSet = {};
          this.observers = [];
        };
      }());
      (function () {
        var metaFor = Ember.meta, guidFor = Ember.guidFor, tryFinally = Ember.tryFinally, sendEvent = Ember.sendEvent, listenersUnion = Ember.listenersUnion, listenersDiff = Ember.listenersDiff, ObserverSet = Ember._ObserverSet, beforeObserverSet = new ObserverSet, observerSet = new ObserverSet, deferred = 0;
        var propertyWillChange = Ember.propertyWillChange = function (obj, keyName) {
            var m = metaFor(obj, false), watching = m.watching[keyName] > 0 || keyName === 'length', proto = m.proto, desc = m.descs[keyName];
            if (!watching) {
              return;
            }
            if (proto === obj) {
              return;
            }
            if (desc && desc.willChange) {
              desc.willChange(obj, keyName);
            }
            dependentKeysWillChange(obj, keyName, m);
            chainsWillChange(obj, keyName, m);
            notifyBeforeObservers(obj, keyName);
          };
        var propertyDidChange = Ember.propertyDidChange = function (obj, keyName) {
            var m = metaFor(obj, false), watching = m.watching[keyName] > 0 || keyName === 'length', proto = m.proto, desc = m.descs[keyName];
            if (proto === obj) {
              return;
            }
            if (desc && desc.didChange) {
              desc.didChange(obj, keyName);
            }
            if (!watching && keyName !== 'length') {
              return;
            }
            dependentKeysDidChange(obj, keyName, m);
            chainsDidChange(obj, keyName, m);
            notifyObservers(obj, keyName);
          };
        var WILL_SEEN, DID_SEEN;
        function dependentKeysWillChange(obj, depKey, meta) {
          if (obj.isDestroying) {
            return;
          }
          var seen = WILL_SEEN, top = !seen;
          if (top) {
            seen = WILL_SEEN = {};
          }
          iterDeps(propertyWillChange, obj, depKey, seen, meta);
          if (top) {
            WILL_SEEN = null;
          }
        }
        function dependentKeysDidChange(obj, depKey, meta) {
          if (obj.isDestroying) {
            return;
          }
          var seen = DID_SEEN, top = !seen;
          if (top) {
            seen = DID_SEEN = {};
          }
          iterDeps(propertyDidChange, obj, depKey, seen, meta);
          if (top) {
            DID_SEEN = null;
          }
        }
        function iterDeps(method, obj, depKey, seen, meta) {
          var guid = guidFor(obj);
          if (!seen[guid])
            seen[guid] = {};
          if (seen[guid][depKey])
            return;
          seen[guid][depKey] = true;
          var deps = meta.deps;
          deps = deps && deps[depKey];
          if (deps) {
            for (var key in deps) {
              var desc = meta.descs[key];
              if (desc && desc._suspended === obj)
                continue;
              method(obj, key);
            }
          }
        }
        var chainsWillChange = function (obj, keyName, m, arg) {
          if (!m.hasOwnProperty('chainWatchers')) {
            return;
          }
          var nodes = m.chainWatchers;
          nodes = nodes[keyName];
          if (!nodes) {
            return;
          }
          for (var i = 0, l = nodes.length; i < l; i++) {
            nodes[i].willChange(arg);
          }
        };
        var chainsDidChange = function (obj, keyName, m, arg) {
          if (!m.hasOwnProperty('chainWatchers')) {
            return;
          }
          var nodes = m.chainWatchers;
          nodes = nodes[keyName];
          if (!nodes) {
            return;
          }
          for (var i = nodes.length - 1; i >= 0; i--) {
            nodes[i].didChange(arg);
          }
        };
        Ember.overrideChains = function (obj, keyName, m) {
          chainsDidChange(obj, keyName, m, true);
        };
        var beginPropertyChanges = Ember.beginPropertyChanges = function () {
            deferred++;
          };
        var endPropertyChanges = Ember.endPropertyChanges = function () {
            deferred--;
            if (deferred <= 0) {
              beforeObserverSet.clear();
              observerSet.flush();
            }
          };
        var changeProperties = Ember.changeProperties = function (cb, binding) {
            beginPropertyChanges();
            tryFinally(cb, endPropertyChanges, binding);
          };
        var notifyBeforeObservers = function (obj, keyName) {
          if (obj.isDestroying) {
            return;
          }
          var eventName = keyName + ':before', listeners, diff;
          if (deferred) {
            listeners = beforeObserverSet.add(obj, keyName, eventName);
            diff = listenersDiff(obj, eventName, listeners);
            sendEvent(obj, eventName, [
              obj,
              keyName
            ], diff);
          } else {
            sendEvent(obj, eventName, [
              obj,
              keyName
            ]);
          }
        };
        var notifyObservers = function (obj, keyName) {
          if (obj.isDestroying) {
            return;
          }
          var eventName = keyName + ':change', listeners;
          if (deferred) {
            listeners = observerSet.add(obj, keyName, eventName);
            listenersUnion(obj, eventName, listeners);
          } else {
            sendEvent(obj, eventName, [
              obj,
              keyName
            ]);
          }
        };
      }());
      (function () {
        var META_KEY = Ember.META_KEY, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, getPath = Ember._getPath;
        var set = function set(obj, keyName, value, tolerant) {
          if (typeof obj === 'string') {
            Ember.assert("Path '" + obj + "' must be global if no obj is given.", IS_GLOBAL.test(obj));
            value = keyName;
            keyName = obj;
            obj = null;
          }
          if (!obj || keyName.indexOf('.') !== -1) {
            return setPath(obj, keyName, value, tolerant);
          }
          Ember.assert('You need to provide an object and key to `set`.', !!obj && keyName !== undefined);
          Ember.assert('calling set on destroyed object', !obj.isDestroyed);
          var meta = obj[META_KEY], desc = meta && meta.descs[keyName], isUnknown, currentValue;
          if (desc) {
            desc.set(obj, keyName, value);
          } else {
            isUnknown = 'object' === typeof obj && !(keyName in obj);
            if (isUnknown && 'function' === typeof obj.setUnknownProperty) {
              obj.setUnknownProperty(keyName, value);
            } else if (meta && meta.watching[keyName] > 0) {
              if (MANDATORY_SETTER) {
                currentValue = meta.values[keyName];
              } else {
                currentValue = obj[keyName];
              }
              if (value !== currentValue) {
                Ember.propertyWillChange(obj, keyName);
                if (MANDATORY_SETTER) {
                  if (currentValue === undefined && !(keyName in obj)) {
                    Ember.defineProperty(obj, keyName, null, value);
                  } else {
                    meta.values[keyName] = value;
                  }
                } else {
                  obj[keyName] = value;
                }
                Ember.propertyDidChange(obj, keyName);
              }
            } else {
              obj[keyName] = value;
            }
          }
          return value;
        };
        if (Ember.config.overrideAccessors) {
          Ember.set = set;
          Ember.config.overrideAccessors();
          set = Ember.set;
        }
        function setPath(root, path, value, tolerant) {
          var keyName;
          keyName = path.slice(path.lastIndexOf('.') + 1);
          path = path.slice(0, path.length - (keyName.length + 1));
          if (path !== 'this') {
            root = getPath(root, path);
          }
          if (!keyName || keyName.length === 0) {
            throw new Error('You passed an empty path');
          }
          if (!root) {
            if (tolerant) {
              return;
            } else {
              throw new Error('Object in path ' + path + ' could not be found or was destroyed.');
            }
          }
          return set(root, keyName, value);
        }
        Ember.set = set;
        Ember.setPath = Ember.deprecateFunc('setPath is deprecated since set now supports paths', Ember.set);
        Ember.trySet = function (root, path, value) {
          return set(root, path, value, true);
        };
        Ember.trySetPath = Ember.deprecateFunc('trySetPath has been renamed to trySet', Ember.trySet);
      }());
      (function () {
        var META_KEY = Ember.META_KEY, metaFor = Ember.meta, objectDefineProperty = Ember.platform.defineProperty;
        var MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER;
        var Descriptor = Ember.Descriptor = function () {
          };
        var MANDATORY_SETTER_FUNCTION = Ember.MANDATORY_SETTER_FUNCTION = function (value) {
            Ember.assert('You must use Ember.set() to access this property (of ' + this + ')', false);
          };
        var DEFAULT_GETTER_FUNCTION = Ember.DEFAULT_GETTER_FUNCTION = function (name) {
            return function () {
              var meta = this[META_KEY];
              return meta && meta.values[name];
            };
          };
        Ember.defineProperty = function (obj, keyName, desc, data, meta) {
          var descs, existingDesc, watching, value;
          if (!meta)
            meta = metaFor(obj);
          descs = meta.descs;
          existingDesc = meta.descs[keyName];
          watching = meta.watching[keyName] > 0;
          if (existingDesc instanceof Ember.Descriptor) {
            existingDesc.teardown(obj, keyName);
          }
          if (desc instanceof Ember.Descriptor) {
            value = desc;
            descs[keyName] = desc;
            if (MANDATORY_SETTER && watching) {
              objectDefineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: undefined
              });
            } else {
              obj[keyName] = undefined;
            }
            desc.setup(obj, keyName);
          } else {
            descs[keyName] = undefined;
            if (desc == null) {
              value = data;
              if (MANDATORY_SETTER && watching) {
                meta.values[keyName] = data;
                objectDefineProperty(obj, keyName, {
                  configurable: true,
                  enumerable: true,
                  set: MANDATORY_SETTER_FUNCTION,
                  get: DEFAULT_GETTER_FUNCTION(keyName)
                });
              } else {
                obj[keyName] = data;
              }
            } else {
              value = desc;
              objectDefineProperty(obj, keyName, desc);
            }
          }
          if (watching) {
            Ember.overrideChains(obj, keyName, meta);
          }
          if (obj.didDefineProperty) {
            obj.didDefineProperty(obj, keyName, value);
          }
          return this;
        };
      }());
      (function () {
        var changeProperties = Ember.changeProperties, set = Ember.set;
        Ember.setProperties = function (self, hash) {
          changeProperties(function () {
            for (var prop in hash) {
              if (hash.hasOwnProperty(prop)) {
                set(self, prop, hash[prop]);
              }
            }
          });
          return self;
        };
      }());
      (function () {
        var metaFor = Ember.meta, isArray = Ember.isArray, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, o_defineProperty = Ember.platform.defineProperty;
        Ember.watchKey = function (obj, keyName) {
          if (keyName === 'length' && isArray(obj)) {
            return this;
          }
          var m = metaFor(obj), watching = m.watching, desc;
          if (!watching[keyName]) {
            watching[keyName] = 1;
            desc = m.descs[keyName];
            if (desc && desc.willWatch) {
              desc.willWatch(obj, keyName);
            }
            if ('function' === typeof obj.willWatchProperty) {
              obj.willWatchProperty(keyName);
            }
            if (MANDATORY_SETTER && keyName in obj) {
              m.values[keyName] = obj[keyName];
              o_defineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                set: Ember.MANDATORY_SETTER_FUNCTION,
                get: Ember.DEFAULT_GETTER_FUNCTION(keyName)
              });
            }
          } else {
            watching[keyName] = (watching[keyName] || 0) + 1;
          }
        };
        Ember.unwatchKey = function (obj, keyName) {
          var m = metaFor(obj), watching = m.watching, desc;
          if (watching[keyName] === 1) {
            watching[keyName] = 0;
            desc = m.descs[keyName];
            if (desc && desc.didUnwatch) {
              desc.didUnwatch(obj, keyName);
            }
            if ('function' === typeof obj.didUnwatchProperty) {
              obj.didUnwatchProperty(keyName);
            }
            if (MANDATORY_SETTER && keyName in obj) {
              o_defineProperty(obj, keyName, {
                configurable: true,
                enumerable: true,
                writable: true,
                value: m.values[keyName]
              });
              delete m.values[keyName];
            }
          } else if (watching[keyName] > 1) {
            watching[keyName]--;
          }
          return this;
        };
      }());
      (function () {
        var metaFor = Ember.meta, get = Ember.get, normalizeTuple = Ember.normalizeTuple, forEach = Ember.ArrayPolyfills.forEach, warn = Ember.warn, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange, FIRST_KEY = /^([^\.\*]+)/;
        function firstKey(path) {
          return path.match(FIRST_KEY)[0];
        }
        var pendingQueue = [];
        Ember.flushPendingChains = function () {
          if (pendingQueue.length === 0) {
            return;
          }
          var queue = pendingQueue;
          pendingQueue = [];
          forEach.call(queue, function (q) {
            q[0].add(q[1]);
          });
          warn('Watching an undefined global, Ember expects watched globals to be setup by the time the run loop is flushed, check for typos', pendingQueue.length === 0);
        };
        function addChainWatcher(obj, keyName, node) {
          if (!obj || 'object' !== typeof obj) {
            return;
          }
          var m = metaFor(obj), nodes = m.chainWatchers;
          if (!m.hasOwnProperty('chainWatchers')) {
            nodes = m.chainWatchers = {};
          }
          if (!nodes[keyName]) {
            nodes[keyName] = [];
          }
          nodes[keyName].push(node);
          watchKey(obj, keyName);
        }
        var removeChainWatcher = Ember.removeChainWatcher = function (obj, keyName, node) {
            if (!obj || 'object' !== typeof obj) {
              return;
            }
            var m = metaFor(obj, false);
            if (!m.hasOwnProperty('chainWatchers')) {
              return;
            }
            var nodes = m.chainWatchers;
            if (nodes[keyName]) {
              nodes = nodes[keyName];
              for (var i = 0, l = nodes.length; i < l; i++) {
                if (nodes[i] === node) {
                  nodes.splice(i, 1);
                }
              }
            }
            unwatchKey(obj, keyName);
          };
        function isProto(pvalue) {
          return metaFor(pvalue, false).proto === pvalue;
        }
        var ChainNode = Ember._ChainNode = function (parent, key, value) {
            var obj;
            this._parent = parent;
            this._key = key;
            this._watching = value === undefined;
            this._value = value;
            this._paths = {};
            if (this._watching) {
              this._object = parent.value();
              if (this._object) {
                addChainWatcher(this._object, this._key, this);
              }
            }
            if (this._parent && this._parent._key === '@each') {
              this.value();
            }
          };
        var ChainNodePrototype = ChainNode.prototype;
        ChainNodePrototype.value = function () {
          if (this._value === undefined && this._watching) {
            var obj = this._parent.value();
            this._value = obj && !isProto(obj) ? get(obj, this._key) : undefined;
          }
          return this._value;
        };
        ChainNodePrototype.destroy = function () {
          if (this._watching) {
            var obj = this._object;
            if (obj) {
              removeChainWatcher(obj, this._key, this);
            }
            this._watching = false;
          }
        };
        ChainNodePrototype.copy = function (obj) {
          var ret = new ChainNode(null, null, obj), paths = this._paths, path;
          for (path in paths) {
            if (paths[path] <= 0) {
              continue;
            }
            ret.add(path);
          }
          return ret;
        };
        ChainNodePrototype.add = function (path) {
          var obj, tuple, key, src, paths;
          paths = this._paths;
          paths[path] = (paths[path] || 0) + 1;
          obj = this.value();
          tuple = normalizeTuple(obj, path);
          if (tuple[0] && tuple[0] === obj) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);
          } else if (!tuple[0]) {
            pendingQueue.push([
              this,
              path
            ]);
            tuple.length = 0;
            return;
          } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            path = tuple[1];
          }
          tuple.length = 0;
          this.chain(key, path, src);
        };
        ChainNodePrototype.remove = function (path) {
          var obj, tuple, key, src, paths;
          paths = this._paths;
          if (paths[path] > 0) {
            paths[path]--;
          }
          obj = this.value();
          tuple = normalizeTuple(obj, path);
          if (tuple[0] === obj) {
            path = tuple[1];
            key = firstKey(path);
            path = path.slice(key.length + 1);
          } else {
            src = tuple[0];
            key = path.slice(0, 0 - (tuple[1].length + 1));
            path = tuple[1];
          }
          tuple.length = 0;
          this.unchain(key, path);
        };
        ChainNodePrototype.count = 0;
        ChainNodePrototype.chain = function (key, path, src) {
          var chains = this._chains, node;
          if (!chains) {
            chains = this._chains = {};
          }
          node = chains[key];
          if (!node) {
            node = chains[key] = new ChainNode(this, key, src);
          }
          node.count++;
          if (path && path.length > 0) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.chain(key, path);
          }
        };
        ChainNodePrototype.unchain = function (key, path) {
          var chains = this._chains, node = chains[key];
          if (path && path.length > 1) {
            key = firstKey(path);
            path = path.slice(key.length + 1);
            node.unchain(key, path);
          }
          node.count--;
          if (node.count <= 0) {
            delete chains[node._key];
            node.destroy();
          }
        };
        ChainNodePrototype.willChange = function () {
          var chains = this._chains;
          if (chains) {
            for (var key in chains) {
              if (!chains.hasOwnProperty(key)) {
                continue;
              }
              chains[key].willChange();
            }
          }
          if (this._parent) {
            this._parent.chainWillChange(this, this._key, 1);
          }
        };
        ChainNodePrototype.chainWillChange = function (chain, path, depth) {
          if (this._key) {
            path = this._key + '.' + path;
          }
          if (this._parent) {
            this._parent.chainWillChange(this, path, depth + 1);
          } else {
            if (depth > 1) {
              propertyWillChange(this.value(), path);
            }
            path = 'this.' + path;
            if (this._paths[path] > 0) {
              propertyWillChange(this.value(), path);
            }
          }
        };
        ChainNodePrototype.chainDidChange = function (chain, path, depth) {
          if (this._key) {
            path = this._key + '.' + path;
          }
          if (this._parent) {
            this._parent.chainDidChange(this, path, depth + 1);
          } else {
            if (depth > 1) {
              propertyDidChange(this.value(), path);
            }
            path = 'this.' + path;
            if (this._paths[path] > 0) {
              propertyDidChange(this.value(), path);
            }
          }
        };
        ChainNodePrototype.didChange = function (suppressEvent) {
          if (this._watching) {
            var obj = this._parent.value();
            if (obj !== this._object) {
              removeChainWatcher(this._object, this._key, this);
              this._object = obj;
              addChainWatcher(obj, this._key, this);
            }
            this._value = undefined;
            if (this._parent && this._parent._key === '@each')
              this.value();
          }
          var chains = this._chains;
          if (chains) {
            for (var key in chains) {
              if (!chains.hasOwnProperty(key)) {
                continue;
              }
              chains[key].didChange(suppressEvent);
            }
          }
          if (suppressEvent) {
            return;
          }
          if (this._parent) {
            this._parent.chainDidChange(this, this._key, 1);
          }
        };
        Ember.finishChains = function (obj) {
          var m = metaFor(obj, false), chains = m.chains;
          if (chains) {
            if (chains.value() !== obj) {
              m.chains = chains = chains.copy(obj);
            }
            chains.didChange(true);
          }
        };
      }());
      (function () {
        var metaFor = Ember.meta, isArray = Ember.isArray, ChainNode = Ember._ChainNode;
        function chainsFor(obj) {
          var m = metaFor(obj), ret = m.chains;
          if (!ret) {
            ret = m.chains = new ChainNode(null, null, obj);
          } else if (ret.value() !== obj) {
            ret = m.chains = ret.copy(obj);
          }
          return ret;
        }
        Ember.watchPath = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return;
          }
          var m = metaFor(obj), watching = m.watching;
          if (!watching[keyPath]) {
            watching[keyPath] = 1;
            chainsFor(obj).add(keyPath);
          } else {
            watching[keyPath] = (watching[keyPath] || 0) + 1;
          }
        };
        Ember.unwatchPath = function (obj, keyPath) {
          var m = metaFor(obj), watching = m.watching, desc;
          if (watching[keyPath] === 1) {
            watching[keyPath] = 0;
            chainsFor(obj).remove(keyPath);
          } else if (watching[keyPath] > 1) {
            watching[keyPath]--;
          }
          return this;
        };
      }());
      (function () {
        var metaFor = Ember.meta, GUID_KEY = Ember.GUID_KEY, META_KEY = Ember.META_KEY, removeChainWatcher = Ember.removeChainWatcher, watchKey = Ember.watchKey, unwatchKey = Ember.unwatchKey, watchPath = Ember.watchPath, unwatchPath = Ember.unwatchPath, isArray = Ember.isArray, generateGuid = Ember.generateGuid, IS_PATH = /[\.\*]/;
        function isKeyName(path) {
          return path === '*' || !IS_PATH.test(path);
        }
        Ember.watch = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return;
          }
          if (isKeyName(keyPath)) {
            watchKey(obj, keyPath);
          } else {
            watchPath(obj, keyPath);
          }
        };
        Ember.isWatching = function isWatching(obj, key) {
          var meta = obj[META_KEY];
          return (meta && meta.watching[key]) > 0;
        };
        Ember.watch.flushPending = Ember.flushPendingChains;
        Ember.unwatch = function (obj, keyPath) {
          if (keyPath === 'length' && isArray(obj)) {
            return this;
          }
          if (isKeyName(keyPath)) {
            unwatchKey(obj, keyPath);
          } else {
            unwatchPath(obj, keyPath);
          }
        };
        Ember.rewatch = function (obj) {
          var m = metaFor(obj, false), chains = m.chains;
          if (GUID_KEY in obj && !obj.hasOwnProperty(GUID_KEY)) {
            generateGuid(obj, 'ember');
          }
          if (chains && chains.value() !== obj) {
            m.chains = chains.copy(obj);
          }
          return this;
        };
        var NODE_STACK = [];
        Ember.destroy = function (obj) {
          var meta = obj[META_KEY], node, nodes, key, nodeObject;
          if (meta) {
            obj[META_KEY] = null;
            node = meta.chains;
            if (node) {
              NODE_STACK.push(node);
              while (NODE_STACK.length > 0) {
                node = NODE_STACK.pop();
                nodes = node._chains;
                if (nodes) {
                  for (key in nodes) {
                    if (nodes.hasOwnProperty(key)) {
                      NODE_STACK.push(nodes[key]);
                    }
                  }
                }
                if (node._watching) {
                  nodeObject = node._object;
                  if (nodeObject) {
                    removeChainWatcher(nodeObject, node._key, node);
                  }
                }
              }
            }
          }
        };
      }());
      (function () {
        Ember.warn("The CP_DEFAULT_CACHEABLE flag has been removed and computed properties are always cached by default. Use `volatile` if you don't want caching.", Ember.ENV.CP_DEFAULT_CACHEABLE !== false);
        var get = Ember.get, set = Ember.set, metaFor = Ember.meta, a_slice = [].slice, o_create = Ember.create, META_KEY = Ember.META_KEY, watch = Ember.watch, unwatch = Ember.unwatch;
        function keysForDep(obj, depsMeta, depKey) {
          var keys = depsMeta[depKey];
          if (!keys) {
            keys = depsMeta[depKey] = {};
          } else if (!depsMeta.hasOwnProperty(depKey)) {
            keys = depsMeta[depKey] = o_create(keys);
          }
          return keys;
        }
        function metaForDeps(obj, meta) {
          return keysForDep(obj, meta, 'deps');
        }
        function addDependentKeys(desc, obj, keyName, meta) {
          var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
          if (!depKeys)
            return;
          depsMeta = metaForDeps(obj, meta);
          for (idx = 0, len = depKeys.length; idx < len; idx++) {
            depKey = depKeys[idx];
            keys = keysForDep(obj, depsMeta, depKey);
            keys[keyName] = (keys[keyName] || 0) + 1;
            watch(obj, depKey);
          }
        }
        function removeDependentKeys(desc, obj, keyName, meta) {
          var depKeys = desc._dependentKeys, depsMeta, idx, len, depKey, keys;
          if (!depKeys)
            return;
          depsMeta = metaForDeps(obj, meta);
          for (idx = 0, len = depKeys.length; idx < len; idx++) {
            depKey = depKeys[idx];
            keys = keysForDep(obj, depsMeta, depKey);
            keys[keyName] = (keys[keyName] || 0) - 1;
            unwatch(obj, depKey);
          }
        }
        function ComputedProperty(func, opts) {
          this.func = func;
          this._cacheable = opts && opts.cacheable !== undefined ? opts.cacheable : true;
          this._dependentKeys = opts && opts.dependentKeys;
          this._readOnly = opts && (opts.readOnly !== undefined || !!opts.readOnly);
        }
        Ember.ComputedProperty = ComputedProperty;
        ComputedProperty.prototype = new Ember.Descriptor;
        var ComputedPropertyPrototype = ComputedProperty.prototype;
        ComputedPropertyPrototype.cacheable = function (aFlag) {
          this._cacheable = aFlag !== false;
          return this;
        };
        ComputedPropertyPrototype.volatile = function () {
          return this.cacheable(false);
        };
        ComputedPropertyPrototype.readOnly = function (readOnly) {
          this._readOnly = readOnly === undefined || !!readOnly;
          return this;
        };
        ComputedPropertyPrototype.property = function () {
          var args = [];
          for (var i = 0, l = arguments.length; i < l; i++) {
            args.push(arguments[i]);
          }
          this._dependentKeys = args;
          return this;
        };
        ComputedPropertyPrototype.meta = function (meta) {
          if (arguments.length === 0) {
            return this._meta || {};
          } else {
            this._meta = meta;
            return this;
          }
        };
        ComputedPropertyPrototype.willWatch = function (obj, keyName) {
          var meta = obj[META_KEY];
          Ember.assert('watch should have setup meta to be writable', meta.source === obj);
          if (!(keyName in meta.cache)) {
            addDependentKeys(this, obj, keyName, meta);
          }
        };
        ComputedPropertyPrototype.didUnwatch = function (obj, keyName) {
          var meta = obj[META_KEY];
          Ember.assert('unwatch should have setup meta to be writable', meta.source === obj);
          if (!(keyName in meta.cache)) {
            removeDependentKeys(this, obj, keyName, meta);
          }
        };
        ComputedPropertyPrototype.didChange = function (obj, keyName) {
          if (this._cacheable && this._suspended !== obj) {
            var meta = metaFor(obj);
            if (keyName in meta.cache) {
              delete meta.cache[keyName];
              if (!meta.watching[keyName]) {
                removeDependentKeys(this, obj, keyName, meta);
              }
            }
          }
        };
        ComputedPropertyPrototype.get = function (obj, keyName) {
          var ret, cache, meta;
          if (this._cacheable) {
            meta = metaFor(obj);
            cache = meta.cache;
            if (keyName in cache) {
              return cache[keyName];
            }
            ret = cache[keyName] = this.func.call(obj, keyName);
            if (!meta.watching[keyName]) {
              addDependentKeys(this, obj, keyName, meta);
            }
          } else {
            ret = this.func.call(obj, keyName);
          }
          return ret;
        };
        ComputedPropertyPrototype.set = function (obj, keyName, value) {
          var cacheable = this._cacheable, func = this.func, meta = metaFor(obj, cacheable), watched = meta.watching[keyName], oldSuspended = this._suspended, hadCachedValue = false, cache = meta.cache, cachedValue, ret;
          if (this._readOnly) {
            throw new Error('Cannot Set: ' + keyName + ' on: ' + obj.toString());
          }
          this._suspended = obj;
          try {
            if (cacheable && cache.hasOwnProperty(keyName)) {
              cachedValue = cache[keyName];
              hadCachedValue = true;
            }
            if (func.wrappedFunction) {
              func = func.wrappedFunction;
            }
            if (func.length === 3) {
              ret = func.call(obj, keyName, value, cachedValue);
            } else if (func.length === 2) {
              ret = func.call(obj, keyName, value);
            } else {
              Ember.defineProperty(obj, keyName, null, cachedValue);
              Ember.set(obj, keyName, value);
              return;
            }
            if (hadCachedValue && cachedValue === ret) {
              return;
            }
            if (watched) {
              Ember.propertyWillChange(obj, keyName);
            }
            if (hadCachedValue) {
              delete cache[keyName];
            }
            if (cacheable) {
              if (!watched && !hadCachedValue) {
                addDependentKeys(this, obj, keyName, meta);
              }
              cache[keyName] = ret;
            }
            if (watched) {
              Ember.propertyDidChange(obj, keyName);
            }
          } finally {
            this._suspended = oldSuspended;
          }
          return ret;
        };
        ComputedPropertyPrototype.setup = function (obj, keyName) {
          var meta = obj[META_KEY];
          if (meta && meta.watching[keyName]) {
            addDependentKeys(this, obj, keyName, metaFor(obj));
          }
        };
        ComputedPropertyPrototype.teardown = function (obj, keyName) {
          var meta = metaFor(obj);
          if (meta.watching[keyName] || keyName in meta.cache) {
            removeDependentKeys(this, obj, keyName, meta);
          }
          if (this._cacheable) {
            delete meta.cache[keyName];
          }
          return null;
        };
        Ember.computed = function (func) {
          var args;
          if (arguments.length > 1) {
            args = a_slice.call(arguments, 0, -1);
            func = a_slice.call(arguments, -1)[0];
          }
          if (typeof func !== 'function') {
            throw new Error('Computed Property declared without a property function');
          }
          var cp = new ComputedProperty(func);
          if (args) {
            cp.property.apply(cp, args);
          }
          return cp;
        };
        Ember.cacheFor = function cacheFor(obj, key) {
          var cache = metaFor(obj, false).cache;
          if (cache && key in cache) {
            return cache[key];
          }
        };
        function getProperties(self, propertyNames) {
          var ret = {};
          for (var i = 0; i < propertyNames.length; i++) {
            ret[propertyNames[i]] = get(self, propertyNames[i]);
          }
          return ret;
        }
        function registerComputed(name, macro) {
          Ember.computed[name] = function (dependentKey) {
            var args = a_slice.call(arguments);
            return Ember.computed(dependentKey, function () {
              return macro.apply(this, args);
            });
          };
        }
        function registerComputedWithProperties(name, macro) {
          Ember.computed[name] = function () {
            var properties = a_slice.call(arguments);
            var computed = Ember.computed(function () {
                return macro.apply(this, [getProperties(this, properties)]);
              });
            return computed.property.apply(computed, properties);
          };
        }
        registerComputed('empty', function (dependentKey) {
          return Ember.isEmpty(get(this, dependentKey));
        });
        registerComputed('notEmpty', function (dependentKey) {
          return !Ember.isEmpty(get(this, dependentKey));
        });
        registerComputed('none', function (dependentKey) {
          return Ember.isNone(get(this, dependentKey));
        });
        registerComputed('not', function (dependentKey) {
          return !get(this, dependentKey);
        });
        registerComputed('bool', function (dependentKey) {
          return !!get(this, dependentKey);
        });
        registerComputed('match', function (dependentKey, regexp) {
          var value = get(this, dependentKey);
          return typeof value === 'string' ? !!value.match(regexp) : false;
        });
        registerComputed('equal', function (dependentKey, value) {
          return get(this, dependentKey) === value;
        });
        registerComputed('gt', function (dependentKey, value) {
          return get(this, dependentKey) > value;
        });
        registerComputed('gte', function (dependentKey, value) {
          return get(this, dependentKey) >= value;
        });
        registerComputed('lt', function (dependentKey, value) {
          return get(this, dependentKey) < value;
        });
        registerComputed('lte', function (dependentKey, value) {
          return get(this, dependentKey) <= value;
        });
        registerComputedWithProperties('and', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && !properties[key]) {
              return false;
            }
          }
          return true;
        });
        registerComputedWithProperties('or', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && properties[key]) {
              return true;
            }
          }
          return false;
        });
        registerComputedWithProperties('any', function (properties) {
          for (var key in properties) {
            if (properties.hasOwnProperty(key) && properties[key]) {
              return properties[key];
            }
          }
          return null;
        });
        registerComputedWithProperties('map', function (properties) {
          var res = [];
          for (var key in properties) {
            if (properties.hasOwnProperty(key)) {
              if (Ember.isNone(properties[key])) {
                res.push(null);
              } else {
                res.push(properties[key]);
              }
            }
          }
          return res;
        });
        Ember.computed.alias = function (dependentKey) {
          return Ember.computed(dependentKey, function (key, value) {
            if (arguments.length > 1) {
              set(this, dependentKey, value);
              return value;
            } else {
              return get(this, dependentKey);
            }
          });
        };
        Ember.computed.defaultTo = function (defaultPath) {
          return Ember.computed(function (key, newValue, cachedValue) {
            var result;
            if (arguments.length === 1) {
              return cachedValue != null ? cachedValue : get(this, defaultPath);
            }
            return newValue != null ? newValue : get(this, defaultPath);
          });
        };
      }());
      (function () {
        var AFTER_OBSERVERS = ':change';
        var BEFORE_OBSERVERS = ':before';
        var guidFor = Ember.guidFor;
        function changeEvent(keyName) {
          return keyName + AFTER_OBSERVERS;
        }
        function beforeEvent(keyName) {
          return keyName + BEFORE_OBSERVERS;
        }
        Ember.addObserver = function (obj, path, target, method) {
          Ember.addListener(obj, changeEvent(path), target, method);
          Ember.watch(obj, path);
          return this;
        };
        Ember.observersFor = function (obj, path) {
          return Ember.listenersFor(obj, changeEvent(path));
        };
        Ember.removeObserver = function (obj, path, target, method) {
          Ember.unwatch(obj, path);
          Ember.removeListener(obj, changeEvent(path), target, method);
          return this;
        };
        Ember.addBeforeObserver = function (obj, path, target, method) {
          Ember.addListener(obj, beforeEvent(path), target, method);
          Ember.watch(obj, path);
          return this;
        };
        Ember._suspendBeforeObserver = function (obj, path, target, method, callback) {
          return Ember._suspendListener(obj, beforeEvent(path), target, method, callback);
        };
        Ember._suspendObserver = function (obj, path, target, method, callback) {
          return Ember._suspendListener(obj, changeEvent(path), target, method, callback);
        };
        var map = Ember.ArrayPolyfills.map;
        Ember._suspendBeforeObservers = function (obj, paths, target, method, callback) {
          var events = map.call(paths, beforeEvent);
          return Ember._suspendListeners(obj, events, target, method, callback);
        };
        Ember._suspendObservers = function (obj, paths, target, method, callback) {
          var events = map.call(paths, changeEvent);
          return Ember._suspendListeners(obj, events, target, method, callback);
        };
        Ember.beforeObserversFor = function (obj, path) {
          return Ember.listenersFor(obj, beforeEvent(path));
        };
        Ember.removeBeforeObserver = function (obj, path, target, method) {
          Ember.unwatch(obj, path);
          Ember.removeListener(obj, beforeEvent(path), target, method);
          return this;
        };
      }());
      (function () {
        var slice = [].slice, forEach = Ember.ArrayPolyfills.forEach;
        function invoke(target, method, args, ignore) {
          if (method === undefined) {
            method = target;
            target = undefined;
          }
          if ('string' === typeof method) {
            method = target[method];
          }
          if (args && ignore > 0) {
            args = args.length > ignore ? slice.call(args, ignore) : null;
          }
          return Ember.handleErrors(function () {
            return method.apply(target || this, args || []);
          }, this);
        }
        var timerMark;
        var RunLoop = function (prev) {
          this._prev = prev || null;
          this.onceTimers = {};
        };
        RunLoop.prototype = {
          end: function () {
            this.flush();
          },
          prev: function () {
            return this._prev;
          },
          schedule: function (queueName, target, method) {
            var queues = this._queues, queue;
            if (!queues) {
              queues = this._queues = {};
            }
            queue = queues[queueName];
            if (!queue) {
              queue = queues[queueName] = [];
            }
            var args = arguments.length > 3 ? slice.call(arguments, 3) : null;
            queue.push({
              target: target,
              method: method,
              args: args
            });
            return this;
          },
          flush: function (queueName) {
            var queueNames, idx, len, queue, log;
            if (!this._queues) {
              return this;
            }
            function iter(item) {
              invoke(item.target, item.method, item.args);
            }
            function tryable() {
              forEach.call(queue, iter);
            }
            Ember.watch.flushPending();
            if (queueName) {
              while (this._queues && (queue = this._queues[queueName])) {
                this._queues[queueName] = null;
                if (queueName === 'sync') {
                  log = Ember.LOG_BINDINGS;
                  if (log) {
                    Ember.Logger.log('Begin: Flush Sync Queue');
                  }
                  Ember.beginPropertyChanges();
                  Ember.tryFinally(tryable, Ember.endPropertyChanges);
                  if (log) {
                    Ember.Logger.log('End: Flush Sync Queue');
                  }
                } else {
                  forEach.call(queue, iter);
                }
              }
            } else {
              queueNames = Ember.run.queues;
              len = queueNames.length;
              idx = 0;
              outerloop:
                while (idx < len) {
                  queueName = queueNames[idx];
                  queue = this._queues && this._queues[queueName];
                  delete this._queues[queueName];
                  if (queue) {
                    if (queueName === 'sync') {
                      log = Ember.LOG_BINDINGS;
                      if (log) {
                        Ember.Logger.log('Begin: Flush Sync Queue');
                      }
                      Ember.beginPropertyChanges();
                      Ember.tryFinally(tryable, Ember.endPropertyChanges);
                      if (log) {
                        Ember.Logger.log('End: Flush Sync Queue');
                      }
                    } else {
                      forEach.call(queue, iter);
                    }
                  }
                  for (var i = 0; i <= idx; i++) {
                    if (this._queues && this._queues[queueNames[i]]) {
                      idx = i;
                      continue outerloop;
                    }
                  }
                  idx++;
                }
            }
            timerMark = null;
            return this;
          }
        };
        Ember.RunLoop = RunLoop;
        Ember.run = function (target, method) {
          var args = arguments;
          run.begin();
          function tryable() {
            if (target || method) {
              return invoke(target, method, args, 2);
            }
          }
          return Ember.tryFinally(tryable, run.end);
        };
        var run = Ember.run;
        Ember.run.begin = function () {
          run.currentRunLoop = new RunLoop(run.currentRunLoop);
        };
        Ember.run.end = function () {
          Ember.assert('must have a current run loop', run.currentRunLoop);
          function tryable() {
            run.currentRunLoop.end();
          }
          function finalizer() {
            run.currentRunLoop = run.currentRunLoop.prev();
          }
          Ember.tryFinally(tryable, finalizer);
        };
        Ember.run.queues = [
          'sync',
          'actions',
          'destroy'
        ];
        Ember.run.schedule = function (queue, target, method) {
          var loop = run.autorun();
          loop.schedule.apply(loop, arguments);
        };
        var scheduledAutorun;
        function autorun() {
          scheduledAutorun = null;
          if (run.currentRunLoop) {
            run.end();
          }
        }
        Ember.run.hasScheduledTimers = function () {
          return !!(scheduledAutorun || scheduledLater);
        };
        Ember.run.cancelTimers = function () {
          if (scheduledAutorun) {
            clearTimeout(scheduledAutorun);
            scheduledAutorun = null;
          }
          if (scheduledLater) {
            clearTimeout(scheduledLater);
            scheduledLater = null;
          }
          timers = {};
        };
        Ember.run.autorun = function () {
          if (!run.currentRunLoop) {
            Ember.assert("You have turned on testing mode, which disabled the run-loop's autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run", !Ember.testing);
            run.begin();
            if (!scheduledAutorun) {
              scheduledAutorun = setTimeout(autorun, 1);
            }
          }
          return run.currentRunLoop;
        };
        Ember.run.sync = function () {
          run.autorun();
          run.currentRunLoop.flush('sync');
        };
        var timers = {};
        var scheduledLater, scheduledLaterExpires;
        function invokeLaterTimers() {
          scheduledLater = null;
          run(function () {
            var now = +new Date, earliest = -1;
            for (var key in timers) {
              if (!timers.hasOwnProperty(key)) {
                continue;
              }
              var timer = timers[key];
              if (timer && timer.expires) {
                if (now >= timer.expires) {
                  delete timers[key];
                  invoke(timer.target, timer.method, timer.args, 2);
                } else {
                  if (earliest < 0 || timer.expires < earliest) {
                    earliest = timer.expires;
                  }
                }
              }
            }
            if (earliest > 0) {
              scheduledLater = setTimeout(invokeLaterTimers, earliest - now);
              scheduledLaterExpires = earliest;
            }
          });
        }
        Ember.run.later = function (target, method) {
          var args, expires, timer, guid, wait;
          if (arguments.length === 2 && 'function' === typeof target) {
            wait = method;
            method = target;
            target = undefined;
            args = [
              target,
              method
            ];
          } else {
            args = slice.call(arguments);
            wait = args.pop();
          }
          expires = +new Date + wait;
          timer = {
            target: target,
            method: method,
            expires: expires,
            args: args
          };
          guid = Ember.guidFor(timer);
          timers[guid] = timer;
          if (scheduledLater && expires < scheduledLaterExpires) {
            clearTimeout(scheduledLater);
            scheduledLater = null;
          }
          if (!scheduledLater) {
            scheduledLater = setTimeout(invokeLaterTimers, wait);
            scheduledLaterExpires = expires;
          }
          return guid;
        };
        function invokeOnceTimer(guid, onceTimers) {
          if (onceTimers[this.tguid]) {
            delete onceTimers[this.tguid][this.mguid];
          }
          if (timers[guid]) {
            invoke(this.target, this.method, this.args);
          }
          delete timers[guid];
        }
        function scheduleOnce(queue, target, method, args) {
          var tguid = Ember.guidFor(target), mguid = Ember.guidFor(method), onceTimers = run.autorun().onceTimers, guid = onceTimers[tguid] && onceTimers[tguid][mguid], timer;
          if (guid && timers[guid]) {
            timers[guid].args = args;
          } else {
            timer = {
              target: target,
              method: method,
              args: args,
              tguid: tguid,
              mguid: mguid
            };
            guid = Ember.guidFor(timer);
            timers[guid] = timer;
            if (!onceTimers[tguid]) {
              onceTimers[tguid] = {};
            }
            onceTimers[tguid][mguid] = guid;
            run.schedule(queue, timer, invokeOnceTimer, guid, onceTimers);
          }
          return guid;
        }
        Ember.run.once = function (target, method) {
          return scheduleOnce('actions', target, method, slice.call(arguments, 2));
        };
        Ember.run.scheduleOnce = function (queue, target, method, args) {
          return scheduleOnce(queue, target, method, slice.call(arguments, 3));
        };
        Ember.run.next = function () {
          var args = slice.call(arguments);
          args.push(1);
          return run.later.apply(this, args);
        };
        Ember.run.cancel = function (timer) {
          delete timers[timer];
        };
      }());
      (function () {
        Ember.LOG_BINDINGS = false || !!Ember.ENV.LOG_BINDINGS;
        var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, IS_GLOBAL = /^([A-Z$]|([0-9][A-Z$]))/;
        var isGlobalPath = Ember.isGlobalPath = function (path) {
            return IS_GLOBAL.test(path);
          };
        function getWithGlobals(obj, path) {
          return get(isGlobalPath(path) ? Ember.lookup : obj, path);
        }
        var Binding = function (toPath, fromPath) {
          this._direction = 'fwd';
          this._from = fromPath;
          this._to = toPath;
          this._directionMap = Ember.Map.create();
        };
        Binding.prototype = {
          copy: function () {
            var copy = new Binding(this._to, this._from);
            if (this._oneWay) {
              copy._oneWay = true;
            }
            return copy;
          },
          from: function (path) {
            this._from = path;
            return this;
          },
          to: function (path) {
            this._to = path;
            return this;
          },
          oneWay: function () {
            this._oneWay = true;
            return this;
          },
          toString: function () {
            var oneWay = this._oneWay ? '[oneWay]' : '';
            return 'Ember.Binding<' + guidFor(this) + '>(' + this._from + ' -> ' + this._to + ')' + oneWay;
          },
          connect: function (obj) {
            Ember.assert('Must pass a valid object to Ember.Binding.connect()', !!obj);
            var fromPath = this._from, toPath = this._to;
            Ember.trySet(obj, toPath, getWithGlobals(obj, fromPath));
            Ember.addObserver(obj, fromPath, this, this.fromDidChange);
            if (!this._oneWay) {
              Ember.addObserver(obj, toPath, this, this.toDidChange);
            }
            this._readyToSync = true;
            return this;
          },
          disconnect: function (obj) {
            Ember.assert('Must pass a valid object to Ember.Binding.disconnect()', !!obj);
            var twoWay = !this._oneWay;
            Ember.removeObserver(obj, this._from, this, this.fromDidChange);
            if (twoWay) {
              Ember.removeObserver(obj, this._to, this, this.toDidChange);
            }
            this._readyToSync = false;
            return this;
          },
          fromDidChange: function (target) {
            this._scheduleSync(target, 'fwd');
          },
          toDidChange: function (target) {
            this._scheduleSync(target, 'back');
          },
          _scheduleSync: function (obj, dir) {
            var directionMap = this._directionMap;
            var existingDir = directionMap.get(obj);
            if (!existingDir) {
              Ember.run.schedule('sync', this, this._sync, obj);
              directionMap.set(obj, dir);
            }
            if (existingDir === 'back' && dir === 'fwd') {
              directionMap.set(obj, 'fwd');
            }
          },
          _sync: function (obj) {
            var log = Ember.LOG_BINDINGS;
            if (obj.isDestroyed || !this._readyToSync) {
              return;
            }
            var directionMap = this._directionMap;
            var direction = directionMap.get(obj);
            var fromPath = this._from, toPath = this._to;
            directionMap.remove(obj);
            if (direction === 'fwd') {
              var fromValue = getWithGlobals(obj, this._from);
              if (log) {
                Ember.Logger.log(' ', this.toString(), '->', fromValue, obj);
              }
              if (this._oneWay) {
                Ember.trySet(obj, toPath, fromValue);
              } else {
                Ember._suspendObserver(obj, toPath, this, this.toDidChange, function () {
                  Ember.trySet(obj, toPath, fromValue);
                });
              }
            } else if (direction === 'back') {
              var toValue = get(obj, this._to);
              if (log) {
                Ember.Logger.log(' ', this.toString(), '<-', toValue, obj);
              }
              Ember._suspendObserver(obj, fromPath, this, this.fromDidChange, function () {
                Ember.trySet(Ember.isGlobalPath(fromPath) ? Ember.lookup : obj, fromPath, toValue);
              });
            }
          }
        };
        function mixinProperties(to, from) {
          for (var key in from) {
            if (from.hasOwnProperty(key)) {
              to[key] = from[key];
            }
          }
        }
        mixinProperties(Binding, {
          from: function () {
            var C = this, binding = new C;
            return binding.from.apply(binding, arguments);
          },
          to: function () {
            var C = this, binding = new C;
            return binding.to.apply(binding, arguments);
          },
          oneWay: function (from, flag) {
            var C = this, binding = new C(null, from);
            return binding.oneWay(flag);
          }
        });
        Ember.Binding = Binding;
        Ember.bind = function (obj, to, from) {
          return new Ember.Binding(to, from).connect(obj);
        };
        Ember.oneWay = function (obj, to, from) {
          return new Ember.Binding(to, from).oneWay().connect(obj);
        };
      }());
      (function () {
        var Mixin, REQUIRED, Alias, a_map = Ember.ArrayPolyfills.map, a_indexOf = Ember.ArrayPolyfills.indexOf, a_forEach = Ember.ArrayPolyfills.forEach, a_slice = [].slice, o_create = Ember.create, defineProperty = Ember.defineProperty, guidFor = Ember.guidFor;
        function mixinsMeta(obj) {
          var m = Ember.meta(obj, true), ret = m.mixins;
          if (!ret) {
            ret = m.mixins = {};
          } else if (!m.hasOwnProperty('mixins')) {
            ret = m.mixins = o_create(ret);
          }
          return ret;
        }
        function initMixin(mixin, args) {
          if (args && args.length > 0) {
            mixin.mixins = a_map.call(args, function (x) {
              if (x instanceof Mixin) {
                return x;
              }
              var mixin = new Mixin;
              mixin.properties = x;
              return mixin;
            });
          }
          return mixin;
        }
        function isMethod(obj) {
          return 'function' === typeof obj && obj.isMethod !== false && obj !== Boolean && obj !== Object && obj !== Number && obj !== Array && obj !== Date && obj !== String;
        }
        var CONTINUE = {};
        function mixinProperties(mixinsMeta, mixin) {
          var guid;
          if (mixin instanceof Mixin) {
            guid = guidFor(mixin);
            if (mixinsMeta[guid]) {
              return CONTINUE;
            }
            mixinsMeta[guid] = mixin;
            return mixin.properties;
          } else {
            return mixin;
          }
        }
        function concatenatedProperties(props, values, base) {
          var concats;
          concats = values.concatenatedProperties || base.concatenatedProperties;
          if (props.concatenatedProperties) {
            concats = concats ? concats.concat(props.concatenatedProperties) : props.concatenatedProperties;
          }
          return concats;
        }
        function giveDescriptorSuper(meta, key, property, values, descs) {
          var superProperty;
          if (values[key] === undefined) {
            superProperty = descs[key];
          }
          superProperty = superProperty || meta.descs[key];
          if (!superProperty || !(superProperty instanceof Ember.ComputedProperty)) {
            return property;
          }
          property = o_create(property);
          property.func = Ember.wrap(property.func, superProperty.func);
          return property;
        }
        function giveMethodSuper(obj, key, method, values, descs) {
          var superMethod;
          if (descs[key] === undefined) {
            superMethod = values[key];
          }
          superMethod = superMethod || obj[key];
          if ('function' !== typeof superMethod) {
            return method;
          }
          return Ember.wrap(method, superMethod);
        }
        function applyConcatenatedProperties(obj, key, value, values) {
          var baseValue = values[key] || obj[key];
          if (baseValue) {
            if ('function' === typeof baseValue.concat) {
              return baseValue.concat(value);
            } else {
              return Ember.makeArray(baseValue).concat(value);
            }
          } else {
            return Ember.makeArray(value);
          }
        }
        function addNormalizedProperty(base, key, value, meta, descs, values, concats) {
          if (value instanceof Ember.Descriptor) {
            if (value === REQUIRED && descs[key]) {
              return CONTINUE;
            }
            if (value.func) {
              value = giveDescriptorSuper(meta, key, value, values, descs);
            }
            descs[key] = value;
            values[key] = undefined;
          } else {
            if (isMethod(value)) {
              value = giveMethodSuper(base, key, value, values, descs);
            } else if (concats && a_indexOf.call(concats, key) >= 0 || key === 'concatenatedProperties') {
              value = applyConcatenatedProperties(base, key, value, values);
            }
            descs[key] = undefined;
            values[key] = value;
          }
        }
        function mergeMixins(mixins, m, descs, values, base, keys) {
          var mixin, props, key, concats, meta;
          function removeKeys(keyName) {
            delete descs[keyName];
            delete values[keyName];
          }
          for (var i = 0, l = mixins.length; i < l; i++) {
            mixin = mixins[i];
            Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');
            props = mixinProperties(m, mixin);
            if (props === CONTINUE) {
              continue;
            }
            if (props) {
              meta = Ember.meta(base);
              concats = concatenatedProperties(props, values, base);
              for (key in props) {
                if (!props.hasOwnProperty(key)) {
                  continue;
                }
                keys.push(key);
                addNormalizedProperty(base, key, props[key], meta, descs, values, concats);
              }
              if (props.hasOwnProperty('toString')) {
                base.toString = props.toString;
              }
            } else if (mixin.mixins) {
              mergeMixins(mixin.mixins, m, descs, values, base, keys);
              if (mixin._without) {
                a_forEach.call(mixin._without, removeKeys);
              }
            }
          }
        }
        function writableReq(obj) {
          var m = Ember.meta(obj), req = m.required;
          if (!req || !m.hasOwnProperty('required')) {
            req = m.required = req ? o_create(req) : {};
          }
          return req;
        }
        var IS_BINDING = Ember.IS_BINDING = /^.+Binding$/;
        function detectBinding(obj, key, value, m) {
          if (IS_BINDING.test(key)) {
            var bindings = m.bindings;
            if (!bindings) {
              bindings = m.bindings = {};
            } else if (!m.hasOwnProperty('bindings')) {
              bindings = m.bindings = o_create(m.bindings);
            }
            bindings[key] = value;
          }
        }
        function connectBindings(obj, m) {
          var bindings = m.bindings, key, binding, to;
          if (bindings) {
            for (key in bindings) {
              binding = bindings[key];
              if (binding) {
                to = key.slice(0, -7);
                if (binding instanceof Ember.Binding) {
                  binding = binding.copy();
                  binding.to(to);
                } else {
                  binding = new Ember.Binding(to, binding);
                }
                binding.connect(obj);
                obj[key] = binding;
              }
            }
            m.bindings = {};
          }
        }
        function finishPartial(obj, m) {
          connectBindings(obj, m || Ember.meta(obj));
          return obj;
        }
        function followAlias(obj, desc, m, descs, values) {
          var altKey = desc.methodName, value;
          if (descs[altKey] || values[altKey]) {
            value = values[altKey];
            desc = descs[altKey];
          } else if (m.descs[altKey]) {
            desc = m.descs[altKey];
            value = undefined;
          } else {
            desc = undefined;
            value = obj[altKey];
          }
          return {
            desc: desc,
            value: value
          };
        }
        function updateObservers(obj, key, observer, observerKey, method) {
          if ('function' !== typeof observer) {
            return;
          }
          var paths = observer[observerKey];
          if (paths) {
            for (var i = 0, l = paths.length; i < l; i++) {
              Ember[method](obj, paths[i], null, key);
            }
          }
        }
        function replaceObservers(obj, key, observer) {
          var prevObserver = obj[key];
          updateObservers(obj, key, prevObserver, '__ember_observesBefore__', 'removeBeforeObserver');
          updateObservers(obj, key, prevObserver, '__ember_observes__', 'removeObserver');
          updateObservers(obj, key, observer, '__ember_observesBefore__', 'addBeforeObserver');
          updateObservers(obj, key, observer, '__ember_observes__', 'addObserver');
        }
        function applyMixin(obj, mixins, partial) {
          var descs = {}, values = {}, m = Ember.meta(obj), key, value, desc, keys = [];
          mergeMixins(mixins, mixinsMeta(obj), descs, values, obj, keys);
          for (var i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            if (key === 'constructor' || !values.hasOwnProperty(key)) {
              continue;
            }
            desc = descs[key];
            value = values[key];
            if (desc === REQUIRED) {
              continue;
            }
            while (desc && desc instanceof Alias) {
              var followed = followAlias(obj, desc, m, descs, values);
              desc = followed.desc;
              value = followed.value;
            }
            if (desc === undefined && value === undefined) {
              continue;
            }
            replaceObservers(obj, key, value);
            detectBinding(obj, key, value, m);
            defineProperty(obj, key, desc, value, m);
          }
          if (!partial) {
            finishPartial(obj, m);
          }
          return obj;
        }
        Ember.mixin = function (obj) {
          var args = a_slice.call(arguments, 1);
          applyMixin(obj, args, false);
          return obj;
        };
        Ember.Mixin = function () {
          return initMixin(this, arguments);
        };
        Mixin = Ember.Mixin;
        Mixin.prototype = {
          properties: null,
          mixins: null,
          ownerConstructor: null
        };
        Mixin._apply = applyMixin;
        Mixin.applyPartial = function (obj) {
          var args = a_slice.call(arguments, 1);
          return applyMixin(obj, args, true);
        };
        Mixin.finishPartial = finishPartial;
        Ember.anyUnprocessedMixins = false;
        Mixin.create = function () {
          Ember.anyUnprocessedMixins = true;
          var M = this;
          return initMixin(new M, arguments);
        };
        var MixinPrototype = Mixin.prototype;
        MixinPrototype.reopen = function () {
          var mixin, tmp;
          if (this.properties) {
            mixin = Mixin.create();
            mixin.properties = this.properties;
            delete this.properties;
            this.mixins = [mixin];
          } else if (!this.mixins) {
            this.mixins = [];
          }
          var len = arguments.length, mixins = this.mixins, idx;
          for (idx = 0; idx < len; idx++) {
            mixin = arguments[idx];
            Ember.assert('Expected hash or Mixin instance, got ' + Object.prototype.toString.call(mixin), typeof mixin === 'object' && mixin !== null && Object.prototype.toString.call(mixin) !== '[object Array]');
            if (mixin instanceof Mixin) {
              mixins.push(mixin);
            } else {
              tmp = Mixin.create();
              tmp.properties = mixin;
              mixins.push(tmp);
            }
          }
          return this;
        };
        MixinPrototype.apply = function (obj) {
          return applyMixin(obj, [this], false);
        };
        MixinPrototype.applyPartial = function (obj) {
          return applyMixin(obj, [this], true);
        };
        function _detect(curMixin, targetMixin, seen) {
          var guid = guidFor(curMixin);
          if (seen[guid]) {
            return false;
          }
          seen[guid] = true;
          if (curMixin === targetMixin) {
            return true;
          }
          var mixins = curMixin.mixins, loc = mixins ? mixins.length : 0;
          while (--loc >= 0) {
            if (_detect(mixins[loc], targetMixin, seen)) {
              return true;
            }
          }
          return false;
        }
        MixinPrototype.detect = function (obj) {
          if (!obj) {
            return false;
          }
          if (obj instanceof Mixin) {
            return _detect(obj, this, {});
          }
          var mixins = Ember.meta(obj, false).mixins;
          if (mixins) {
            return !!mixins[guidFor(this)];
          }
          return false;
        };
        MixinPrototype.without = function () {
          var ret = new Mixin(this);
          ret._without = a_slice.call(arguments);
          return ret;
        };
        function _keys(ret, mixin, seen) {
          if (seen[guidFor(mixin)]) {
            return;
          }
          seen[guidFor(mixin)] = true;
          if (mixin.properties) {
            var props = mixin.properties;
            for (var key in props) {
              if (props.hasOwnProperty(key)) {
                ret[key] = true;
              }
            }
          } else if (mixin.mixins) {
            a_forEach.call(mixin.mixins, function (x) {
              _keys(ret, x, seen);
            });
          }
        }
        MixinPrototype.keys = function () {
          var keys = {}, seen = {}, ret = [];
          _keys(keys, this, seen);
          for (var key in keys) {
            if (keys.hasOwnProperty(key)) {
              ret.push(key);
            }
          }
          return ret;
        };
        Mixin.mixins = function (obj) {
          var mixins = Ember.meta(obj, false).mixins, ret = [];
          if (!mixins) {
            return ret;
          }
          for (var key in mixins) {
            var mixin = mixins[key];
            if (!mixin.properties) {
              ret.push(mixin);
            }
          }
          return ret;
        };
        REQUIRED = new Ember.Descriptor;
        REQUIRED.toString = function () {
          return '(Required Property)';
        };
        Ember.required = function () {
          return REQUIRED;
        };
        Alias = function (methodName) {
          this.methodName = methodName;
        };
        Alias.prototype = new Ember.Descriptor;
        Ember.alias = function (methodName) {
          return new Alias(methodName);
        };
        Ember.deprecateFunc('Ember.alias is deprecated. Please use Ember.aliasMethod or Ember.computed.alias instead.', Ember.alias);
        Ember.aliasMethod = function (methodName) {
          return new Alias(methodName);
        };
        Ember.observer = function (func) {
          var paths = a_slice.call(arguments, 1);
          func.__ember_observes__ = paths;
          return func;
        };
        Ember.immediateObserver = function () {
          for (var i = 0, l = arguments.length; i < l; i++) {
            var arg = arguments[i];
            Ember.assert('Immediate observers must observe internal properties only, not properties on other objects.', typeof arg !== 'string' || arg.indexOf('.') === -1);
          }
          return Ember.observer.apply(this, arguments);
        };
        Ember.beforeObserver = function (func) {
          var paths = a_slice.call(arguments, 1);
          func.__ember_observesBefore__ = paths;
          return func;
        };
      }());
      (function () {
      }());
      (function () {
        define('rsvp', [], function () {
          'use strict';
          var browserGlobal = typeof window !== 'undefined' ? window : {};
          var MutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
          var RSVP, async;
          if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            async = function (callback, binding) {
              process.nextTick(function () {
                callback.call(binding);
              });
            };
          } else if (MutationObserver) {
            var queue = [];
            var observer = new MutationObserver(function () {
                var toProcess = queue.slice();
                queue = [];
                toProcess.forEach(function (tuple) {
                  var callback = tuple[0], binding = tuple[1];
                  callback.call(binding);
                });
              });
            var element = document.createElement('div');
            observer.observe(element, { attributes: true });
            window.addEventListener('unload', function () {
              observer.disconnect();
              observer = null;
            });
            async = function (callback, binding) {
              queue.push([
                callback,
                binding
              ]);
              element.setAttribute('drainQueue', 'drainQueue');
            };
          } else {
            async = function (callback, binding) {
              setTimeout(function () {
                callback.call(binding);
              }, 1);
            };
          }
          var Event = function (type, options) {
            this.type = type;
            for (var option in options) {
              if (!options.hasOwnProperty(option)) {
                continue;
              }
              this[option] = options[option];
            }
          };
          var indexOf = function (callbacks, callback) {
            for (var i = 0, l = callbacks.length; i < l; i++) {
              if (callbacks[i][0] === callback) {
                return i;
              }
            }
            return -1;
          };
          var callbacksFor = function (object) {
            var callbacks = object._promiseCallbacks;
            if (!callbacks) {
              callbacks = object._promiseCallbacks = {};
            }
            return callbacks;
          };
          var EventTarget = {
              mixin: function (object) {
                object.on = this.on;
                object.off = this.off;
                object.trigger = this.trigger;
                return object;
              },
              on: function (eventNames, callback, binding) {
                var allCallbacks = callbacksFor(this), callbacks, eventName;
                eventNames = eventNames.split(/\s+/);
                binding = binding || this;
                while (eventName = eventNames.shift()) {
                  callbacks = allCallbacks[eventName];
                  if (!callbacks) {
                    callbacks = allCallbacks[eventName] = [];
                  }
                  if (indexOf(callbacks, callback) === -1) {
                    callbacks.push([
                      callback,
                      binding
                    ]);
                  }
                }
              },
              off: function (eventNames, callback) {
                var allCallbacks = callbacksFor(this), callbacks, eventName, index;
                eventNames = eventNames.split(/\s+/);
                while (eventName = eventNames.shift()) {
                  if (!callback) {
                    allCallbacks[eventName] = [];
                    continue;
                  }
                  callbacks = allCallbacks[eventName];
                  index = indexOf(callbacks, callback);
                  if (index !== -1) {
                    callbacks.splice(index, 1);
                  }
                }
              },
              trigger: function (eventName, options) {
                var allCallbacks = callbacksFor(this), callbacks, callbackTuple, callback, binding, event;
                if (callbacks = allCallbacks[eventName]) {
                  for (var i = 0; i < callbacks.length; i++) {
                    callbackTuple = callbacks[i];
                    callback = callbackTuple[0];
                    binding = callbackTuple[1];
                    if (typeof options !== 'object') {
                      options = { detail: options };
                    }
                    event = new Event(eventName, options);
                    callback.call(binding, event);
                  }
                }
              }
            };
          var Promise = function () {
            this.on('promise:resolved', function (event) {
              this.trigger('success', { detail: event.detail });
            }, this);
            this.on('promise:failed', function (event) {
              this.trigger('error', { detail: event.detail });
            }, this);
          };
          var noop = function () {
          };
          var invokeCallback = function (type, promise, callback, event) {
            var hasCallback = typeof callback === 'function', value, error, succeeded, failed;
            if (hasCallback) {
              try {
                value = callback(event.detail);
                succeeded = true;
              } catch (e) {
                failed = true;
                error = e;
              }
            } else {
              value = event.detail;
              succeeded = true;
            }
            if (value && typeof value.then === 'function') {
              value.then(function (value) {
                promise.resolve(value);
              }, function (error) {
                promise.reject(error);
              });
            } else if (hasCallback && succeeded) {
              promise.resolve(value);
            } else if (failed) {
              promise.reject(error);
            } else {
              promise[type](value);
            }
          };
          Promise.prototype = {
            then: function (done, fail) {
              var thenPromise = new Promise;
              if (this.isResolved) {
                RSVP.async(function () {
                  invokeCallback('resolve', thenPromise, done, { detail: this.resolvedValue });
                }, this);
              }
              if (this.isRejected) {
                RSVP.async(function () {
                  invokeCallback('reject', thenPromise, fail, { detail: this.rejectedValue });
                }, this);
              }
              this.on('promise:resolved', function (event) {
                invokeCallback('resolve', thenPromise, done, event);
              });
              this.on('promise:failed', function (event) {
                invokeCallback('reject', thenPromise, fail, event);
              });
              return thenPromise;
            },
            resolve: function (value) {
              resolve(this, value);
              this.resolve = noop;
              this.reject = noop;
            },
            reject: function (value) {
              reject(this, value);
              this.resolve = noop;
              this.reject = noop;
            }
          };
          function resolve(promise, value) {
            RSVP.async(function () {
              promise.trigger('promise:resolved', { detail: value });
              promise.isResolved = true;
              promise.resolvedValue = value;
            });
          }
          function reject(promise, value) {
            RSVP.async(function () {
              promise.trigger('promise:failed', { detail: value });
              promise.isRejected = true;
              promise.rejectedValue = value;
            });
          }
          function all(promises) {
            var i, results = [];
            var allPromise = new Promise;
            var remaining = promises.length;
            if (remaining === 0) {
              allPromise.resolve([]);
            }
            var resolver = function (index) {
              return function (value) {
                resolve(index, value);
              };
            };
            var resolve = function (index, value) {
              results[index] = value;
              if (--remaining === 0) {
                allPromise.resolve(results);
              }
            };
            var reject = function (error) {
              allPromise.reject(error);
            };
            for (i = 0; i < remaining; i++) {
              promises[i].then(resolver(i), reject);
            }
            return allPromise;
          }
          EventTarget.mixin(Promise.prototype);
          RSVP = {
            async: async,
            Promise: Promise,
            Event: Event,
            EventTarget: EventTarget,
            all: all,
            raiseOnUncaughtExceptions: true
          };
          return RSVP;
        });
      }());
      (function () {
        define('container', [], function () {
          function InheritingDict(parent) {
            this.parent = parent;
            this.dict = {};
          }
          InheritingDict.prototype = {
            get: function (key) {
              var dict = this.dict;
              if (dict.hasOwnProperty(key)) {
                return dict[key];
              }
              if (this.parent) {
                return this.parent.get(key);
              }
            },
            set: function (key, value) {
              this.dict[key] = value;
            },
            has: function (key) {
              var dict = this.dict;
              if (dict.hasOwnProperty(key)) {
                return true;
              }
              if (this.parent) {
                return this.parent.has(key);
              }
              return false;
            },
            eachLocal: function (callback, binding) {
              var dict = this.dict;
              for (var prop in dict) {
                if (dict.hasOwnProperty(prop)) {
                  callback.call(binding, prop, dict[prop]);
                }
              }
            }
          };
          function Container(parent) {
            this.parent = parent;
            this.children = [];
            this.resolver = parent && parent.resolver || function () {
            };
            this.registry = new InheritingDict(parent && parent.registry);
            this.cache = new InheritingDict(parent && parent.cache);
            this.typeInjections = new InheritingDict(parent && parent.typeInjections);
            this.injections = {};
            this._options = new InheritingDict(parent && parent._options);
            this._typeOptions = new InheritingDict(parent && parent._typeOptions);
          }
          Container.prototype = {
            child: function () {
              var container = new Container(this);
              this.children.push(container);
              return container;
            },
            set: function (object, key, value) {
              object[key] = value;
            },
            register: function (type, name, factory, options) {
              var fullName;
              if (type.indexOf(':') !== -1) {
                options = factory;
                factory = name;
                fullName = type;
              } else {
                Ember.deprecate('register("' + type + '", "' + name + '") is now deprecated in-favour of register("' + type + ':' + name + '");', false);
                fullName = type + ':' + name;
              }
              var normalizedName = this.normalize(fullName);
              this.registry.set(normalizedName, factory);
              this._options.set(normalizedName, options || {});
            },
            resolve: function (fullName) {
              return this.resolver(fullName) || this.registry.get(fullName);
            },
            normalize: function (fullName) {
              return fullName;
            },
            lookup: function (fullName, options) {
              fullName = this.normalize(fullName);
              options = options || {};
              if (this.cache.has(fullName) && options.singleton !== false) {
                return this.cache.get(fullName);
              }
              var value = instantiate(this, fullName);
              if (!value) {
                return;
              }
              if (isSingleton(this, fullName) && options.singleton !== false) {
                this.cache.set(fullName, value);
              }
              return value;
            },
            has: function (fullName) {
              if (this.cache.has(fullName)) {
                return true;
              }
              return !!factoryFor(this, fullName);
            },
            optionsForType: function (type, options) {
              if (this.parent) {
                illegalChildOperation('optionsForType');
              }
              this._typeOptions.set(type, options);
            },
            options: function (type, options) {
              this.optionsForType(type, options);
            },
            typeInjection: function (type, property, fullName) {
              if (this.parent) {
                illegalChildOperation('typeInjection');
              }
              var injections = this.typeInjections.get(type);
              if (!injections) {
                injections = [];
                this.typeInjections.set(type, injections);
              }
              injections.push({
                property: property,
                fullName: fullName
              });
            },
            injection: function (factoryName, property, injectionName) {
              if (this.parent) {
                illegalChildOperation('injection');
              }
              if (factoryName.indexOf(':') === -1) {
                return this.typeInjection(factoryName, property, injectionName);
              }
              var injections = this.injections[factoryName] = this.injections[factoryName] || [];
              injections.push({
                property: property,
                fullName: injectionName
              });
            },
            destroy: function () {
              this.isDestroyed = true;
              for (var i = 0, l = this.children.length; i < l; i++) {
                this.children[i].destroy();
              }
              this.children = [];
              eachDestroyable(this, function (item) {
                item.isDestroying = true;
              });
              eachDestroyable(this, function (item) {
                item.destroy();
              });
              delete this.parent;
              this.isDestroyed = true;
            },
            reset: function () {
              for (var i = 0, l = this.children.length; i < l; i++) {
                resetCache(this.children[i]);
              }
              resetCache(this);
            }
          };
          function illegalChildOperation(operation) {
            throw new Error(operation + ' is not currently supported on child containers');
          }
          function isSingleton(container, fullName) {
            var singleton = option(container, fullName, 'singleton');
            return singleton !== false;
          }
          function buildInjections(container, injections) {
            var hash = {};
            if (!injections) {
              return hash;
            }
            var injection, lookup;
            for (var i = 0, l = injections.length; i < l; i++) {
              injection = injections[i];
              lookup = container.lookup(injection.fullName);
              hash[injection.property] = lookup;
            }
            return hash;
          }
          function option(container, fullName, optionName) {
            var options = container._options.get(fullName);
            if (options && options[optionName] !== undefined) {
              return options[optionName];
            }
            var type = fullName.split(':')[0];
            options = container._typeOptions.get(type);
            if (options) {
              return options[optionName];
            }
          }
          function factoryFor(container, fullName) {
            var name = container.normalize(fullName);
            return container.resolve(name);
          }
          function instantiate(container, fullName) {
            var factory = factoryFor(container, fullName);
            var splitName = fullName.split(':'), type = splitName[0], name = splitName[1], value;
            if (option(container, fullName, 'instantiate') === false) {
              return factory;
            }
            if (factory) {
              var injections = [];
              injections = injections.concat(container.typeInjections.get(type) || []);
              injections = injections.concat(container.injections[fullName] || []);
              var hash = buildInjections(container, injections);
              hash.container = container;
              hash._debugContainerKey = fullName;
              value = factory.create(hash);
              return value;
            }
          }
          function eachDestroyable(container, callback) {
            container.cache.eachLocal(function (key, value) {
              if (option(container, key, 'instantiate') === false) {
                return;
              }
              callback(value);
            });
          }
          function resetCache(container) {
            container.cache.eachLocal(function (key, value) {
              if (option(container, key, 'instantiate') === false) {
                return;
              }
              value.destroy();
            });
            container.cache.dict = {};
          }
          return Container;
        });
      }());
      (function () {
        var indexOf = Ember.EnumerableUtils.indexOf;
        var TYPE_MAP = {};
        var t = 'Boolean Number String Function Array Date RegExp Object'.split(' ');
        Ember.ArrayPolyfills.forEach.call(t, function (name) {
          TYPE_MAP['[object ' + name + ']'] = name.toLowerCase();
        });
        var toString = Object.prototype.toString;
        Ember.typeOf = function (item) {
          var ret;
          ret = item === null || item === undefined ? String(item) : TYPE_MAP[toString.call(item)] || 'object';
          if (ret === 'function') {
            if (Ember.Object && Ember.Object.detect(item))
              ret = 'class';
          } else if (ret === 'object') {
            if (item instanceof Error)
              ret = 'error';
            else if (Ember.Object && item instanceof Ember.Object)
              ret = 'instance';
            else
              ret = 'object';
          }
          return ret;
        };
        Ember.compare = function compare(v, w) {
          if (v === w) {
            return 0;
          }
          var type1 = Ember.typeOf(v);
          var type2 = Ember.typeOf(w);
          var Comparable = Ember.Comparable;
          if (Comparable) {
            if (type1 === 'instance' && Comparable.detect(v.constructor)) {
              return v.constructor.compare(v, w);
            }
            if (type2 === 'instance' && Comparable.detect(w.constructor)) {
              return 1 - w.constructor.compare(w, v);
            }
          }
          var mapping = Ember.ORDER_DEFINITION_MAPPING;
          if (!mapping) {
            var order = Ember.ORDER_DEFINITION;
            mapping = Ember.ORDER_DEFINITION_MAPPING = {};
            var idx, len;
            for (idx = 0, len = order.length; idx < len; ++idx) {
              mapping[order[idx]] = idx;
            }
            delete Ember.ORDER_DEFINITION;
          }
          var type1Index = mapping[type1];
          var type2Index = mapping[type2];
          if (type1Index < type2Index) {
            return -1;
          }
          if (type1Index > type2Index) {
            return 1;
          }
          switch (type1) {
          case 'boolean':
          case 'number':
            if (v < w) {
              return -1;
            }
            if (v > w) {
              return 1;
            }
            return 0;
          case 'string':
            var comp = v.localeCompare(w);
            if (comp < 0) {
              return -1;
            }
            if (comp > 0) {
              return 1;
            }
            return 0;
          case 'array':
            var vLen = v.length;
            var wLen = w.length;
            var l = Math.min(vLen, wLen);
            var r = 0;
            var i = 0;
            while (r === 0 && i < l) {
              r = compare(v[i], w[i]);
              i++;
            }
            if (r !== 0) {
              return r;
            }
            if (vLen < wLen) {
              return -1;
            }
            if (vLen > wLen) {
              return 1;
            }
            return 0;
          case 'instance':
            if (Ember.Comparable && Ember.Comparable.detect(v)) {
              return v.compare(v, w);
            }
            return 0;
          case 'date':
            var vNum = v.getTime();
            var wNum = w.getTime();
            if (vNum < wNum) {
              return -1;
            }
            if (vNum > wNum) {
              return 1;
            }
            return 0;
          default:
            return 0;
          }
        };
        function _copy(obj, deep, seen, copies) {
          var ret, loc, key;
          if ('object' !== typeof obj || obj === null)
            return obj;
          if (deep && (loc = indexOf(seen, obj)) >= 0)
            return copies[loc];
          Ember.assert('Cannot clone an Ember.Object that does not implement Ember.Copyable', !(obj instanceof Ember.Object) || Ember.Copyable && Ember.Copyable.detect(obj));
          if (Ember.typeOf(obj) === 'array') {
            ret = obj.slice();
            if (deep) {
              loc = ret.length;
              while (--loc >= 0)
                ret[loc] = _copy(ret[loc], deep, seen, copies);
            }
          } else if (Ember.Copyable && Ember.Copyable.detect(obj)) {
            ret = obj.copy(deep, seen, copies);
          } else {
            ret = {};
            for (key in obj) {
              if (!obj.hasOwnProperty(key))
                continue;
              if (key.substring(0, 2) === '__')
                continue;
              ret[key] = deep ? _copy(obj[key], deep, seen, copies) : obj[key];
            }
          }
          if (deep) {
            seen.push(obj);
            copies.push(ret);
          }
          return ret;
        }
        Ember.copy = function (obj, deep) {
          if ('object' !== typeof obj || obj === null)
            return obj;
          if (Ember.Copyable && Ember.Copyable.detect(obj))
            return obj.copy(deep);
          return _copy(obj, deep, deep ? [] : null, deep ? [] : null);
        };
        Ember.inspect = function (obj) {
          if (typeof obj !== 'object' || obj === null) {
            return obj + '';
          }
          var v, ret = [];
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              v = obj[key];
              if (v === 'toString') {
                continue;
              }
              if (Ember.typeOf(v) === 'function') {
                v = 'function() { ... }';
              }
              ret.push(key + ': ' + v);
            }
          }
          return '{' + ret.join(', ') + '}';
        };
        Ember.isEqual = function (a, b) {
          if (a && 'function' === typeof a.isEqual)
            return a.isEqual(b);
          return a === b;
        };
        Ember.ORDER_DEFINITION = Ember.ENV.ORDER_DEFINITION || [
          'undefined',
          'null',
          'boolean',
          'number',
          'string',
          'array',
          'object',
          'instance',
          'function',
          'class',
          'date'
        ];
        Ember.keys = Object.keys;
        if (!Ember.keys) {
          Ember.keys = function (obj) {
            var ret = [];
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) {
                ret.push(key);
              }
            }
            return ret;
          };
        }
        var errorProps = [
            'description',
            'fileName',
            'lineNumber',
            'message',
            'name',
            'number',
            'stack'
          ];
        Ember.Error = function () {
          var tmp = Error.prototype.constructor.apply(this, arguments);
          for (var idx = 0; idx < errorProps.length; idx++) {
            this[errorProps[idx]] = tmp[errorProps[idx]];
          }
        };
        Ember.Error.prototype = Ember.create(Error.prototype);
      }());
      (function () {
        Ember.RSVP = requireModule('rsvp');
      }());
      (function () {
        var STRING_DASHERIZE_REGEXP = /[ _]/g;
        var STRING_DASHERIZE_CACHE = {};
        var STRING_DECAMELIZE_REGEXP = /([a-z])([A-Z])/g;
        var STRING_CAMELIZE_REGEXP = /(\-|_|\.|\s)+(.)?/g;
        var STRING_UNDERSCORE_REGEXP_1 = /([a-z\d])([A-Z]+)/g;
        var STRING_UNDERSCORE_REGEXP_2 = /\-|\s+/g;
        Ember.STRINGS = {};
        Ember.String = {
          fmt: function (str, formats) {
            var idx = 0;
            return str.replace(/%@([0-9]+)?/g, function (s, argIndex) {
              argIndex = argIndex ? parseInt(argIndex, 0) - 1 : idx++;
              s = formats[argIndex];
              return (s === null ? '(null)' : s === undefined ? '' : s).toString();
            });
          },
          loc: function (str, formats) {
            str = Ember.STRINGS[str] || str;
            return Ember.String.fmt(str, formats);
          },
          w: function (str) {
            return str.split(/\s+/);
          },
          decamelize: function (str) {
            return str.replace(STRING_DECAMELIZE_REGEXP, '$1_$2').toLowerCase();
          },
          dasherize: function (str) {
            var cache = STRING_DASHERIZE_CACHE, hit = cache.hasOwnProperty(str), ret;
            if (hit) {
              return cache[str];
            } else {
              ret = Ember.String.decamelize(str).replace(STRING_DASHERIZE_REGEXP, '-');
              cache[str] = ret;
            }
            return ret;
          },
          camelize: function (str) {
            return str.replace(STRING_CAMELIZE_REGEXP, function (match, separator, chr) {
              return chr ? chr.toUpperCase() : '';
            }).replace(/^([A-Z])/, function (match, separator, chr) {
              return match.toLowerCase();
            });
          },
          classify: function (str) {
            var parts = str.split('.'), out = [];
            for (var i = 0, l = parts.length; i < l; i++) {
              var camelized = Ember.String.camelize(parts[i]);
              out.push(camelized.charAt(0).toUpperCase() + camelized.substr(1));
            }
            return out.join('.');
          },
          underscore: function (str) {
            return str.replace(STRING_UNDERSCORE_REGEXP_1, '$1_$2').replace(STRING_UNDERSCORE_REGEXP_2, '_').toLowerCase();
          },
          capitalize: function (str) {
            return str.charAt(0).toUpperCase() + str.substr(1);
          }
        };
      }());
      (function () {
        var fmt = Ember.String.fmt, w = Ember.String.w, loc = Ember.String.loc, camelize = Ember.String.camelize, decamelize = Ember.String.decamelize, dasherize = Ember.String.dasherize, underscore = Ember.String.underscore, capitalize = Ember.String.capitalize, classify = Ember.String.classify;
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.String) {
          String.prototype.fmt = function () {
            return fmt(this, arguments);
          };
          String.prototype.w = function () {
            return w(this);
          };
          String.prototype.loc = function () {
            return loc(this, arguments);
          };
          String.prototype.camelize = function () {
            return camelize(this);
          };
          String.prototype.decamelize = function () {
            return decamelize(this);
          };
          String.prototype.dasherize = function () {
            return dasherize(this);
          };
          String.prototype.underscore = function () {
            return underscore(this);
          };
          String.prototype.classify = function () {
            return classify(this);
          };
          String.prototype.capitalize = function () {
            return capitalize(this);
          };
        }
      }());
      (function () {
        var a_slice = Array.prototype.slice;
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Function) {
          Function.prototype.property = function () {
            var ret = Ember.computed(this);
            return ret.property.apply(ret, arguments);
          };
          Function.prototype.observes = function () {
            this.__ember_observes__ = a_slice.call(arguments);
            return this;
          };
          Function.prototype.observesBefore = function () {
            this.__ember_observesBefore__ = a_slice.call(arguments);
            return this;
          };
        }
      }());
      (function () {
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        var a_slice = Array.prototype.slice;
        var a_indexOf = Ember.EnumerableUtils.indexOf;
        var contexts = [];
        function popCtx() {
          return contexts.length === 0 ? {} : contexts.pop();
        }
        function pushCtx(ctx) {
          contexts.push(ctx);
          return null;
        }
        function iter(key, value) {
          var valueProvided = arguments.length === 2;
          function i(item) {
            var cur = get(item, key);
            return valueProvided ? value === cur : !!cur;
          }
          return i;
        }
        Ember.Enumerable = Ember.Mixin.create({
          isEnumerable: true,
          nextObject: Ember.required(Function),
          firstObject: Ember.computed(function () {
            if (get(this, 'length') === 0)
              return undefined;
            var context = popCtx(), ret;
            ret = this.nextObject(0, null, context);
            pushCtx(context);
            return ret;
          }).property('[]'),
          lastObject: Ember.computed(function () {
            var len = get(this, 'length');
            if (len === 0)
              return undefined;
            var context = popCtx(), idx = 0, cur, last = null;
            do {
              last = cur;
              cur = this.nextObject(idx++, last, context);
            } while (cur !== undefined);
            pushCtx(context);
            return last;
          }).property('[]'),
          contains: function (obj) {
            return this.find(function (item) {
              return item === obj;
            }) !== undefined;
          },
          forEach: function (callback, target) {
            if (typeof callback !== 'function')
              throw new TypeError;
            var len = get(this, 'length'), last = null, context = popCtx();
            if (target === undefined)
              target = null;
            for (var idx = 0; idx < len; idx++) {
              var next = this.nextObject(idx, last, context);
              callback.call(target, next, idx, this);
              last = next;
            }
            last = null;
            context = pushCtx(context);
            return this;
          },
          getEach: function (key) {
            return this.mapProperty(key);
          },
          setEach: function (key, value) {
            return this.forEach(function (item) {
              set(item, key, value);
            });
          },
          map: function (callback, target) {
            var ret = Ember.A([]);
            this.forEach(function (x, idx, i) {
              ret[idx] = callback.call(target, x, idx, i);
            });
            return ret;
          },
          mapProperty: function (key) {
            return this.map(function (next) {
              return get(next, key);
            });
          },
          filter: function (callback, target) {
            var ret = Ember.A([]);
            this.forEach(function (x, idx, i) {
              if (callback.call(target, x, idx, i))
                ret.push(x);
            });
            return ret;
          },
          reject: function (callback, target) {
            return this.filter(function () {
              return !callback.apply(target, arguments);
            });
          },
          filterProperty: function (key, value) {
            return this.filter(iter.apply(this, arguments));
          },
          rejectProperty: function (key, value) {
            var exactValue = function (item) {
                return get(item, key) === value;
              }, hasValue = function (item) {
                return !!get(item, key);
              }, use = arguments.length === 2 ? exactValue : hasValue;
            return this.reject(use);
          },
          find: function (callback, target) {
            var len = get(this, 'length');
            if (target === undefined)
              target = null;
            var last = null, next, found = false, ret;
            var context = popCtx();
            for (var idx = 0; idx < len && !found; idx++) {
              next = this.nextObject(idx, last, context);
              if (found = callback.call(target, next, idx, this))
                ret = next;
              last = next;
            }
            next = last = null;
            context = pushCtx(context);
            return ret;
          },
          findProperty: function (key, value) {
            return this.find(iter.apply(this, arguments));
          },
          every: function (callback, target) {
            return !this.find(function (x, idx, i) {
              return !callback.call(target, x, idx, i);
            });
          },
          everyProperty: function (key, value) {
            return this.every(iter.apply(this, arguments));
          },
          some: function (callback, target) {
            return !!this.find(function (x, idx, i) {
              return !!callback.call(target, x, idx, i);
            });
          },
          someProperty: function (key, value) {
            return this.some(iter.apply(this, arguments));
          },
          reduce: function (callback, initialValue, reducerProperty) {
            if (typeof callback !== 'function') {
              throw new TypeError;
            }
            var ret = initialValue;
            this.forEach(function (item, i) {
              ret = callback.call(null, ret, item, i, this, reducerProperty);
            }, this);
            return ret;
          },
          invoke: function (methodName) {
            var args, ret = Ember.A([]);
            if (arguments.length > 1)
              args = a_slice.call(arguments, 1);
            this.forEach(function (x, idx) {
              var method = x && x[methodName];
              if ('function' === typeof method) {
                ret[idx] = args ? method.apply(x, args) : method.call(x);
              }
            }, this);
            return ret;
          },
          toArray: function () {
            var ret = Ember.A([]);
            this.forEach(function (o, idx) {
              ret[idx] = o;
            });
            return ret;
          },
          compact: function () {
            return this.filter(function (value) {
              return value != null;
            });
          },
          without: function (value) {
            if (!this.contains(value))
              return this;
            var ret = Ember.A([]);
            this.forEach(function (k) {
              if (k !== value)
                ret[ret.length] = k;
            });
            return ret;
          },
          uniq: function () {
            var ret = Ember.A([]);
            this.forEach(function (k) {
              if (a_indexOf(ret, k) < 0)
                ret.push(k);
            });
            return ret;
          },
          '[]': Ember.computed(function (key, value) {
            return this;
          }),
          addEnumerableObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'enumerableWillChange', didChange = opts && opts.didChange || 'enumerableDidChange';
            var hasObservers = get(this, 'hasEnumerableObservers');
            if (!hasObservers)
              Ember.propertyWillChange(this, 'hasEnumerableObservers');
            Ember.addListener(this, '@enumerable:before', target, willChange);
            Ember.addListener(this, '@enumerable:change', target, didChange);
            if (!hasObservers)
              Ember.propertyDidChange(this, 'hasEnumerableObservers');
            return this;
          },
          removeEnumerableObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'enumerableWillChange', didChange = opts && opts.didChange || 'enumerableDidChange';
            var hasObservers = get(this, 'hasEnumerableObservers');
            if (hasObservers)
              Ember.propertyWillChange(this, 'hasEnumerableObservers');
            Ember.removeListener(this, '@enumerable:before', target, willChange);
            Ember.removeListener(this, '@enumerable:change', target, didChange);
            if (hasObservers)
              Ember.propertyDidChange(this, 'hasEnumerableObservers');
            return this;
          },
          hasEnumerableObservers: Ember.computed(function () {
            return Ember.hasListeners(this, '@enumerable:change') || Ember.hasListeners(this, '@enumerable:before');
          }),
          enumerableContentWillChange: function (removing, adding) {
            var removeCnt, addCnt, hasDelta;
            if ('number' === typeof removing)
              removeCnt = removing;
            else if (removing)
              removeCnt = get(removing, 'length');
            else
              removeCnt = removing = -1;
            if ('number' === typeof adding)
              addCnt = adding;
            else if (adding)
              addCnt = get(adding, 'length');
            else
              addCnt = adding = -1;
            hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
            if (removing === -1)
              removing = null;
            if (adding === -1)
              adding = null;
            Ember.propertyWillChange(this, '[]');
            if (hasDelta)
              Ember.propertyWillChange(this, 'length');
            Ember.sendEvent(this, '@enumerable:before', [
              this,
              removing,
              adding
            ]);
            return this;
          },
          enumerableContentDidChange: function (removing, adding) {
            var removeCnt, addCnt, hasDelta;
            if ('number' === typeof removing)
              removeCnt = removing;
            else if (removing)
              removeCnt = get(removing, 'length');
            else
              removeCnt = removing = -1;
            if ('number' === typeof adding)
              addCnt = adding;
            else if (adding)
              addCnt = get(adding, 'length');
            else
              addCnt = adding = -1;
            hasDelta = addCnt < 0 || removeCnt < 0 || addCnt - removeCnt !== 0;
            if (removing === -1)
              removing = null;
            if (adding === -1)
              adding = null;
            Ember.sendEvent(this, '@enumerable:change', [
              this,
              removing,
              adding
            ]);
            if (hasDelta)
              Ember.propertyDidChange(this, 'length');
            Ember.propertyDidChange(this, '[]');
            return this;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, map = Ember.EnumerableUtils.map, cacheFor = Ember.cacheFor;
        function none(obj) {
          return obj === null || obj === undefined;
        }
        Ember.Array = Ember.Mixin.create(Ember.Enumerable, {
          isSCArray: true,
          length: Ember.required(),
          objectAt: function (idx) {
            if (idx < 0 || idx >= get(this, 'length'))
              return undefined;
            return get(this, idx);
          },
          objectsAt: function (indexes) {
            var self = this;
            return map(indexes, function (idx) {
              return self.objectAt(idx);
            });
          },
          nextObject: function (idx) {
            return this.objectAt(idx);
          },
          '[]': Ember.computed(function (key, value) {
            if (value !== undefined)
              this.replace(0, get(this, 'length'), value);
            return this;
          }),
          firstObject: Ember.computed(function () {
            return this.objectAt(0);
          }),
          lastObject: Ember.computed(function () {
            return this.objectAt(get(this, 'length') - 1);
          }),
          contains: function (obj) {
            return this.indexOf(obj) >= 0;
          },
          slice: function (beginIndex, endIndex) {
            var ret = Ember.A([]);
            var length = get(this, 'length');
            if (none(beginIndex))
              beginIndex = 0;
            if (none(endIndex) || endIndex > length)
              endIndex = length;
            if (beginIndex < 0)
              beginIndex = length + beginIndex;
            if (endIndex < 0)
              endIndex = length + endIndex;
            while (beginIndex < endIndex) {
              ret[ret.length] = this.objectAt(beginIndex++);
            }
            return ret;
          },
          indexOf: function (object, startAt) {
            var idx, len = get(this, 'length');
            if (startAt === undefined)
              startAt = 0;
            if (startAt < 0)
              startAt += len;
            for (idx = startAt; idx < len; idx++) {
              if (this.objectAt(idx, true) === object)
                return idx;
            }
            return -1;
          },
          lastIndexOf: function (object, startAt) {
            var idx, len = get(this, 'length');
            if (startAt === undefined || startAt >= len)
              startAt = len - 1;
            if (startAt < 0)
              startAt += len;
            for (idx = startAt; idx >= 0; idx--) {
              if (this.objectAt(idx) === object)
                return idx;
            }
            return -1;
          },
          addArrayObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'arrayWillChange', didChange = opts && opts.didChange || 'arrayDidChange';
            var hasObservers = get(this, 'hasArrayObservers');
            if (!hasObservers)
              Ember.propertyWillChange(this, 'hasArrayObservers');
            Ember.addListener(this, '@array:before', target, willChange);
            Ember.addListener(this, '@array:change', target, didChange);
            if (!hasObservers)
              Ember.propertyDidChange(this, 'hasArrayObservers');
            return this;
          },
          removeArrayObserver: function (target, opts) {
            var willChange = opts && opts.willChange || 'arrayWillChange', didChange = opts && opts.didChange || 'arrayDidChange';
            var hasObservers = get(this, 'hasArrayObservers');
            if (hasObservers)
              Ember.propertyWillChange(this, 'hasArrayObservers');
            Ember.removeListener(this, '@array:before', target, willChange);
            Ember.removeListener(this, '@array:change', target, didChange);
            if (hasObservers)
              Ember.propertyDidChange(this, 'hasArrayObservers');
            return this;
          },
          hasArrayObservers: Ember.computed(function () {
            return Ember.hasListeners(this, '@array:change') || Ember.hasListeners(this, '@array:before');
          }),
          arrayContentWillChange: function (startIdx, removeAmt, addAmt) {
            if (startIdx === undefined) {
              startIdx = 0;
              removeAmt = addAmt = -1;
            } else {
              if (removeAmt === undefined)
                removeAmt = -1;
              if (addAmt === undefined)
                addAmt = -1;
            }
            if (Ember.isWatching(this, '@each')) {
              get(this, '@each');
            }
            Ember.sendEvent(this, '@array:before', [
              this,
              startIdx,
              removeAmt,
              addAmt
            ]);
            var removing, lim;
            if (startIdx >= 0 && removeAmt >= 0 && get(this, 'hasEnumerableObservers')) {
              removing = [];
              lim = startIdx + removeAmt;
              for (var idx = startIdx; idx < lim; idx++)
                removing.push(this.objectAt(idx));
            } else {
              removing = removeAmt;
            }
            this.enumerableContentWillChange(removing, addAmt);
            return this;
          },
          arrayContentDidChange: function (startIdx, removeAmt, addAmt) {
            if (startIdx === undefined) {
              startIdx = 0;
              removeAmt = addAmt = -1;
            } else {
              if (removeAmt === undefined)
                removeAmt = -1;
              if (addAmt === undefined)
                addAmt = -1;
            }
            var adding, lim;
            if (startIdx >= 0 && addAmt >= 0 && get(this, 'hasEnumerableObservers')) {
              adding = [];
              lim = startIdx + addAmt;
              for (var idx = startIdx; idx < lim; idx++)
                adding.push(this.objectAt(idx));
            } else {
              adding = addAmt;
            }
            this.enumerableContentDidChange(removeAmt, adding);
            Ember.sendEvent(this, '@array:change', [
              this,
              startIdx,
              removeAmt,
              addAmt
            ]);
            var length = get(this, 'length'), cachedFirst = cacheFor(this, 'firstObject'), cachedLast = cacheFor(this, 'lastObject');
            if (this.objectAt(0) !== cachedFirst) {
              Ember.propertyWillChange(this, 'firstObject');
              Ember.propertyDidChange(this, 'firstObject');
            }
            if (this.objectAt(length - 1) !== cachedLast) {
              Ember.propertyWillChange(this, 'lastObject');
              Ember.propertyDidChange(this, 'lastObject');
            }
            return this;
          },
          '@each': Ember.computed(function () {
            if (!this.__each)
              this.__each = new Ember.EachProxy(this);
            return this.__each;
          })
        });
      }());
      (function () {
        Ember.Comparable = Ember.Mixin.create({
          isComparable: true,
          compare: Ember.required(Function)
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Copyable = Ember.Mixin.create({
          copy: Ember.required(Function),
          frozenCopy: function () {
            if (Ember.Freezable && Ember.Freezable.detect(this)) {
              return get(this, 'isFrozen') ? this : this.copy().freeze();
            } else {
              throw new Error(Ember.String.fmt('%@ does not support freezing', [this]));
            }
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Freezable = Ember.Mixin.create({
          isFrozen: false,
          freeze: function () {
            if (get(this, 'isFrozen'))
              return this;
            set(this, 'isFrozen', true);
            return this;
          }
        });
        Ember.FROZEN_ERROR = 'Frozen object cannot be modified.';
      }());
      (function () {
        var forEach = Ember.EnumerableUtils.forEach;
        Ember.MutableEnumerable = Ember.Mixin.create(Ember.Enumerable, {
          addObject: Ember.required(Function),
          addObjects: function (objects) {
            Ember.beginPropertyChanges(this);
            forEach(objects, function (obj) {
              this.addObject(obj);
            }, this);
            Ember.endPropertyChanges(this);
            return this;
          },
          removeObject: Ember.required(Function),
          removeObjects: function (objects) {
            Ember.beginPropertyChanges(this);
            forEach(objects, function (obj) {
              this.removeObject(obj);
            }, this);
            Ember.endPropertyChanges(this);
            return this;
          }
        });
      }());
      (function () {
        var OUT_OF_RANGE_EXCEPTION = 'Index out of range';
        var EMPTY = [];
        var get = Ember.get, set = Ember.set;
        Ember.MutableArray = Ember.Mixin.create(Ember.Array, Ember.MutableEnumerable, {
          replace: Ember.required(),
          clear: function () {
            var len = get(this, 'length');
            if (len === 0)
              return this;
            this.replace(0, len, EMPTY);
            return this;
          },
          insertAt: function (idx, object) {
            if (idx > get(this, 'length'))
              throw new Error(OUT_OF_RANGE_EXCEPTION);
            this.replace(idx, 0, [object]);
            return this;
          },
          removeAt: function (start, len) {
            if ('number' === typeof start) {
              if (start < 0 || start >= get(this, 'length')) {
                throw new Error(OUT_OF_RANGE_EXCEPTION);
              }
              if (len === undefined)
                len = 1;
              this.replace(start, len, EMPTY);
            }
            return this;
          },
          pushObject: function (obj) {
            this.insertAt(get(this, 'length'), obj);
            return obj;
          },
          pushObjects: function (objects) {
            this.replace(get(this, 'length'), 0, objects);
            return this;
          },
          popObject: function () {
            var len = get(this, 'length');
            if (len === 0)
              return null;
            var ret = this.objectAt(len - 1);
            this.removeAt(len - 1, 1);
            return ret;
          },
          shiftObject: function () {
            if (get(this, 'length') === 0)
              return null;
            var ret = this.objectAt(0);
            this.removeAt(0);
            return ret;
          },
          unshiftObject: function (obj) {
            this.insertAt(0, obj);
            return obj;
          },
          unshiftObjects: function (objects) {
            this.replace(0, 0, objects);
            return this;
          },
          reverseObjects: function () {
            var len = get(this, 'length');
            if (len === 0)
              return this;
            var objects = this.toArray().reverse();
            this.replace(0, len, objects);
            return this;
          },
          setObjects: function (objects) {
            if (objects.length === 0)
              return this.clear();
            var len = get(this, 'length');
            this.replace(0, len, objects);
            return this;
          },
          removeObject: function (obj) {
            var loc = get(this, 'length') || 0;
            while (--loc >= 0) {
              var curObject = this.objectAt(loc);
              if (curObject === obj)
                this.removeAt(loc);
            }
            return this;
          },
          addObject: function (obj) {
            if (!this.contains(obj))
              this.pushObject(obj);
            return this;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.Observable = Ember.Mixin.create({
          get: function (keyName) {
            return get(this, keyName);
          },
          getProperties: function () {
            var ret = {};
            var propertyNames = arguments;
            if (arguments.length === 1 && Ember.typeOf(arguments[0]) === 'array') {
              propertyNames = arguments[0];
            }
            for (var i = 0; i < propertyNames.length; i++) {
              ret[propertyNames[i]] = get(this, propertyNames[i]);
            }
            return ret;
          },
          set: function (keyName, value) {
            set(this, keyName, value);
            return this;
          },
          setProperties: function (hash) {
            return Ember.setProperties(this, hash);
          },
          beginPropertyChanges: function () {
            Ember.beginPropertyChanges();
            return this;
          },
          endPropertyChanges: function () {
            Ember.endPropertyChanges();
            return this;
          },
          propertyWillChange: function (keyName) {
            Ember.propertyWillChange(this, keyName);
            return this;
          },
          propertyDidChange: function (keyName) {
            Ember.propertyDidChange(this, keyName);
            return this;
          },
          notifyPropertyChange: function (keyName) {
            this.propertyWillChange(keyName);
            this.propertyDidChange(keyName);
            return this;
          },
          addBeforeObserver: function (key, target, method) {
            Ember.addBeforeObserver(this, key, target, method);
          },
          addObserver: function (key, target, method) {
            Ember.addObserver(this, key, target, method);
          },
          removeObserver: function (key, target, method) {
            Ember.removeObserver(this, key, target, method);
          },
          hasObserverFor: function (key) {
            return Ember.hasListeners(this, key + ':change');
          },
          getPath: function (path) {
            Ember.deprecate('getPath is deprecated since get now supports paths');
            return this.get(path);
          },
          setPath: function (path, value) {
            Ember.deprecate('setPath is deprecated since set now supports paths');
            return this.set(path, value);
          },
          getWithDefault: function (keyName, defaultValue) {
            return Ember.getWithDefault(this, keyName, defaultValue);
          },
          incrementProperty: function (keyName, increment) {
            if (!increment) {
              increment = 1;
            }
            set(this, keyName, (get(this, keyName) || 0) + increment);
            return get(this, keyName);
          },
          decrementProperty: function (keyName, increment) {
            if (!increment) {
              increment = 1;
            }
            set(this, keyName, (get(this, keyName) || 0) - increment);
            return get(this, keyName);
          },
          toggleProperty: function (keyName) {
            set(this, keyName, !get(this, keyName));
            return get(this, keyName);
          },
          cacheFor: function (keyName) {
            return Ember.cacheFor(this, keyName);
          },
          observersForKey: function (keyName) {
            return Ember.observersFor(this, keyName);
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        Ember.TargetActionSupport = Ember.Mixin.create({
          target: null,
          action: null,
          targetObject: Ember.computed(function () {
            var target = get(this, 'target');
            if (Ember.typeOf(target) === 'string') {
              var value = get(this, target);
              if (value === undefined) {
                value = get(Ember.lookup, target);
              }
              return value;
            } else {
              return target;
            }
          }).property('target'),
          triggerAction: function () {
            var action = get(this, 'action'), target = get(this, 'targetObject');
            if (target && action) {
              var ret;
              if (typeof target.send === 'function') {
                ret = target.send(action, this);
              } else {
                if (typeof action === 'string') {
                  action = target[action];
                }
                ret = action.call(target, this);
              }
              if (ret !== false)
                ret = true;
              return ret;
            } else {
              return false;
            }
          }
        });
      }());
      (function () {
        Ember.Evented = Ember.Mixin.create({
          on: function (name, target, method) {
            Ember.addListener(this, name, target, method);
            return this;
          },
          one: function (name, target, method) {
            if (!method) {
              method = target;
              target = null;
            }
            Ember.addListener(this, name, target, method, true);
            return this;
          },
          trigger: function (name) {
            var args = [], i, l;
            for (i = 1, l = arguments.length; i < l; i++) {
              args.push(arguments[i]);
            }
            Ember.sendEvent(this, name, args);
          },
          fire: function (name) {
            Ember.deprecate('Ember.Evented#fire() has been deprecated in favor of trigger() for compatibility with jQuery. It will be removed in 1.0. Please update your code to call trigger() instead.');
            this.trigger.apply(this, arguments);
          },
          off: function (name, target, method) {
            Ember.removeListener(this, name, target, method);
            return this;
          },
          has: function (name) {
            return Ember.hasListeners(this, name);
          }
        });
      }());
      (function () {
        var RSVP = requireModule('rsvp');
        RSVP.async = function (callback, binding) {
          Ember.run.schedule('actions', binding, callback);
        };
        var get = Ember.get;
        Ember.DeferredMixin = Ember.Mixin.create({
          then: function (doneCallback, failCallback) {
            var promise = get(this, 'promise');
            return promise.then.apply(promise, arguments);
          },
          resolve: function (value) {
            get(this, 'promise').resolve(value);
          },
          reject: function (value) {
            get(this, 'promise').reject(value);
          },
          promise: Ember.computed(function () {
            return new RSVP.Promise;
          })
        });
      }());
      (function () {
      }());
      (function () {
        Ember.Container = requireModule('container');
        Ember.Container.set = Ember.set;
      }());
      (function () {
        var set = Ember.set, get = Ember.get, o_create = Ember.create, o_defineProperty = Ember.platform.defineProperty, GUID_KEY = Ember.GUID_KEY, guidFor = Ember.guidFor, generateGuid = Ember.generateGuid, meta = Ember.meta, rewatch = Ember.rewatch, finishChains = Ember.finishChains, destroy = Ember.destroy, schedule = Ember.run.schedule, Mixin = Ember.Mixin, applyMixin = Mixin._apply, finishPartial = Mixin.finishPartial, reopen = Mixin.prototype.reopen, MANDATORY_SETTER = Ember.ENV.MANDATORY_SETTER, indexOf = Ember.EnumerableUtils.indexOf;
        var undefinedDescriptor = {
            configurable: true,
            writable: true,
            enumerable: false,
            value: undefined
          };
        function makeCtor() {
          var wasApplied = false, initMixins, initProperties;
          var Class = function () {
            if (!wasApplied) {
              Class.proto();
            }
            o_defineProperty(this, GUID_KEY, undefinedDescriptor);
            o_defineProperty(this, '_super', undefinedDescriptor);
            var m = meta(this);
            m.proto = this;
            if (initMixins) {
              var mixins = initMixins;
              initMixins = null;
              this.reopen.apply(this, mixins);
            }
            if (initProperties) {
              var props = initProperties;
              initProperties = null;
              var concatenatedProperties = this.concatenatedProperties;
              for (var i = 0, l = props.length; i < l; i++) {
                var properties = props[i];
                for (var keyName in properties) {
                  if (!properties.hasOwnProperty(keyName)) {
                    continue;
                  }
                  var value = properties[keyName], IS_BINDING = Ember.IS_BINDING;
                  if (IS_BINDING.test(keyName)) {
                    var bindings = m.bindings;
                    if (!bindings) {
                      bindings = m.bindings = {};
                    } else if (!m.hasOwnProperty('bindings')) {
                      bindings = m.bindings = o_create(m.bindings);
                    }
                    bindings[keyName] = value;
                  }
                  var desc = m.descs[keyName];
                  Ember.assert('Ember.Object.create no longer supports defining computed properties.', !(value instanceof Ember.ComputedProperty));
                  Ember.assert('Ember.Object.create no longer supports defining methods that call _super.', !(typeof value === 'function' && value.toString().indexOf('._super') !== -1));
                  if (concatenatedProperties && indexOf(concatenatedProperties, keyName) >= 0) {
                    var baseValue = this[keyName];
                    if (baseValue) {
                      if ('function' === typeof baseValue.concat) {
                        value = baseValue.concat(value);
                      } else {
                        value = Ember.makeArray(baseValue).concat(value);
                      }
                    } else {
                      value = Ember.makeArray(value);
                    }
                  }
                  if (desc) {
                    desc.set(this, keyName, value);
                  } else {
                    if (typeof this.setUnknownProperty === 'function' && !(keyName in this)) {
                      this.setUnknownProperty(keyName, value);
                    } else if (MANDATORY_SETTER) {
                      Ember.defineProperty(this, keyName, null, value);
                    } else {
                      this[keyName] = value;
                    }
                  }
                }
              }
            }
            finishPartial(this, m);
            delete m.proto;
            finishChains(this);
            this.init.apply(this, arguments);
          };
          Class.toString = Mixin.prototype.toString;
          Class.willReopen = function () {
            if (wasApplied) {
              Class.PrototypeMixin = Mixin.create(Class.PrototypeMixin);
            }
            wasApplied = false;
          };
          Class._initMixins = function (args) {
            initMixins = args;
          };
          Class._initProperties = function (args) {
            initProperties = args;
          };
          Class.proto = function () {
            var superclass = Class.superclass;
            if (superclass) {
              superclass.proto();
            }
            if (!wasApplied) {
              wasApplied = true;
              Class.PrototypeMixin.applyPartial(Class.prototype);
              rewatch(Class.prototype);
            }
            return this.prototype;
          };
          return Class;
        }
        var CoreObject = makeCtor();
        CoreObject.toString = function () {
          return 'Ember.CoreObject';
        };
        CoreObject.PrototypeMixin = Mixin.create({
          reopen: function () {
            applyMixin(this, arguments, true);
            return this;
          },
          isInstance: true,
          init: function () {
          },
          concatenatedProperties: null,
          isDestroyed: false,
          isDestroying: false,
          destroy: function () {
            if (this._didCallDestroy) {
              return;
            }
            this.isDestroying = true;
            this._didCallDestroy = true;
            schedule('destroy', this, this._scheduledDestroy);
            return this;
          },
          willDestroy: Ember.K,
          _scheduledDestroy: function () {
            if (this.willDestroy) {
              this.willDestroy();
            }
            destroy(this);
            this.isDestroyed = true;
            if (this.didDestroy) {
              this.didDestroy();
            }
          },
          bind: function (to, from) {
            if (!(from instanceof Ember.Binding)) {
              from = Ember.Binding.from(from);
            }
            from.to(to).connect(this);
            return from;
          },
          toString: function toString() {
            var hasToStringExtension = typeof this.toStringExtension === 'function', extension = hasToStringExtension ? ':' + this.toStringExtension() : '';
            var ret = '<' + this.constructor.toString() + ':' + guidFor(this) + extension + '>';
            this.toString = makeToString(ret);
            return ret;
          }
        });
        CoreObject.PrototypeMixin.ownerConstructor = CoreObject;
        function makeToString(ret) {
          return function () {
            return ret;
          };
        }
        if (Ember.config.overridePrototypeMixin) {
          Ember.config.overridePrototypeMixin(CoreObject.PrototypeMixin);
        }
        CoreObject.__super__ = null;
        var ClassMixin = Mixin.create({
            ClassMixin: Ember.required(),
            PrototypeMixin: Ember.required(),
            isClass: true,
            isMethod: false,
            extend: function () {
              var Class = makeCtor(), proto;
              Class.ClassMixin = Mixin.create(this.ClassMixin);
              Class.PrototypeMixin = Mixin.create(this.PrototypeMixin);
              Class.ClassMixin.ownerConstructor = Class;
              Class.PrototypeMixin.ownerConstructor = Class;
              reopen.apply(Class.PrototypeMixin, arguments);
              Class.superclass = this;
              Class.__super__ = this.prototype;
              proto = Class.prototype = o_create(this.prototype);
              proto.constructor = Class;
              generateGuid(proto, 'ember');
              meta(proto).proto = proto;
              Class.ClassMixin.apply(Class);
              return Class;
            },
            createWithMixins: function () {
              var C = this;
              if (arguments.length > 0) {
                this._initMixins(arguments);
              }
              return new C;
            },
            create: function () {
              var C = this;
              if (arguments.length > 0) {
                this._initProperties(arguments);
              }
              return new C;
            },
            reopen: function () {
              this.willReopen();
              reopen.apply(this.PrototypeMixin, arguments);
              return this;
            },
            reopenClass: function () {
              reopen.apply(this.ClassMixin, arguments);
              applyMixin(this, arguments, false);
              return this;
            },
            detect: function (obj) {
              if ('function' !== typeof obj) {
                return false;
              }
              while (obj) {
                if (obj === this) {
                  return true;
                }
                obj = obj.superclass;
              }
              return false;
            },
            detectInstance: function (obj) {
              return obj instanceof this;
            },
            metaForProperty: function (key) {
              var desc = meta(this.proto(), false).descs[key];
              Ember.assert("metaForProperty() could not find a computed property with key '" + key + "'.", !!desc && desc instanceof Ember.ComputedProperty);
              return desc._meta || {};
            },
            eachComputedProperty: function (callback, binding) {
              var proto = this.proto(), descs = meta(proto).descs, empty = {}, property;
              for (var name in descs) {
                property = descs[name];
                if (property instanceof Ember.ComputedProperty) {
                  callback.call(binding || this, name, property._meta || empty);
                }
              }
            }
          });
        ClassMixin.ownerConstructor = CoreObject;
        if (Ember.config.overrideClassMixin) {
          Ember.config.overrideClassMixin(ClassMixin);
        }
        CoreObject.ClassMixin = ClassMixin;
        ClassMixin.apply(CoreObject);
        Ember.CoreObject = CoreObject;
      }());
      (function () {
        Ember.Object = Ember.CoreObject.extend(Ember.Observable);
        Ember.Object.toString = function () {
          return 'Ember.Object';
        };
      }());
      (function () {
        var get = Ember.get, indexOf = Ember.ArrayPolyfills.indexOf;
        var Namespace = Ember.Namespace = Ember.Object.extend({
            isNamespace: true,
            init: function () {
              Ember.Namespace.NAMESPACES.push(this);
              Ember.Namespace.PROCESSED = false;
            },
            toString: function () {
              var name = get(this, 'name');
              if (name) {
                return name;
              }
              findNamespaces();
              return this[Ember.GUID_KEY + '_name'];
            },
            nameClasses: function () {
              processNamespace([this.toString()], this, {});
            },
            destroy: function () {
              var namespaces = Ember.Namespace.NAMESPACES;
              Ember.lookup[this.toString()] = undefined;
              namespaces.splice(indexOf.call(namespaces, this), 1);
              this._super();
            }
          });
        Namespace.reopenClass({
          NAMESPACES: [Ember],
          NAMESPACES_BY_ID: {},
          PROCESSED: false,
          processAll: processAllNamespaces,
          byName: function (name) {
            if (!Ember.BOOTED) {
              processAllNamespaces();
            }
            return NAMESPACES_BY_ID[name];
          }
        });
        var NAMESPACES_BY_ID = Namespace.NAMESPACES_BY_ID;
        var hasOwnProp = {}.hasOwnProperty, guidFor = Ember.guidFor;
        function processNamespace(paths, root, seen) {
          var idx = paths.length;
          NAMESPACES_BY_ID[paths.join('.')] = root;
          for (var key in root) {
            if (!hasOwnProp.call(root, key)) {
              continue;
            }
            var obj = root[key];
            paths[idx] = key;
            if (obj && obj.toString === classToString) {
              obj.toString = makeToString(paths.join('.'));
              obj[NAME_KEY] = paths.join('.');
            } else if (obj && obj.isNamespace) {
              if (seen[guidFor(obj)]) {
                continue;
              }
              seen[guidFor(obj)] = true;
              processNamespace(paths, obj, seen);
            }
          }
          paths.length = idx;
        }
        function findNamespaces() {
          var Namespace = Ember.Namespace, lookup = Ember.lookup, obj, isNamespace;
          if (Namespace.PROCESSED) {
            return;
          }
          for (var prop in lookup) {
            if (prop === 'parent' || prop === 'top' || prop === 'frameElement') {
              continue;
            }
            if (prop === 'globalStorage' && lookup.StorageList && lookup.globalStorage instanceof lookup.StorageList) {
              continue;
            }
            if (lookup.hasOwnProperty && !lookup.hasOwnProperty(prop)) {
              continue;
            }
            try {
              obj = Ember.lookup[prop];
              isNamespace = obj && obj.isNamespace;
            } catch (e) {
              continue;
            }
            if (isNamespace) {
              Ember.deprecate('Namespaces should not begin with lowercase.', /^[A-Z]/.test(prop));
              obj[NAME_KEY] = prop;
            }
          }
        }
        var NAME_KEY = Ember.NAME_KEY = Ember.GUID_KEY + '_name';
        function superClassString(mixin) {
          var superclass = mixin.superclass;
          if (superclass) {
            if (superclass[NAME_KEY]) {
              return superclass[NAME_KEY];
            } else {
              return superClassString(superclass);
            }
          } else {
            return;
          }
        }
        function classToString() {
          if (!Ember.BOOTED && !this[NAME_KEY]) {
            processAllNamespaces();
          }
          var ret;
          if (this[NAME_KEY]) {
            ret = this[NAME_KEY];
          } else {
            var str = superClassString(this);
            if (str) {
              ret = '(subclass of ' + str + ')';
            } else {
              ret = '(unknown mixin)';
            }
            this.toString = makeToString(ret);
          }
          return ret;
        }
        function processAllNamespaces() {
          var unprocessedNamespaces = !Namespace.PROCESSED, unprocessedMixins = Ember.anyUnprocessedMixins;
          if (unprocessedNamespaces) {
            findNamespaces();
            Namespace.PROCESSED = true;
          }
          if (unprocessedNamespaces || unprocessedMixins) {
            var namespaces = Namespace.NAMESPACES, namespace;
            for (var i = 0, l = namespaces.length; i < l; i++) {
              namespace = namespaces[i];
              processNamespace([namespace.toString()], namespace, {});
            }
            Ember.anyUnprocessedMixins = false;
          }
        }
        function makeToString(ret) {
          return function () {
            return ret;
          };
        }
        Ember.Mixin.prototype.toString = classToString;
      }());
      (function () {
        Ember.Application = Ember.Namespace.extend();
      }());
      (function () {
        var OUT_OF_RANGE_EXCEPTION = 'Index out of range';
        var EMPTY = [];
        var get = Ember.get, set = Ember.set;
        Ember.ArrayProxy = Ember.Object.extend(Ember.MutableArray, {
          content: null,
          arrangedContent: Ember.computed.alias('content'),
          objectAtContent: function (idx) {
            return get(this, 'arrangedContent').objectAt(idx);
          },
          replaceContent: function (idx, amt, objects) {
            get(this, 'content').replace(idx, amt, objects);
          },
          _contentWillChange: Ember.beforeObserver(function () {
            this._teardownContent();
          }, 'content'),
          _teardownContent: function () {
            var content = get(this, 'content');
            if (content) {
              content.removeArrayObserver(this, {
                willChange: 'contentArrayWillChange',
                didChange: 'contentArrayDidChange'
              });
            }
          },
          contentArrayWillChange: Ember.K,
          contentArrayDidChange: Ember.K,
          _contentDidChange: Ember.observer(function () {
            var content = get(this, 'content');
            Ember.assert("Can't set ArrayProxy's content to itself", content !== this);
            this._setupContent();
          }, 'content'),
          _setupContent: function () {
            var content = get(this, 'content');
            if (content) {
              content.addArrayObserver(this, {
                willChange: 'contentArrayWillChange',
                didChange: 'contentArrayDidChange'
              });
            }
          },
          _arrangedContentWillChange: Ember.beforeObserver(function () {
            var arrangedContent = get(this, 'arrangedContent'), len = arrangedContent ? get(arrangedContent, 'length') : 0;
            this.arrangedContentArrayWillChange(this, 0, len, undefined);
            this.arrangedContentWillChange(this);
            this._teardownArrangedContent(arrangedContent);
          }, 'arrangedContent'),
          _arrangedContentDidChange: Ember.observer(function () {
            var arrangedContent = get(this, 'arrangedContent'), len = arrangedContent ? get(arrangedContent, 'length') : 0;
            Ember.assert("Can't set ArrayProxy's content to itself", arrangedContent !== this);
            this._setupArrangedContent();
            this.arrangedContentDidChange(this);
            this.arrangedContentArrayDidChange(this, 0, undefined, len);
          }, 'arrangedContent'),
          _setupArrangedContent: function () {
            var arrangedContent = get(this, 'arrangedContent');
            if (arrangedContent) {
              arrangedContent.addArrayObserver(this, {
                willChange: 'arrangedContentArrayWillChange',
                didChange: 'arrangedContentArrayDidChange'
              });
            }
          },
          _teardownArrangedContent: function () {
            var arrangedContent = get(this, 'arrangedContent');
            if (arrangedContent) {
              arrangedContent.removeArrayObserver(this, {
                willChange: 'arrangedContentArrayWillChange',
                didChange: 'arrangedContentArrayDidChange'
              });
            }
          },
          arrangedContentWillChange: Ember.K,
          arrangedContentDidChange: Ember.K,
          objectAt: function (idx) {
            return get(this, 'content') && this.objectAtContent(idx);
          },
          length: Ember.computed(function () {
            var arrangedContent = get(this, 'arrangedContent');
            return arrangedContent ? get(arrangedContent, 'length') : 0;
          }),
          _replace: function (idx, amt, objects) {
            var content = get(this, 'content');
            Ember.assert('The content property of ' + this.constructor + ' should be set before modifying it', content);
            if (content)
              this.replaceContent(idx, amt, objects);
            return this;
          },
          replace: function () {
            if (get(this, 'arrangedContent') === get(this, 'content')) {
              this._replace.apply(this, arguments);
            } else {
              throw new Ember.Error('Using replace on an arranged ArrayProxy is not allowed.');
            }
          },
          _insertAt: function (idx, object) {
            if (idx > get(this, 'content.length'))
              throw new Error(OUT_OF_RANGE_EXCEPTION);
            this._replace(idx, 0, [object]);
            return this;
          },
          insertAt: function (idx, object) {
            if (get(this, 'arrangedContent') === get(this, 'content')) {
              return this._insertAt(idx, object);
            } else {
              throw new Ember.Error('Using insertAt on an arranged ArrayProxy is not allowed.');
            }
          },
          removeAt: function (start, len) {
            if ('number' === typeof start) {
              var content = get(this, 'content'), arrangedContent = get(this, 'arrangedContent'), indices = [], i;
              if (start < 0 || start >= get(this, 'length')) {
                throw new Error(OUT_OF_RANGE_EXCEPTION);
              }
              if (len === undefined)
                len = 1;
              for (i = start; i < start + len; i++) {
                indices.push(content.indexOf(arrangedContent.objectAt(i)));
              }
              indices.sort(function (a, b) {
                return b - a;
              });
              Ember.beginPropertyChanges();
              for (i = 0; i < indices.length; i++) {
                this._replace(indices[i], 1, EMPTY);
              }
              Ember.endPropertyChanges();
            }
            return this;
          },
          pushObject: function (obj) {
            this._insertAt(get(this, 'content.length'), obj);
            return obj;
          },
          pushObjects: function (objects) {
            this._replace(get(this, 'length'), 0, objects);
            return this;
          },
          setObjects: function (objects) {
            if (objects.length === 0)
              return this.clear();
            var len = get(this, 'length');
            this._replace(0, len, objects);
            return this;
          },
          unshiftObject: function (obj) {
            this._insertAt(0, obj);
            return obj;
          },
          unshiftObjects: function (objects) {
            this._replace(0, 0, objects);
            return this;
          },
          slice: function () {
            var arr = this.toArray();
            return arr.slice.apply(arr, arguments);
          },
          arrangedContentArrayWillChange: function (item, idx, removedCnt, addedCnt) {
            this.arrayContentWillChange(idx, removedCnt, addedCnt);
          },
          arrangedContentArrayDidChange: function (item, idx, removedCnt, addedCnt) {
            this.arrayContentDidChange(idx, removedCnt, addedCnt);
          },
          init: function () {
            this._super();
            this._setupContent();
            this._setupArrangedContent();
          },
          willDestroy: function () {
            this._teardownArrangedContent();
            this._teardownContent();
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, fmt = Ember.String.fmt, addBeforeObserver = Ember.addBeforeObserver, addObserver = Ember.addObserver, removeBeforeObserver = Ember.removeBeforeObserver, removeObserver = Ember.removeObserver, propertyWillChange = Ember.propertyWillChange, propertyDidChange = Ember.propertyDidChange;
        function contentPropertyWillChange(content, contentKey) {
          var key = contentKey.slice(8);
          if (key in this) {
            return;
          }
          propertyWillChange(this, key);
        }
        function contentPropertyDidChange(content, contentKey) {
          var key = contentKey.slice(8);
          if (key in this) {
            return;
          }
          propertyDidChange(this, key);
        }
        Ember.ObjectProxy = Ember.Object.extend({
          content: null,
          _contentDidChange: Ember.observer(function () {
            Ember.assert("Can't set ObjectProxy's content to itself", this.get('content') !== this);
          }, 'content'),
          isTruthy: Ember.computed.bool('content'),
          _debugContainerKey: null,
          willWatchProperty: function (key) {
            var contentKey = 'content.' + key;
            addBeforeObserver(this, contentKey, null, contentPropertyWillChange);
            addObserver(this, contentKey, null, contentPropertyDidChange);
          },
          didUnwatchProperty: function (key) {
            var contentKey = 'content.' + key;
            removeBeforeObserver(this, contentKey, null, contentPropertyWillChange);
            removeObserver(this, contentKey, null, contentPropertyDidChange);
          },
          unknownProperty: function (key) {
            var content = get(this, 'content');
            if (content) {
              return get(content, key);
            }
          },
          setUnknownProperty: function (key, value) {
            var content = get(this, 'content');
            Ember.assert(fmt("Cannot delegate set('%@', %@) to the 'content' property of object proxy %@: its 'content' is undefined.", [
              key,
              value,
              this
            ]), content);
            return set(content, key, value);
          }
        });
        Ember.ObjectProxy.reopenClass({
          create: function () {
            var mixin, prototype, i, l, properties, keyName;
            if (arguments.length) {
              prototype = this.proto();
              for (i = 0, l = arguments.length; i < l; i++) {
                properties = arguments[i];
                for (keyName in properties) {
                  if (!properties.hasOwnProperty(keyName) || keyName in prototype) {
                    continue;
                  }
                  if (!mixin)
                    mixin = {};
                  mixin[keyName] = null;
                }
              }
              if (mixin)
                this._initMixins([mixin]);
            }
            return this._super.apply(this, arguments);
          }
        });
      }());
      (function () {
        var set = Ember.set, get = Ember.get, guidFor = Ember.guidFor;
        var forEach = Ember.EnumerableUtils.forEach;
        var EachArray = Ember.Object.extend(Ember.Array, {
            init: function (content, keyName, owner) {
              this._super();
              this._keyName = keyName;
              this._owner = owner;
              this._content = content;
            },
            objectAt: function (idx) {
              var item = this._content.objectAt(idx);
              return item && get(item, this._keyName);
            },
            length: Ember.computed(function () {
              var content = this._content;
              return content ? get(content, 'length') : 0;
            })
          });
        var IS_OBSERVER = /^.+:(before|change)$/;
        function addObserverForContentKey(content, keyName, proxy, idx, loc) {
          var objects = proxy._objects, guid;
          if (!objects)
            objects = proxy._objects = {};
          while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
              Ember.addBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
              Ember.addObserver(item, keyName, proxy, 'contentKeyDidChange');
              guid = guidFor(item);
              if (!objects[guid])
                objects[guid] = [];
              objects[guid].push(loc);
            }
          }
        }
        function removeObserverForContentKey(content, keyName, proxy, idx, loc) {
          var objects = proxy._objects;
          if (!objects)
            objects = proxy._objects = {};
          var indicies, guid;
          while (--loc >= idx) {
            var item = content.objectAt(loc);
            if (item) {
              Ember.removeBeforeObserver(item, keyName, proxy, 'contentKeyWillChange');
              Ember.removeObserver(item, keyName, proxy, 'contentKeyDidChange');
              guid = guidFor(item);
              indicies = objects[guid];
              indicies[indicies.indexOf(loc)] = null;
            }
          }
        }
        Ember.EachProxy = Ember.Object.extend({
          init: function (content) {
            this._super();
            this._content = content;
            content.addArrayObserver(this);
            forEach(Ember.watchedEvents(this), function (eventName) {
              this.didAddListener(eventName);
            }, this);
          },
          unknownProperty: function (keyName, value) {
            var ret;
            ret = new EachArray(this._content, keyName, this);
            Ember.defineProperty(this, keyName, null, ret);
            this.beginObservingContentKey(keyName);
            return ret;
          },
          arrayWillChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, lim;
            lim = removedCnt > 0 ? idx + removedCnt : -1;
            Ember.beginPropertyChanges(this);
            for (key in keys) {
              if (!keys.hasOwnProperty(key)) {
                continue;
              }
              if (lim > 0)
                removeObserverForContentKey(content, key, this, idx, lim);
              Ember.propertyWillChange(this, key);
            }
            Ember.propertyWillChange(this._content, '@each');
            Ember.endPropertyChanges(this);
          },
          arrayDidChange: function (content, idx, removedCnt, addedCnt) {
            var keys = this._keys, key, lim;
            lim = addedCnt > 0 ? idx + addedCnt : -1;
            Ember.beginPropertyChanges(this);
            for (key in keys) {
              if (!keys.hasOwnProperty(key)) {
                continue;
              }
              if (lim > 0)
                addObserverForContentKey(content, key, this, idx, lim);
              Ember.propertyDidChange(this, key);
            }
            Ember.propertyDidChange(this._content, '@each');
            Ember.endPropertyChanges(this);
          },
          didAddListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
              this.beginObservingContentKey(eventName.slice(0, -7));
            }
          },
          didRemoveListener: function (eventName) {
            if (IS_OBSERVER.test(eventName)) {
              this.stopObservingContentKey(eventName.slice(0, -7));
            }
          },
          beginObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (!keys)
              keys = this._keys = {};
            if (!keys[keyName]) {
              keys[keyName] = 1;
              var content = this._content, len = get(content, 'length');
              addObserverForContentKey(content, keyName, this, 0, len);
            } else {
              keys[keyName]++;
            }
          },
          stopObservingContentKey: function (keyName) {
            var keys = this._keys;
            if (keys && keys[keyName] > 0 && --keys[keyName] <= 0) {
              var content = this._content, len = get(content, 'length');
              removeObserverForContentKey(content, keyName, this, 0, len);
            }
          },
          contentKeyWillChange: function (obj, keyName) {
            Ember.propertyWillChange(this, keyName);
          },
          contentKeyDidChange: function (obj, keyName) {
            Ember.propertyDidChange(this, keyName);
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set;
        var NativeArray = Ember.Mixin.create(Ember.MutableArray, Ember.Observable, Ember.Copyable, {
            get: function (key) {
              if (key === 'length')
                return this.length;
              else if ('number' === typeof key)
                return this[key];
              else
                return this._super(key);
            },
            objectAt: function (idx) {
              return this[idx];
            },
            replace: function (idx, amt, objects) {
              if (this.isFrozen)
                throw Ember.FROZEN_ERROR;
              var len = objects ? get(objects, 'length') : 0;
              this.arrayContentWillChange(idx, amt, len);
              if (!objects || objects.length === 0) {
                this.splice(idx, amt);
              } else {
                var args = [
                    idx,
                    amt
                  ].concat(objects);
                this.splice.apply(this, args);
              }
              this.arrayContentDidChange(idx, amt, len);
              return this;
            },
            unknownProperty: function (key, value) {
              var ret;
              if (value !== undefined && ret === undefined) {
                ret = this[key] = value;
              }
              return ret;
            },
            indexOf: function (object, startAt) {
              var idx, len = this.length;
              if (startAt === undefined)
                startAt = 0;
              else
                startAt = startAt < 0 ? Math.ceil(startAt) : Math.floor(startAt);
              if (startAt < 0)
                startAt += len;
              for (idx = startAt; idx < len; idx++) {
                if (this[idx] === object)
                  return idx;
              }
              return -1;
            },
            lastIndexOf: function (object, startAt) {
              var idx, len = this.length;
              if (startAt === undefined)
                startAt = len - 1;
              else
                startAt = startAt < 0 ? Math.ceil(startAt) : Math.floor(startAt);
              if (startAt < 0)
                startAt += len;
              for (idx = startAt; idx >= 0; idx--) {
                if (this[idx] === object)
                  return idx;
              }
              return -1;
            },
            copy: function (deep) {
              if (deep) {
                return this.map(function (item) {
                  return Ember.copy(item, true);
                });
              }
              return this.slice();
            }
          });
        var ignore = ['length'];
        Ember.EnumerableUtils.forEach(NativeArray.keys(), function (methodName) {
          if (Array.prototype[methodName])
            ignore.push(methodName);
        });
        if (ignore.length > 0) {
          NativeArray = NativeArray.without.apply(NativeArray, ignore);
        }
        Ember.NativeArray = NativeArray;
        Ember.A = function (arr) {
          if (arr === undefined) {
            arr = [];
          }
          return Ember.Array.detect(arr) ? arr : Ember.NativeArray.apply(arr);
        };
        Ember.NativeArray.activate = function () {
          NativeArray.apply(Array.prototype);
          Ember.A = function (arr) {
            return arr || [];
          };
        };
        if (Ember.EXTEND_PROTOTYPES === true || Ember.EXTEND_PROTOTYPES.Array) {
          Ember.NativeArray.activate();
        }
      }());
      (function () {
        var get = Ember.get, set = Ember.set, guidFor = Ember.guidFor, none = Ember.isNone, fmt = Ember.String.fmt;
        Ember.Set = Ember.CoreObject.extend(Ember.MutableEnumerable, Ember.Copyable, Ember.Freezable, {
          length: 0,
          clear: function () {
            if (this.isFrozen) {
              throw new Error(Ember.FROZEN_ERROR);
            }
            var len = get(this, 'length');
            if (len === 0) {
              return this;
            }
            var guid;
            this.enumerableContentWillChange(len, 0);
            Ember.propertyWillChange(this, 'firstObject');
            Ember.propertyWillChange(this, 'lastObject');
            for (var i = 0; i < len; i++) {
              guid = guidFor(this[i]);
              delete this[guid];
              delete this[i];
            }
            set(this, 'length', 0);
            Ember.propertyDidChange(this, 'firstObject');
            Ember.propertyDidChange(this, 'lastObject');
            this.enumerableContentDidChange(len, 0);
            return this;
          },
          isEqual: function (obj) {
            if (!Ember.Enumerable.detect(obj))
              return false;
            var loc = get(this, 'length');
            if (get(obj, 'length') !== loc)
              return false;
            while (--loc >= 0) {
              if (!obj.contains(this[loc]))
                return false;
            }
            return true;
          },
          add: Ember.aliasMethod('addObject'),
          remove: Ember.aliasMethod('removeObject'),
          pop: function () {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            var obj = this.length > 0 ? this[this.length - 1] : null;
            this.remove(obj);
            return obj;
          },
          push: Ember.aliasMethod('addObject'),
          shift: Ember.aliasMethod('pop'),
          unshift: Ember.aliasMethod('push'),
          addEach: Ember.aliasMethod('addObjects'),
          removeEach: Ember.aliasMethod('removeObjects'),
          init: function (items) {
            this._super();
            if (items)
              this.addObjects(items);
          },
          nextObject: function (idx) {
            return this[idx];
          },
          firstObject: Ember.computed(function () {
            return this.length > 0 ? this[0] : undefined;
          }),
          lastObject: Ember.computed(function () {
            return this.length > 0 ? this[this.length - 1] : undefined;
          }),
          addObject: function (obj) {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            if (none(obj))
              return this;
            var guid = guidFor(obj), idx = this[guid], len = get(this, 'length'), added;
            if (idx >= 0 && idx < len && this[idx] === obj)
              return this;
            added = [obj];
            this.enumerableContentWillChange(null, added);
            Ember.propertyWillChange(this, 'lastObject');
            len = get(this, 'length');
            this[guid] = len;
            this[len] = obj;
            set(this, 'length', len + 1);
            Ember.propertyDidChange(this, 'lastObject');
            this.enumerableContentDidChange(null, added);
            return this;
          },
          removeObject: function (obj) {
            if (get(this, 'isFrozen'))
              throw new Error(Ember.FROZEN_ERROR);
            if (none(obj))
              return this;
            var guid = guidFor(obj), idx = this[guid], len = get(this, 'length'), isFirst = idx === 0, isLast = idx === len - 1, last, removed;
            if (idx >= 0 && idx < len && this[idx] === obj) {
              removed = [obj];
              this.enumerableContentWillChange(removed, null);
              if (isFirst) {
                Ember.propertyWillChange(this, 'firstObject');
              }
              if (isLast) {
                Ember.propertyWillChange(this, 'lastObject');
              }
              if (idx < len - 1) {
                last = this[len - 1];
                this[idx] = last;
                this[guidFor(last)] = idx;
              }
              delete this[guid];
              delete this[len - 1];
              set(this, 'length', len - 1);
              if (isFirst) {
                Ember.propertyDidChange(this, 'firstObject');
              }
              if (isLast) {
                Ember.propertyDidChange(this, 'lastObject');
              }
              this.enumerableContentDidChange(removed, null);
            }
            return this;
          },
          contains: function (obj) {
            return this[guidFor(obj)] >= 0;
          },
          copy: function () {
            var C = this.constructor, ret = new C, loc = get(this, 'length');
            set(ret, 'length', loc);
            while (--loc >= 0) {
              ret[loc] = this[loc];
              ret[guidFor(this[loc])] = loc;
            }
            return ret;
          },
          toString: function () {
            var len = this.length, idx, array = [];
            for (idx = 0; idx < len; idx++) {
              array[idx] = this[idx];
            }
            return fmt('Ember.Set<%@>', [array.join(',')]);
          }
        });
      }());
      (function () {
        var DeferredMixin = Ember.DeferredMixin, get = Ember.get;
        var Deferred = Ember.Object.extend(DeferredMixin);
        Deferred.reopenClass({
          promise: function (callback, binding) {
            var deferred = Deferred.create();
            callback.call(binding, deferred);
            return get(deferred, 'promise');
          }
        });
        Ember.Deferred = Deferred;
      }());
      (function () {
        var loadHooks = Ember.ENV.EMBER_LOAD_HOOKS || {};
        var loaded = {};
        Ember.onLoad = function (name, callback) {
          var object;
          loadHooks[name] = loadHooks[name] || Ember.A();
          loadHooks[name].pushObject(callback);
          if (object = loaded[name]) {
            callback(object);
          }
        };
        Ember.runLoadHooks = function (name, object) {
          var hooks;
          loaded[name] = object;
          if (hooks = loadHooks[name]) {
            loadHooks[name].forEach(function (callback) {
              callback(object);
            });
          }
        };
      }());
      (function () {
      }());
      (function () {
        var get = Ember.get;
        Ember.ControllerMixin = Ember.Mixin.create({
          isController: true,
          target: null,
          container: null,
          store: null,
          model: Ember.computed.alias('content'),
          send: function (actionName) {
            var args = [].slice.call(arguments, 1), target;
            if (this[actionName]) {
              Ember.assert('The controller ' + this + ' does not have the action ' + actionName, typeof this[actionName] === 'function');
              this[actionName].apply(this, args);
            } else if (target = get(this, 'target')) {
              Ember.assert('The target for controller ' + this + ' (' + target + ') did not define a `send` method', typeof target.send === 'function');
              target.send.apply(target, arguments);
            }
          }
        });
        Ember.Controller = Ember.Object.extend(Ember.ControllerMixin);
      }());
      (function () {
        var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach;
        Ember.SortableMixin = Ember.Mixin.create(Ember.MutableEnumerable, {
          sortProperties: null,
          sortAscending: true,
          orderBy: function (item1, item2) {
            var result = 0, sortProperties = get(this, 'sortProperties'), sortAscending = get(this, 'sortAscending');
            Ember.assert('you need to define `sortProperties`', !!sortProperties);
            forEach(sortProperties, function (propertyName) {
              if (result === 0) {
                result = Ember.compare(get(item1, propertyName), get(item2, propertyName));
                if (result !== 0 && !sortAscending) {
                  result = -1 * result;
                }
              }
            });
            return result;
          },
          destroy: function () {
            var content = get(this, 'content'), sortProperties = get(this, 'sortProperties');
            if (content && sortProperties) {
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super();
          },
          isSorted: Ember.computed.bool('sortProperties'),
          arrangedContent: Ember.computed('content', 'sortProperties.@each', function (key, value) {
            var content = get(this, 'content'), isSorted = get(this, 'isSorted'), sortProperties = get(this, 'sortProperties'), self = this;
            if (content && isSorted) {
              content = content.slice();
              content.sort(function (item1, item2) {
                return self.orderBy(item1, item2);
              });
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.addObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
              return Ember.A(content);
            }
            return content;
          }),
          _contentWillChange: Ember.beforeObserver(function () {
            var content = get(this, 'content'), sortProperties = get(this, 'sortProperties');
            if (content && sortProperties) {
              forEach(content, function (item) {
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            this._super();
          }, 'content'),
          sortAscendingWillChange: Ember.beforeObserver(function () {
            this._lastSortAscending = get(this, 'sortAscending');
          }, 'sortAscending'),
          sortAscendingDidChange: Ember.observer(function () {
            if (get(this, 'sortAscending') !== this._lastSortAscending) {
              var arrangedContent = get(this, 'arrangedContent');
              arrangedContent.reverseObjects();
            }
          }, 'sortAscending'),
          contentArrayWillChange: function (array, idx, removedCount, addedCount) {
            var isSorted = get(this, 'isSorted');
            if (isSorted) {
              var arrangedContent = get(this, 'arrangedContent');
              var removedObjects = array.slice(idx, idx + removedCount);
              var sortProperties = get(this, 'sortProperties');
              forEach(removedObjects, function (item) {
                arrangedContent.removeObject(item);
                forEach(sortProperties, function (sortProperty) {
                  Ember.removeObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super(array, idx, removedCount, addedCount);
          },
          contentArrayDidChange: function (array, idx, removedCount, addedCount) {
            var isSorted = get(this, 'isSorted'), sortProperties = get(this, 'sortProperties');
            if (isSorted) {
              var addedObjects = array.slice(idx, idx + addedCount);
              forEach(addedObjects, function (item) {
                this.insertItemSorted(item);
                forEach(sortProperties, function (sortProperty) {
                  Ember.addObserver(item, sortProperty, this, 'contentItemSortPropertyDidChange');
                }, this);
              }, this);
            }
            return this._super(array, idx, removedCount, addedCount);
          },
          insertItemSorted: function (item) {
            var arrangedContent = get(this, 'arrangedContent');
            var length = get(arrangedContent, 'length');
            var idx = this._binarySearch(item, 0, length);
            arrangedContent.insertAt(idx, item);
          },
          contentItemSortPropertyDidChange: function (item) {
            var arrangedContent = get(this, 'arrangedContent'), oldIndex = arrangedContent.indexOf(item), leftItem = arrangedContent.objectAt(oldIndex - 1), rightItem = arrangedContent.objectAt(oldIndex + 1), leftResult = leftItem && this.orderBy(item, leftItem), rightResult = rightItem && this.orderBy(item, rightItem);
            if (leftResult < 0 || rightResult > 0) {
              arrangedContent.removeObject(item);
              this.insertItemSorted(item);
            }
          },
          _binarySearch: function (item, low, high) {
            var mid, midItem, res, arrangedContent;
            if (low === high) {
              return low;
            }
            arrangedContent = get(this, 'arrangedContent');
            mid = low + Math.floor((high - low) / 2);
            midItem = arrangedContent.objectAt(mid);
            res = this.orderBy(midItem, item);
            if (res < 0) {
              return this._binarySearch(item, mid + 1, high);
            } else if (res > 0) {
              return this._binarySearch(item, low, mid);
            }
            return mid;
          }
        });
      }());
      (function () {
        var get = Ember.get, set = Ember.set, forEach = Ember.EnumerableUtils.forEach, replace = Ember.EnumerableUtils.replace;
        Ember.ArrayController = Ember.ArrayProxy.extend(Ember.ControllerMixin, Ember.SortableMixin, {
          itemController: null,
          lookupItemController: function (object) {
            return get(this, 'itemController');
          },
          objectAtContent: function (idx) {
            var length = get(this, 'length'), arrangedContent = get(this, 'arrangedContent'), object = arrangedContent && arrangedContent.objectAt(idx);
            if (idx >= 0 && idx < length) {
              var controllerClass = this.lookupItemController(object);
              if (controllerClass) {
                return this.controllerAt(idx, object, controllerClass);
              }
            }
            return object;
          },
          arrangedContentDidChange: function () {
            this._super();
            this._resetSubControllers();
          },
          arrayContentDidChange: function (idx, removedCnt, addedCnt) {
            var subControllers = get(this, '_subControllers'), subControllersToRemove = subControllers.slice(idx, idx + removedCnt);
            forEach(subControllersToRemove, function (subController) {
              if (subController) {
                subController.destroy();
              }
            });
            replace(subControllers, idx, removedCnt, new Array(addedCnt));
            this._super(idx, removedCnt, addedCnt);
          },
          init: function () {
            this._super();
            if (!this.get('content')) {
              Ember.defineProperty(this, 'content', undefined, Ember.A());
            }
            this.set('_subControllers', Ember.A());
          },
          controllerAt: function (idx, object, controllerClass) {
            var container = get(this, 'container'), subControllers = get(this, '_subControllers'), subController = subControllers[idx];
            if (!subController) {
              subController = container.lookup('controller:' + controllerClass, { singleton: false });
              subControllers[idx] = subController;
            }
            if (!subController) {
              throw new Error('Could not resolve itemController: "' + controllerClass + '"');
            }
            subController.set('target', this);
            subController.set('content', object);
            return subController;
          },
          _subControllers: null,
          _resetSubControllers: function () {
            var subControllers = get(this, '_subControllers');
            forEach(subControllers, function (subController) {
              if (subController) {
                subController.destroy();
              }
            });
            this.set('_subControllers', Ember.A());
          }
        });
      }());
      (function () {
        Ember.ObjectController = Ember.ObjectProxy.extend(Ember.ControllerMixin);
      }());
      (function () {
      }());
      (function () {
      }());
    }());
  });
  require.define('/lib/functional-helpers.js', function (module, exports, __dirname, __filename) {
    var concat, foldl, map, nub, span;
    this.any = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (fn(e))
          return true;
      }
      return false;
    };
    this.all = function (list, fn) {
      var e;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        e = list[i$];
        if (!fn(e))
          return false;
      }
      return true;
    };
    this.foldl = foldl = function (memo, list, fn) {
      var i;
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        memo = fn(memo, i);
      }
      return memo;
    };
    this.foldl1 = function (list, fn) {
      return foldl(list[0], list.slice(1), fn);
    };
    this.map = map = function (list, fn) {
      var e;
      return function (accum$) {
        for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
          e = list[i$];
          accum$.push(fn(e));
        }
        return accum$;
      }.call(this, []);
    };
    this.concat = concat = function (list) {
      var cache$;
      return (cache$ = []).concat.apply(cache$, [].slice.call(list));
    };
    this.concatMap = function (list, fn) {
      return concat(map(list, fn));
    };
    this.intersect = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.difference = function (listA, listB) {
      var a;
      return function (accum$) {
        for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
          a = listA[i$];
          if (!!in$(a, listB))
            continue;
          accum$.push(a);
        }
        return accum$;
      }.call(this, []);
    };
    this.nub = nub = function (list) {
      var i, result;
      result = [];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        i = list[i$];
        if (!!in$(i, result))
          continue;
        result.push(i);
      }
      return result;
    };
    this.union = function (listA, listB) {
      var b;
      return listA.concat(function (accum$) {
        for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
          b = cache$[i$];
          if (!!in$(b, listA))
            continue;
          accum$.push(b);
        }
        return accum$;
      }.call(this, []));
    };
    this.flip = function (fn) {
      return function (b, a) {
        return fn.call(this, a, b);
      };
    };
    this.owns = function (hop) {
      return function (a, b) {
        return hop.call(a, b);
      };
    }({}.hasOwnProperty);
    this.span = span = function (list, f) {
      var cache$, ys, zs;
      if (list.length === 0) {
        return [
          [],
          []
        ];
      } else if (f(list[0])) {
        cache$ = span(list.slice(1), f);
        ys = cache$[0];
        zs = cache$[1];
        return [
          [list[0]].concat([].slice.call(ys)),
          zs
        ];
      } else {
        return [
          [],
          list
        ];
      }
    };
    this.divMod = function (a, b) {
      var c, div, mod;
      c = a % b;
      mod = c < 0 ? c + b : c;
      div = Math.floor(a / b);
      return [
        div,
        mod
      ];
    };
    this.partition = function (list, fn) {
      var item, result;
      result = [
        [],
        []
      ];
      for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
        item = list[i$];
        result[+!fn(item)].push(item);
      }
      return result;
    };
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
  });
  require.define('/src/preprocessor.coffee', function (module, exports, __dirname, __filename) {
    var DEDENT, INDENT, pointToErrorLocation, Preprocessor, StringScanner, TERM, ws;
    pointToErrorLocation = require('/src/helpers.coffee', module).pointToErrorLocation;
    StringScanner = require('/node_modules/StringScanner/lib/StringScanner.js', module);
    this.Preprocessor = Preprocessor = function () {
      ws = '\\t\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
      INDENT = '\uEFEF';
      DEDENT = '\uEFFE';
      TERM = '\uEFFF';
      function Preprocessor(param$) {
        if (null == param$)
          param$ = {};
        this.options = param$;
        this.preprocessed = '';
        this.base = null;
        this.indents = [];
        this.context = [];
      }
      Preprocessor.process = function (input, options) {
        if (null == options)
          options = {};
        return new Preprocessor(options).process(input);
      };
      Preprocessor.prototype.err = function (c) {
        var columns, context, lines, token;
        token = function () {
          switch (c) {
          case INDENT:
            return 'INDENT';
          case DEDENT:
            return 'DEDENT';
          case TERM:
            return 'TERM';
          default:
            return '"' + c.replace(/"/g, '\\"') + '"';
          }
        }.call(this);
        lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
        columns = null != lines[lines.length - 1] ? lines[lines.length - 1].length : 0;
        context = pointToErrorLocation(this.ss.str, lines.length, columns);
        throw new Error('Unexpected ' + token + '\n' + context);
      };
      Preprocessor.prototype.peek = function () {
        if (this.context.length) {
          return this.context[this.context.length - 1];
        } else {
          return null;
        }
      };
      Preprocessor.prototype.observe = function (c) {
        var top;
        top = this.peek();
        switch (c) {
        case '"""':
        case "'''":
        case '"':
        case "'":
        case '###':
        case '`':
        case '///':
        case '/':
          if (top === c) {
            this.context.pop();
          } else {
            this.context.push(c);
          }
          break;
        case INDENT:
        case '#':
        case '#{':
        case '[':
        case '(':
        case '{':
        case '\\':
        case 'regexp-[':
        case 'regexp-(':
        case 'regexp-{':
        case 'heregexp-#':
        case 'heregexp-[':
        case 'heregexp-(':
        case 'heregexp-{':
          this.context.push(c);
          break;
        case DEDENT:
          if (!(top === INDENT))
            this.err(c);
          this.indents.pop();
          this.context.pop();
          break;
        case '\n':
          if (!(top === '#' || top === 'heregexp-#'))
            this.err(c);
          this.context.pop();
          break;
        case ']':
          if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
            this.err(c);
          this.context.pop();
          break;
        case ')':
          if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
            this.err(c);
          this.context.pop();
          break;
        case '}':
          if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
            this.err(c);
          this.context.pop();
          break;
        case 'end-\\':
          if (!(top === '\\'))
            this.err(c);
          this.context.pop();
          break;
        default:
          throw new Error('undefined token observed: ' + c);
        }
        return this.context;
      };
      Preprocessor.prototype.p = function (s) {
        if (null != s)
          this.preprocessed = '' + this.preprocessed + s;
        return s;
      };
      Preprocessor.prototype.scan = function (r) {
        return this.p(this.ss.scan(r));
      };
      Preprocessor.prototype.consumeIndentation = function () {
        var context, indent, indentIndex, lineLen, lines, message;
        if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
          this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
          if (null != this.base) {
            if (!(this.ss.eos() || null != this.scan(this.base)))
              throw new Error('inconsistent base indentation');
          } else {
            this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
          }
          indentIndex = 0;
          while (indentIndex < this.indents.length) {
            indent = this.indents[indentIndex];
            if (this.ss.check(new RegExp('' + indent + ''))) {
              this.scan(new RegExp('' + indent + ''));
            } else if (this.ss.eos() || this.ss.check(new RegExp('[^' + ws + ']'))) {
              --indentIndex;
              this.p('' + DEDENT + TERM);
              this.observe(DEDENT);
            } else {
              lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
              message = 'Syntax error on line ' + lines.length + ': indentation is ambiguous';
              lineLen = this.indents.reduce(function (l, r) {
                return l + r.length;
              }, 0);
              context = pointToErrorLocation(this.ss.str, lines.length, lineLen);
              throw new Error('' + message + '\n' + context);
            }
            ++indentIndex;
          }
          if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
            this.indents.push(this.scan(new RegExp('[' + ws + ']+')));
            this.p(INDENT);
            return this.observe(INDENT);
          }
        }
      };
      Preprocessor.prototype.introduceContext = function () {
        var impliedRegexp, lastChar, pos, spaceBefore, tok;
        if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
          return this.observe(tok);
        } else if (tok = this.scan(/\//)) {
          pos = this.ss.position();
          if (pos > 1) {
            lastChar = this.ss.string()[pos - 2];
            spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
            impliedRegexp = /[;,=><*%^&|[(+!~-]/.test(lastChar);
          }
          if (pos === 1 || impliedRegexp || spaceBefore && !this.ss.check(new RegExp('[' + ws + '=]')) && this.ss.check(/[^\r\n]*\//))
            return this.observe('/');
        }
      };
      Preprocessor.prototype.process = function (input) {
        var tok;
        if (this.options.literate)
          input = input.replace(/^( {0,3}\S)/gm, '    #$1');
        this.ss = new StringScanner(input);
        while (!this.ss.eos()) {
          switch (this.peek()) {
          case null:
          case INDENT:
            this.consumeIndentation();
            this.scan(/[^\n'"\\\/#`[(){}\]]+/);
            if (this.ss.check(/[})\]]/)) {
              while (this.peek() === INDENT) {
                this.p('' + DEDENT + TERM);
                this.observe(DEDENT);
              }
              this.observe(this.scan(/[})\]]/));
            } else {
              this.introduceContext();
            }
            break;
          case '#{':
          case '{':
            this.scan(/[^\n'"\\\/#`[({}]+/);
            if (tok = this.scan(/\}/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '[':
            this.scan(/[^\n'"\\\/#`[({\]]+/);
            if (tok = this.scan(/\]/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '(':
            this.scan(/[^\n'"\\\/#`[({)]+/);
            if (tok = this.scan(/\)/)) {
              this.observe(tok);
            } else {
              this.consumeIndentation();
              this.introduceContext();
            }
            break;
          case '\\':
            if (this.scan(/[\s\S]/))
              this.observe('end-\\');
            break;
          case '"""':
            this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"""/)) {
              this.observe(tok);
            } else if (tok = this.scan(/#{|"""/)) {
              this.observe(tok);
            }
            break;
          case '"':
            this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/#{|"/))
              this.observe(tok);
            break;
          case "'''":
            this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'''/))
              this.observe(tok);
            break;
          case "'":
            this.scan(/(?:[^'\\]+|\\.)+/);
            this.ss.scan(/\\\n/);
            if (tok = this.scan(/'/))
              this.observe(tok);
            break;
          case '###':
            this.scan(/(?:[^#]+|##?(?!#))+/);
            if (tok = this.scan(/###/))
              this.observe(tok);
            break;
          case '#':
            this.scan(/[^\n]+/);
            if (tok = this.scan(/\n/))
              this.observe(tok);
            break;
          case '`':
            this.scan(/[^`]+/);
            if (tok = this.scan(/`/))
              this.observe(tok);
            break;
          case '///':
            this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
            if (tok = this.scan(/#{|\/\/\/|\\/)) {
              this.observe(tok);
            } else if (this.ss.scan(/#/)) {
              this.observe('heregexp-#');
            } else if (tok = this.scan(/[\[]/)) {
              this.observe('heregexp-' + tok);
            }
            break;
          case 'heregexp-[':
            this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/[\]\\]|#{|\/\/\//))
              this.observe(tok);
            break;
          case 'heregexp-#':
            this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
            if (tok = this.scan(/\n|\/\/\//))
              this.observe(tok);
            break;
          case '/':
            this.scan(/[^[/\\]+/);
            if (tok = this.scan(/[\/\\]/)) {
              this.observe(tok);
            } else if (tok = this.scan(/\[/)) {
              this.observe('regexp-' + tok);
            }
            break;
          case 'regexp-[':
            this.scan(/[^\]\\]+/);
            if (tok = this.scan(/[\]\\]/))
              this.observe(tok);
          }
        }
        this.scan(new RegExp('[' + ws + '\\n]*$'));
        while (this.context.length) {
          switch (this.peek()) {
          case INDENT:
            this.p('' + DEDENT + TERM);
            this.observe(DEDENT);
            break;
          case '#':
            this.p('\n');
            this.observe('\n');
            break;
          default:
            throw new Error('Unclosed "' + this.peek().replace(/"/g, '\\"') + '" at EOF');
          }
        }
        return this.preprocessed;
      };
      return Preprocessor;
    }();
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function extends$(child, parent) {
      for (var key in parent)
        if (isOwn$(parent, key))
          child[key] = parent[key];
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor;
      child.__super__ = parent.prototype;
      return child;
    }
  });
  require.define('/node_modules/StringScanner/lib/StringScanner.js', function (module, exports, __dirname, __filename) {
    (function () {
      var StringScanner;
      StringScanner = function () {
        function StringScanner(str) {
          this.str = str != null ? str : '';
          this.str = '' + this.str;
          this.pos = 0;
          this.lastMatch = {
            reset: function () {
              this.str = null;
              this.captures = [];
              return this;
            }
          }.reset();
          this;
        }
        StringScanner.prototype.bol = function () {
          return this.pos <= 0 || this.str[this.pos - 1] === '\n';
        };
        StringScanner.prototype.captures = function () {
          return this.lastMatch.captures;
        };
        StringScanner.prototype.check = function (pattern) {
          var matches;
          if (this.str.substr(this.pos).search(pattern) !== 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str;
        };
        StringScanner.prototype.checkUntil = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);
          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.captures = matches.slice(1);
          return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
        };
        StringScanner.prototype.clone = function () {
          var clone, prop, value, _ref;
          clone = new this.constructor(this.str);
          clone.pos = this.pos;
          clone.lastMatch = {};
          _ref = this.lastMatch;
          for (prop in _ref) {
            value = _ref[prop];
            clone.lastMatch[prop] = value;
          }
          return clone;
        };
        StringScanner.prototype.concat = function (str) {
          this.str += str;
          return this;
        };
        StringScanner.prototype.eos = function () {
          return this.pos === this.str.length;
        };
        StringScanner.prototype.exists = function (pattern) {
          var matches, patternPos;
          patternPos = this.str.substr(this.pos).search(pattern);
          if (patternPos < 0) {
            this.lastMatch.reset();
            return null;
          }
          matches = this.str.substr(this.pos + patternPos).match(pattern);
          this.lastMatch.str = matches[0];
          this.lastMatch.captures = matches.slice(1);
          return patternPos;
        };
        StringScanner.prototype.getch = function () {
          return this.scan(/./);
        };
        StringScanner.prototype.match = function () {
          return this.lastMatch.str;
        };
        StringScanner.prototype.matches = function (pattern) {
          this.check(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.matched = function () {
          return this.lastMatch.str != null;
        };
        StringScanner.prototype.matchSize = function () {
          if (this.matched()) {
            return this.match().length;
          } else {
            return null;
          }
        };
        StringScanner.prototype.peek = function (len) {
          return this.str.substr(this.pos, len);
        };
        StringScanner.prototype.pointer = function () {
          return this.pos;
        };
        StringScanner.prototype.setPointer = function (pos) {
          pos = +pos;
          if (pos < 0) {
            pos = 0;
          }
          if (pos > this.str.length) {
            pos = this.str.length;
          }
          return this.pos = pos;
        };
        StringScanner.prototype.reset = function () {
          this.lastMatch.reset();
          this.pos = 0;
          return this;
        };
        StringScanner.prototype.rest = function () {
          return this.str.substr(this.pos);
        };
        StringScanner.prototype.scan = function (pattern) {
          var chk;
          chk = this.check(pattern);
          if (chk != null) {
            this.pos += chk.length;
          }
          return chk;
        };
        StringScanner.prototype.scanUntil = function (pattern) {
          var chk;
          chk = this.checkUntil(pattern);
          if (chk != null) {
            this.pos += chk.length;
          }
          return chk;
        };
        StringScanner.prototype.skip = function (pattern) {
          this.scan(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.skipUntil = function (pattern) {
          this.scanUntil(pattern);
          return this.matchSize();
        };
        StringScanner.prototype.string = function () {
          return this.str;
        };
        StringScanner.prototype.terminate = function () {
          this.pos = this.str.length;
          this.lastMatch.reset();
          return this;
        };
        StringScanner.prototype.toString = function () {
          return '#<StringScanner ' + (this.eos() ? 'fin' : '' + this.pos + '/' + this.str.length + ' @ ' + (this.str.length > 8 ? '' + this.str.substr(0, 5) + '...' : this.str)) + '>';
        };
        return StringScanner;
      }();
      StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
      StringScanner.prototype.clear = StringScanner.prototype.terminate;
      StringScanner.prototype.dup = StringScanner.prototype.clone;
      StringScanner.prototype.endOfString = StringScanner.prototype.eos;
      StringScanner.prototype.exist = StringScanner.prototype.exists;
      StringScanner.prototype.getChar = StringScanner.prototype.getch;
      StringScanner.prototype.position = StringScanner.prototype.pointer;
      StringScanner.StringScanner = StringScanner;
      module.exports = StringScanner;
    }.call(this));
  });
  global.EmberScript = require('/src/browser.coffee');
}.call(this, this));
//# sourceMappingURL=dist/ember-script.js.map
